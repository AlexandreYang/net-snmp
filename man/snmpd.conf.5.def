.TH SNMPD.CONF 5 "08 Feb 2002" VVERSIONINFO "Net-SNMP"
.UC 4
.SH NAME
snmpd.conf - configuration file for the Net-SNMP SNMP agent
.SH DESCRIPTION
.B snmpd.conf
is the configuration file which defines how the Net-SNMP SNMP agent
operates.  These files may contain any of the directives found in the
.B DIRECTIVES
section below.  If this file is not found (or does not contain any
access control directives), the agent will run but will not respond
to any requests.
.SH PLEASE READ FIRST
First, make sure you have read the
.I snmp_config(5) 
manual page that describes how the Net-SNMP configuration files
operate, where they are located and how they all work together.
.PP
Also, you might consider looking into the
.B snmpconf
application (perl script) which can help you build an snmpd.conf file
by prompting you for information.  You should try it.  Really.  Go
ahead.  Right now.  Run:
.RS
.IP "snmpconf -g basic_setup"
.RE
.PP
to get you started. See the
.I snmpconf(1)
manual page for more information.
.SH EXTENSIBLE-MIB
.PP
The Net-SNMP SNMP agent reports much of its information through
queries to the EXTENSIBLEDOTMIB section of the MIB tree.  Every MIB in
this section has the following table entries in it.
.IP ".MIBINDEX -- index"
This is the table's index numbers for each of the DIRECTIVES listed below.
.IP ".ERRORNAME -- name"
The name of the given table entry.  This should be unique, but is not
required to be.
.IP ".ERRORFLAG -- errorFlag"
This is a flag returning either the integer value 1 or 0 if an error
is detected for this table entry.
.IP ".ERRORMSG -- errorMsg"
This is a DISPLAY-STRING describing any error triggering the errorFlag above.
.IP ".ERRORFIX -- errorFix"
If this entry is set to the integer value of 1 AND the errorFlag
defined above is indeed a 1, a program or script will get executed
with the table entry name from above as the argument.  The program to
be executed is configured in the net-snmp-config.h file at compile time.
.SS Directives
.IP "proc NAME"
.IP "proc NAME MAX"
.IP "proc NAME MAX MIN"
.IP
Checks to see if processes called NAME are running on the agent
machine.  An error flag (1) and a description message are then passed
to the EXTENSIBLEDOTMIB.PROCMIBNUM.1.ERRORFLAG and
EXTENSIBLEDOTMIB.PROCMIBNUM.1.ERRORMSG MIB columns (respectively) if
the NAME'd program is not found in the process table as reported by
PSCMD.
.IP
If MAX and MIN are not specified, MAX is assumed to be 
.B infinity
and MIN is assumed to be 1.
.IP
If MAX is specified but MIN is not specified, MIN is assumed to be 0.
.IP "procfix NAME PROG ARGS"
This registers a command that knows how to fix errors with the given
process NAME.  When EXTENSIBLEDOTMIB.PROCMIBNUM.1.ERRORFIX for a given
NAMEd program is set to the integer value of 1, this command will be
called.  It defaults to a compiled value set using the PROCFIXCMD
definition in the net-snmp-config.h file.
.IP "disk PATH"
.IP "disk PATH [ MINSPACE | MINPERCENT% ]"
.IP
Checks the named disks mounted at PATH for available disk space.  If
the disk space is less than MINSPACE (kB) if specified or less than
MINPERCENT (%) if a % sign is specified, or DEFDISKMINIMUMSPACE (kB)
if not specified, the associated entry in the
EXTENSIBLEDOTMIB.DISKMIBNUM.1.ERRORFLAG MIB table will be set to (1) and
a descriptive error message will be returned to queries of
EXTENSIBLEDOTMIB.DISKMIBNUM.1.ERRORMSG.
.IP "includeAllDisks MINPERCENT%"
.IP
Adds  all  the  disks  that can be found on the system using the
setmntent(3) and getmntent(3), or fopen(3) and getmntent(3),  or
setfsent(3)  and  getfsent(3) system calls. If none of the above
system calls are available then it adds the root partition  "/",
(which  is  assumed to exist on any UNIX based system) using the
statfs(2) system call.
.IP
There can only be one 'includeAllDisks' directive in the config-
uration  file.  It  can  be  used in conjunction with the 'disk'
directive. They may be used in any order. The  'disk'  directive
overrides  the  disk  usage  specified  by the 'includeAllDisks'
directive, no matter in which order they are  specified  in  the
configuration file.
.IP
The 'includeAllDisks' directive only includes the disks that are
mounted when the snmpd daemon  is  started.  It  cannot  include
disks  that are dynamically loadable, such as with automount. So
the preferred way is to mount all the disks that will ever  need
to be monitored before starting the snmpd daemon.
.IP "load MAX1"
.IP "load MAX1 MAX5"
.IP "load MAX1 MAX5 MAX15"
.IP
Checks the load average of the machine and returns an error flag (1),
and an text-string error message
to queries of EXTENSIBLEDOTMIB.LOADAVEMIBNUM.1.ERRORFLAG and
EXTENSIBLEDOTMIB.LOADAVEMIBNUM.1.ERRORMSG (respectively) when the
1-minute, 5-minute, or 15-minute averages exceed the associated
maximum values.  If any of the MAX1, MAX5, or MAX15 values are
unspecified, they default to a value of DEFMAXLOADAVE.
.IP "file FILE [MAXSIZE]"
Monitors file sizes and makes sure they don't grow beyond a certain
size (in kilobytes).  MAXSIZE defaults to infinite if not specified,
and only monitors the size without reporting errors about it.
A maximum of 20 files can be monitored.
.IP "logmatch NAME PATH CYCLETIME REGEX"
Configures log file monitoring that can be queried via the
UCD-SNMP-MIB::logMatchTable.
.SS "Errors"
.PP
Any errors in obtaining the above information are reported via the
EXTENSIBLEDOTMIB.ERRORMIBNUM.1.ERRORFLAG flag and the
EXTENSIBLEDOTMIB.ERRORMIBNUM.1.ERRORMSG text-string description.
.SH ACCESS CONTROL
.B snmpd
supports the View-Based Access Control Model (VACM) as defined in RFC
2575, to control who can retrieve or update information.  To this end,
it recognizes various directives relating to access control.
These fall into three basic groups.
.SS Traditional Access Control
Most simple access control requirements can be specified using the
directives \fIrouser\fR/\fIrwuser\fR (for SNMPv3) or
\fIrocommunity\fR/\fIrwcommunity\fR (for SNMPv1 or SNMPv2c).
.IP "rouser USER [noauth|auth|priv [OID]]"
.IP "rwuser USER [noauth|auth|priv [OID]]"
specify an SNMPv3 USM user that will be allowed read-only (GET and GETNEXT)
or read-write (GET, GETNEXT and SET) access respectively.
By default, this will provide access to the full OID tree for authenticated
(including encrypted) SNMPv3 requests.
An alternative minimum security level can be specified using the \fInoauth\fR
or \fIpriv\fR tokens (to allow unauthenticated requests, or enforce use of
encryption respectively).  The OID parameter restricts access for that
user to the subtree rooted at the given OID.
.IP "rocommunity COMMUNITY [SOURCE [OID]]"
.IP "rwcommunity COMMUNITY [SOURCE [OID]]"
specify an SNMPv1 or SNMPv2c community that will be allowed read-only
(GET and GETNEXT) or read-write (GET, GETNEXT and SET) access respectively.
By default, this will provide access to the full OID tree for such requests,
regardless of where they were sent from. The SOURCE token can be used to
restrict access to requests from the specified system(s) - see
\fIcom2sec\fR for the full details.  The OID parameter restricts access for
that community to the subtree rooted at the given OID.
.IP "rocommunity6 COMMUNITY [SOURCE [OID]]"
.IP "rwcommunity6 COMMUNITY [SOURCE [OID]]"
are equivalent directives, relating to requests received using IPv6-based
transports (if the agent supports such transport domains).
The interpretation of the SOURCE and OID tokens are exactly the same as for
the IPv4 equivalents.
.PP
In each case, only one directive should be specified for a given SNMPv3 user,
or community string. More complex access requirements (such as access to two
or more distinct OID subtrees, or different views for GET and SET requests)
should use one of the other access control mechanisms.
.PP
In particular, it is \fBnot\fR appropriate to specify both \fIrouser\fR
and \fIrwuser\fR directives referring to the same SNMPv3 user (or equivalent
community settings). The \fIrwuser\fR directive provides all the access
of \fIrouser\fR (as well as allowing SET support).
.PP
Note that if several distinct communities or SNMPv3 users need to be granted
the same level of access, it would be more efficient to use the main VACM
configuration directives.
.SS VACM Configuration
The full flexibility of the VACM is available using four configuration
directives - \fIcom2sec\fR, \fIgroup\fR, \fIview\fR and \fIaccess\fR.
These provide direct configuration of the underlying VACM tables.
.IP "com2sec  [-Cn CONTEXT] NAME SOURCE COMMUNITY"
.IP "com2sec6 [-Cn CONTEXT] NAME SOURCE COMMUNITY"
map an SNMPv1 or SNMPv2c community string to a security name - either from
a particular range of source addresses, or globally (\fI"default"\fR).
A restricted source can either be a specific hostname (or address), or
a subnet - represented as IP/MASK (e.g. 10.10.10.0/255.255.255.0), or as
IP/BITS (e.g. 10.10.10.0/24) - or the IPv6 equivalents.
.IP
The same community string can be specified in several separate directives
(presumably with different source tokens), and the first source/community
combination that matches the incoming request will be selected.
The same security name can also appear in several separate directives.
.IP
If a CONTEXT is specified (using \fI-Cn\fR), the community string will be
mapped to a security name in the named SNMPv3 context. Otherwise the
default context ("") will be used.
.IP "com2secunix [-Cn CONTEXT] NAME SOCKPATH COMMUNITY"
is the Unix domain sockets version of \fIcom2sec\fR.
.IP "group NAME MODEL SECURITY"
maps one or more security names (in the specified security model) into
a named group, which allows a single access setting to apply to several
users and/or community strings.
MODEL is one of \fIv1\fR, \fIv2c\fR, or \fIusm\fR.
.IP
Note that the two community-based models must be specified separately -
a single \fIcom2sec\fR (or equivalent) directive will typically be
accompanied by \fBtwo\fR \fIgroup\fR directives.
.IP "view NAME TYPE SUBTREE [MASK]"
defines a named "view" - a subset of the overall OID tree. This is most
commonly a single subtree, but several \fIview\fR directives can be given
with the same view name, to build up a more complex collection of OIDs.
TYPE is either \fIincluded\fR or \fIexcluded\fR, which can again define
a more complex view (e.g by excluding certain sensitive objects
from an otherwise accessible subtree).
.IP
MASK is a list of hex octets (separated by '.' or ':') with the set bits
indicating which subidentifiers in the view OID to match against.  This
can be used to define a view covering all columns of selected rows in a
table.  If not specified, this defaults to matching the OID exactly
(all bits set), thus defining a simple OID subtree.
.IP "access NAME CONTEXT MODEL LEVEL PREFX READ WRITE NOTIFY"
maps from a group of users/communities (with a particular security model
and minimum security level, and in a specific context) to one of three views,
depending on the request being processed.
.IP
MODEL is one of \fIany\fR, \fIv1\fR, \fIv2c\fR, or \fIusm\fR.
LEVEL is one of \fInoauth\fR, \fIauth\fR, or \fIpriv\fR.
PREFX specifies how CONTEXT should be matched against the context of
the incoming request, either \fIexact\fR or \fIprefix\fR.
READ, WRITE and NOTIFY specifies the view to be used for GET*, SET
and TRAP/INFORM requests (althought the NOTIFY view is not currently used).
For v1 or v2c access, LEVEL will need to be \fInoauth\fR.
.SS Typed-View Configuration
The final group of access control directives extend the VACM approach to a
more flexible mechanism, which can be applied more widely. Rather than
the fixed three views of the standard VACM mechanism, this can be used to
configure various different view types.  As far as the main SNMP agent is
concerned, the two main view types are \fIread\fR and \fIwrite\fR,
corresponding to the READ and WRITE views of the main \fIaccess\fR directive.
See the 'snmptrapd.conf(5)' man page for discussion of other view types.
.IP "authcommunity TYPES  COMMUNITY   [SOURCE [OID | -v VIEW]]"
.IP "authuser   TYPES [-s MODEL] USER  [LEVEL [OID | -v VIEW]]"
are alternative versions of the \fIrocommunity\fR/\fIrwcommunity\fR
and \fIrouser\fR/\fIrwuser\fR directives respectively.  TYPES will
usually be \fIread\fR or \fIread,write\fR.
The view specification can either be an OID subtree (as with
the earlier directives), or a named view (defined using the
\fIview\fR directive) for greater flexibility.  If this is omitted,
then access will be allowed to the full OID tree.
.IP "authgroup  TYPES [-s MODEL] GROUP [LEVEL [OID | -v VIEW]]"
is a companion to the \fIauthuser\fR directive, specifying access
for a particular group (defined using the \fIgroup\fR directive as usual).
Both \fIauthuser\fR and \fIauthgroup\fR default to authenticated requests -
LEVEL can also be specified as \fInoauth\fR or \fIpriv\fR to allow
unauthenticated requests, or require encryption respectively.
Both \fIauthuser\fR and \fIauthgroup\fR directives also default to configuring
access for SNMPv3/USM requests - use the '-s' flag to specify an alternative
security model (using the same values as for \fIaccess\fR above).
.IP "authaccess TYPES [-s MODEL] GROUP VIEW [LEVEL [CONTEXT]]"
also configures the access for a particular group,
specifying the name and type of view to apply. The MODEL and LEVEL fields
are interpreted in the same way as for \fIauthgroup\fI.
If CONTEXT is specified, access is configured within this SNMPv3 context
(or contexts with this prefix if the CONTEXT field ends with '*'),
otherwise the default context ("") is used.
.IP "setaccess CONTEXT MODEL LEVEL PREFIX VIEW TYPES"
is a direct equivalent to the original \fIaccess\fR directive, typically
listing the view types as \fIread\fR or \fIread,write\fR as appropriate.
(or see 'snmptrapd.conf(5)' for other possibilities).
All other fields have the same interpretation as with \fIaccess\fR.
.SS "VACM Examples:"
.nf
#        sec.name  source          community
com2sec  local     localhost       private
com2sec  mynet     10.10.10.0/24   public
com2sec  public    default         public
com2sec6 mynet     fec0::/64       public

#             sec.model  sec.name
group mygroup v1         mynet
group mygroup v2c        mynet
group mygroup usm        mynet
group local   v1         local
group local   v2c        local
group local   usm        local
group public  v1         public
group public  v2c        public
group public  usm        public

#           incl/excl subtree                          mask
view all    included  .1                               80
view system included  system                           fe
view mib2   included  .iso.org.dod.internet.mgmt.mib-2 fc

#              context sec.model sec.level prefix read   write notify
access mygroup ""      any       noauth    exact  mib2   none  none
access public  ""      any       noauth    exact  system none  none
access local   ""      any       noauth    exact  all    all   all
.IP "Default VACM model"
The default configuration of the agent, as shipped, is functionally
equivalent to the following entries:
.nf
com2sec	public	default	public
group	public	v1	public
group	public	v2c	public
group	public	usm	public
view 	all	included	.1
access	public	""	any	noauth	exact	all	none	none
.fi
.RE
.SH SNMPv3 CONFIGURATION
.PP
.IP "engineID STRING"
The snmpd agent needs to be configured with a unique engineID to be able to
respond to SNMPv3 messages.  With this configuration file line, the
engineID will be configured from STRING. 
.IP "engineIDType 1|2|3"
Defines that the engineID should be built from the IPv4 address (1), IPv6 address (2) or MAC address (3). Beware that you might run into trouble on IP 
address changes!
.IP "engineIDNic interface"
Defines the interface (e.g. "eth1") that should be used to determine the MAC address in case of "engineIDType 3". Default is eth0.
.P
If neither an engineID, engineIDType or engineIDNic directive is present, 
the value of the engineID is built from 2 fairly random elements:
a random number and the current time in seconds. This is the recommended
approach.
.IP "createUser [-e ENGINEID] username (MD5|SHA) authpassphrase [DES|AES] [privpassphrase]"
.IP
MD5 and SHA are the authentication types to use.  DES and AES are the
privacy protocols to use.  If the privacy
passphrase is not specified, it is assumed to be the same as the
authentication passphrase.  Note that the users created will be
useless unless they are also added to the VACM access control tables
described above.
.IP
SHA authentication and DES/AES privacy require OpenSSL to be installed and
the agent to be built with OpenSSL support.  MD5 authentication may be
used without OpenSSL.
.IP
Warning: the minimum pass phrase length is 8 characters.
.IP
SNMPv3 users can be created at runtime using the
.I snmpusm(1)
command.
.IP
Instead of figuring out how to use this directive and where to put it
(see below), just run "net-snmp-config --create-snmpv3-user" instead,
which will add one of these lines to the right place.
.IP
This directive should be placed into the
PERSISTENT_DIRECTORY/snmpd.conf file instead of the other normal
locations.  The reason is that the information is read from the file
and then the line is removed (eliminating the storage of the master
password for that user) and replaced with the key that is derived from
it.  This key is a localized key, so that if it is stolen it can not
be used to access other agents.  If the password is stolen, however,
it can be.
.IP
If you need to localize the user to a particular EngineID (this is
useful mostly in the similar snmptrapd.conf file), you can use the -e
argument to specify an EngineID as a hex value (EG, "0x01020304").
.IP
If you want to generate either your master or localized keys directly,
replace the given password with a hexstring (preceeded by a "0x") and
precede the hex string by a -m or -l token (respectively).  EGs:
.IP
.RS
.nf
[these keys are *not* secure but are easy to visually parse for
counting purposes.  Please generate random keys instead of using
these examples]

createUser myuser SHA -l 0x0001020304050607080900010203040506070809 AES -l 0x00010203040506070809000102030405
createUser myuser SHA -m 0x0001020304050607080900010203040506070809 AES -m 0x0001020304050607080900010203040506070809
.fi
.RE
.IP
Due to the way localization happens, localized privacy keys are
expected to be the length needed by the algorithm (128 bits for all
supported algorithms).  Master encryption keys, though, need to be the
length required by the authentication algorithm not the length
required by the encrypting algorithm (MD5: 16 bytes, SHA: 20 bytes).
.IP
.SH SETTING SYSTEM INFORMATION
.IP "syslocation STRING"
.IP "syscontact STRING"
.IP "sysname STRING"
Sets the system location, system contact or system name for the agent.
This information is reported in the 'system' group the mibII tree.
Ordinarily these objects (sysLocation.0, sysContact.0 and sysName.0)
are read-write.  However, specifying the value for one of these
objects by giving the appropriate token makes the corresponding object
read-only, and attempts to set the value of the object will result in
a notWritable error response.
.IP "sysservices NUMBER"
Sets the value of the system.sysServices.0 object.
For a host, a good value is 72.
.IP "sysdescr STRING"
.IP "sysobjectid OID"
Sets the system description or object ID for the agent.
Although these values are not SNMP-writable, it is conceivable
that a network administrator may wish to configure them to something
other than the default values.
.IP "leave_pidfile yes"
Instructs the agent to not remove its pid file on shutdown. Equivalent to
specifying "-U" on the command line.
.IP "agentaddress [<transport-specifier>:]<transport-address>[,...]"
Makes the agent list on the specified comma-separated list of
listening addresses instead of the default behaviour, which is to
listen on UDP port 161 on all IPv4 interfaces.  See the section 
.B LISTENING ADDRESSES
in the
.I snmpd(8)
manual page for more information about the format of listening
addresses.  For example, specifying
.I "agentaddress 161,tcp:161,localhost:9161"
will make the agent listen on UDP port 161 on all IPv4 interfaces, TCP
port 161 on all IPv4 interfaces and UDP port 9161 only on the interface
associated with the localhost address.
.IP "agentgroup groupid"
Change to this gid after opening port. The groupid may refer to a group
by name or a number if the group number starts with '#'. For example,
specifying
.I agentgroup snmp
will cause the agent to run as the snmp group or
.I agentgroup #10
will cause the agent to run as the group with groupid 10.
.IP "agentuser uid"
Change to this uid after opening port. The userid may refer to a user
by name or a number if the user number starts with '#'. For example,
specifying
.I agentuser snmp
will cause the agent to run as the snmp user or
.I agentuser #10
will cause the agent to run as the user with userid 10.
.IP "interface NAME TYPE SPEED"
For interfaces where the agent fails to guess correctly on the type and
speed, this directive can supply additional information.
TYPE is a type value as given in the IANAifType-MIB.
.IP "ignoredisk STRING"
When scanning for available disk devices the agent might block in trying
to open all possible disk devices. This might lead to a timeout when
walking the device tree. Sometimes the next walk will run without timeout,
sometimes it will timeout every time you try it.
.IP
If you experience such behaviour you might add this directive and give all
device names not to be checked (i.e. opened). You might have more than one
such directive in your configuration file stating all devices not to be
opened. You might also specify those devices using wildcards similar to
the syntax you can use in a bourne shell (see examples below).
.IP
.B Note:
For a list of devices scanned for every system please consult the sources
(host/hr_disk.c) and check for the Add_HR_Disk_entry() calls relevant for
your type of OS.
.IP
Examples:
.IP
ignoredisk /dev/rdsk/c0t2d0
.IP
This directive prevents the device /dev/rdsk/c0t2d0 from being scanned.
.IP
ignoredisk /dev/rdsk/c0t[!6]d0
.IP
This directive prevents all devices /dev/rdsk/c0tXd0 except .../c0t6d0
from being scanned. For most systems similar is the following directive:
.IP
ignoredisk /dev/rdsk/c0t[0-57-9a-f]d0
.IP
ignoredisk /dev/rdsk/c1*
.IP
This directive prevents all devices whose device names start with /dev/rdsk/c1
from being scanned.
.IP
ignoredisk /dev/rdsk/c?t0d0
.IP
This directive prevents all devices /dev/rdsk/cXt0d0 ('X' might be any char)
from being scanned.
.IP
You might use more than one such wildcard expression in any such directive.
.IP "storageUseNFS NUMBER"
Setting storageUseNFS to 1 causes all NFS and NFS-like file systems to be
marked as 'Network Disks' in the hrStorageTable. This is according to RFC 2790.
Not setting storageUseNFS or setting it to 2 causes NFS and NFS-like file
systems to be marked as 'Fixed Disks' as it has been in previous versions of
the ucd-snmp SNMP agent.
.IP "authtrapenable NUMBER"
Setting authtrapenable to 1 enables generation of authentication failure
traps.  The default value is disabled(2).  Ordinarily the corresponding
object (snmpEnableAuthenTraps.0) is read-write, but setting its value
via this token makes the object read-only, and attempts to set the
value of the object will result in a notWritable error response.
.IP "override [-rw] OID TYPE VALUE"
This directive allows you to override a particular OID with a
different value (and possibly a different type of value).  The -rw
flag will allow snmp SETs to modify it's value as well. (note that if
you're overriding original functionality, that functionality will be
entirely lost.  Thus SETS will do nothing more than modify the
internal overridden value and will not perform any of the original
functionality intended to be provided by the MIB object.  It's an
emulation only.)  An example:
.IP
override sysDescr.0 octet_str "my own sysDescr"
.IP
That line will set the sysDescr.0 value to "my own sysDescr" as well
as make it modifiable with SNMP SETs as well (which is actually
illegal according to the MIB specifications).
.IP
Note that care must be taken when using this.  For example, if you try
to override a property of the 3rd interface in the ifTable with a new
value and later the numbering within the ifTable changes it's index
ordering you'll end up with problems and your modified value won't
appear in the right place in the table.
.IP
Valid TYPEs are: integer, uinteger, octet_str, object_id, counter,
null (for gauge's, use "uinteger"; for bit strings, use "octet_str").
Note that setting an object to "null" effectively delete's it as being
accessible.  No VALUE needs to be given if the object type is null.
.IP
More types should be available in the future.
.SH "SETTING UP TRAP AND/OR INFORM DESTINATIONS"
.IP "trapcommunity STRING"
This defines the default community string to be used when sending traps.
Note that this command must be used prior to any of the following three
commands that are intended use this community string.
.IP "trapsink HOST [COMMUNITY [PORT]]"
.IP "trap2sink HOST [COMMUNITY [PORT]]"
.IP "informsink HOST [COMMUNITY [PORT]]"
These commands define
the hosts to receive traps (and/or inform notifications). The
daemon sends a Cold Start trap when it starts up. If enabled, it also sends
traps on authentication failures.  Multiple \fItrapsink\fR, \fItrap2sink\fR
and \fIinformsink\fR lines may be specified to specify multiple destinations.
Use \fItrap2sink\fR to send SNMPv2 traps and \fIinformsink\fR to send
inform notifications.
If COMMUNITY is not specified, the string from a preceding \fItrapcommunity\fR
directive will be used. If PORT is not specified, the well known SNMP trap
port (162) will be used.
.IP "trapsess [SNMPCMD_ARGS] HOST"
This is a more generic trap configuration token that allows any type
of trap destination to be specified with any version of SNMP.  See the 
.I snmpcmd(1)
manual page for further details on the arguments that can be passed as
.I "SNMPCMD ARGS".
In addition to the arguments listed there, the special argument
\fI-Ci\fR specifies that you want inform notifications to be used
instead of unacknowledged traps (this requires that you also specify a 
version number of v2c or v3 as well).
.SH "DISMAN-EVENT-MIB SUPPORT (READ: SENDING TRAPS ON ERRORS)"
.PP
Warning: this implementation has not been extensively tested and is
additionally not known to be entirely complete.  The concepts defined
here should function appropriately, however, but no promises are made
at this time.
.PP
If your agent was compiled with support for the DISMAN-EVENT-MIB (you
can enable this by running the net-snmp configure script with the
--with-mib-modules=disman/event-mib argument) you have support for
having the agent check its own data at regular intervals and to send
out traps when certain conditions occur.  Traps are sent when
expressions are first noticed, not once per evaluation.  Once a test
expression fires a trap, the test will have to fail again before a new
trap is sent.  See the DISMAN-EVENT-MIB documentation for more
details. This can be configured either using the MIB tables themselves
or by using these special key words:
.IP "agentSecName NAME"
The DISMAN-EVENT-MIB support requires a valid user name for which to
scan your agent with.  This can either be specified using the
agentSecName token or by explicitly list one on the "monitor" lines
described below using the -u switch.  Either way, a "rouser" line (or
equivalent access control settings) must also be specified with the
same security name name.  If you need an example, just do something
like this:
.RS
.IP
.nf
agentSecName internal
rouser internal
.fi
.RE
.IP
And everything below should work just fine.
.IP "monitor [OPTIONS] NAME EXPRESSION"
This token tells the agent to monitor itself for problems based on
EXPRESSION.  Expression is a simple expression based on an oid, a
comparison operator (!=, ==, <, <=, >, >=) and an integer value (see
the examples below).  NAME is merely an arbitrary name of your
choosing for administrative purposes only.  OPTIONS include the
following possibilities:
.RS
.IP "-t"
Use a threshold monitor instead of a boolean monitor.  This means that
expression should be a low and high value.  If the given OID passes
beyond the high value, a rising alarm will triggered.  A falling alarm
will then be triggered after it falls below the low value.
.IP "-r FREQUENCY"
Monitors the given expression every FREQUENCY seconds.  The default is
600 (10 minutes). 
.IP "-u SECNAME"
Use the SECNAME security name for scanning the local host.
Specifically, this SECNAME must then be given access control rights
via something like the "rouser" snmpd.conf token for this expression
to be valid at all.  If not specified, it uses the default security
name specified by the agentsecname snmpd.conf token.  Either the -u
flag or a valid agentsecname token must be specified (and that name
must be given proper access control rights via a "rouser" token).
.IP "-o OID"
Specifies additional object values to be delivered with in the
resulting trap in addition to the normal trap objects.  This is useful
for obtaining other columns in the table for the row that triggered
the expression.  See the examples below for more details.
.IP "-e EVENTNAME"
Specifies an event name that describes what to do when the trigger is
fired.  Currently, this must be the name of a notificationEvent event
as described below.
.RE
.IP
The following example configuration checks the hrSWRunPerfTable table
(listing running processes) for any process which is consuming > 10Mb
of memory.  It performs this check every 600 seconds (the default).
For every process it finds exceeding the limit, it will end out
exactly one notification.  In addition to the normal hrSWRunPerfMem
oid and value sent in the trap, the hrSWRunName object will also be
sent.  Note that the hrSWRunName object actually occurs in a different
table, but since the indexes to the two tables are the same this works
out alright.
.RS
.IP
.nf
rouser me
monitor -u me -o sysUpTime.0 -o hrSWRunName "high process memory" hrSWRunPerfMem > 10000
.fi
.fi
.RE
.IP
The above line would produce a trap which, when formated by snmptrapd, would
look like:
.RS
.IP
.nf
2002-04-05 13:33:53 localhost.localdomain [udp:127.0.0.1:32931]:
        sysUpTimeInstance = Timeticks: (1629) 0:00:16.29        snmpTrapOID.0 = OID: mteTriggerFired    mteHotTrigger = high process memory     mteHotTargetName =      mteHotContextName =     mteHotOID = OID: hrSWRunPerfMem.1968    mteHotValue = 28564     hrSWRunName.1968 = "xemacs"
.fi
.RE
.IP
This shows my xemacs process using 28Mb of resident memory.  Which,
considering it's xemacs, is not that surprising.
.IP
Threshold example:
.RS
.nf
.IP
monitor -t -r 15 -o prNames -o prErrMessage "process table" prErrorFlag 0 1
.fi
.RE
.IP "notificationEvent NAME NOTIFICATION [[-w] OID_OBJECT ...]"
This will create a notification event, which can be fired by attaching
it to a monitor using a monitor's -e switch and an identical NAME
field.  The NOTIFICATION to be sent should be the OID of a
notification.  Additional objects can be included, and by default the
suffix of the row/object being monitored will be appended to the
object identifier unless it's told not to be a wild-card object by
prefixing it with the -w switch.  EG, if you're monitoring the ifTable
and you want your trap to include the ifDescr object for the row that
was discovered, don't add the -w switch and the .INDEX field will be
appended.  If the OID is fully qualified (EG, "sysContact.0") and no
instance suffix should be appended to it then add a -w switch before
it.  See the linkUpDownNotifications token below for example usage of
this token to send the linkUp and linkDown traps.
.IP "linkUpDownNotifications yes"
This will make the DISMAN-EVENT-MIB support watch the ifTable to
determine when a network interface is taken up or down.  When this
happens, a linkUp or linkDown notification will be triggered.  This is
exactly equivalent to doing:
.RS
.IP
.nf
notificationEvent  linkUpTrap    linkUp   ifIndex ifAdminStatus ifOperStatus
notificationEvent  linkDownTrap  linkDown ifIndex ifAdminStatus ifOperStatus

monitor  -r 60 -e linkUpTrap   "Generate linkUp" ifOperStatus != 2
monitor  -r 60 -e linkDownTrap "Generate linkDown" ifOperStatus == 2
.fi
.RE
.IP "defaultMonitors yes"
By default, the agent and the DISMAN-EVENT-MIB support do nothing
until configured.  Typically people wish to watch a bunch of tables
within the UCD-SNMP-MIB which are designed specifically for reporting
problems.  If the "defaultMonitors yes" line is put into the
snmpd.conf file (which must be accompanied by an appropriate
agentSecName line and a rouser line), the following monitoring
conditions will be installed:
.RS
.IP
.nf
monitor	-o prNames -o prErrMessage "process table" prErrorFlag != 0
monitor	-o memErrorName -o memSwapErrorMsg "memory" memSwapError != 0
monitor	-o extNames -o extOutput "extTable" extResult != 0
monitor	-o dskPath -o dskErrorMsg "dskTable" dskErrorFlag != 0
monitor	-o laNames -o laErrMessage  "laTable" laErrorFlag != 0
monitor	-o fileName -o fileErrorMsg  "fileTable" fileErrorFlag != 0
.fi
.RE
.SH "EXTENDING AGENT FUNCTIONALITY"
One of the first distinguishing features of the original UCD suite was
the ability to extend the functionality of the agent - not just by
adding new MIB modules, but also by configuring the running agent to
report additional information. There are a number of techniques to
support this, including:
.IP \(bu
running external commands (\fIexec\fR, \fIextend\fR, \fIpass\fR)
.IP \(bu
loading new code dynamically (embedded perl, \fIdlmod\fR)
.IP \(bu
communicating with other agents (\fIproxy\fR, SMUX, AgentX)
.SS "Arbitrary Extension Commands"
The earliest extension mechanism was the ability to run arbitrary
commands or shell scripts. Such commands do not need to be aware of
SNMP operations, or conform to any particular behaviour - the MIB
structures are designed to accommodate any form of command output.
This requires that the agent was built with support for the
\fIucd-snmp/extensible\fR and/or \fIagent/extend\fR modules (which
are both included as part of the default build configuration).
.IP "exec [MIBOID] NAME PROG ARGS"
.IP "sh [MIBOID] NAME PROG ARGS"
invoke the named PROG with arguments of ARGS.  By default the exit
status and first line of output from the command will be reported via
the UCD-SNMP-MIB::extTable, discarding any additional output.
.RS
.IP Note:
Entries in this table appear in the order they are read from the
configuration file.  This means that adding new \fIexec\fR (or \fIsh\fR)
directives and restarting the agent, may affect the indexing of other
entries.
.RE
.IP
The PROG argument for \fIexec\fR directives must be a full path
to a real binary, as it is executed via the exec() system call.
To invoke a shell script, use the \fIsh\fR directive instead.
.IP
If MIBOID is specified, then the results will be rooted at this point
in the OID tree, returning the exit statement as MIBOID.ERRORFLAG.0
and the entire command output in a pseudo-table based at
MIBNUM.ERRORMSG - with one 'row' for each line of output.
.RS
.IP Note:
The layout of this "relocatable" form of \fIexec\fR (or \fIsh\fR) output
does not strictly form a valid MIB structure.  This mechanism is being
deprecated - please see the \fIextend\fR directive (described below) instead.
.RE
.IP
In either case, the exit statement and output will be cached for 30s
after the initial query.  This cache can be flushed by a SET request of
\fIinteger(1)\fR to the MIB instance UCD-SNMP-MIB::versionClearCache.0.
.\"
.\" XXX - Is this still true ??
.\"
.IP "execfix NAME PROG ARGS"
registers a command that can be invoked on demand - typically to respond
to or fix errors with the corresponding \fIexec\fR or \fIsh\fR entry.
When the \fIextErrFix\fR instance for a given NAMEd entry is set to the
integer value of 1, this command will be called.
.RS
.IP "Note:"
This directive can only be used in combination with a corresponding
\fIexec\fR or \fIsh\fR directive, which must be defined first.
Attempting to define an unaccompanied \fIexecfix\fR directive will fail.
.RE
.IP "extend [MIBOID] NAME PROG ARGS"
works in a similar manner to the \fIexec\fR directive, but with a number
of improvements.  The MIB tables (\fInsExtendConfigTable\fR
etc) are indexed by the NAME token, so are unaffected by the order in
which entries are read from the configuration files.
There are \fItwo\fR result tables - one (\fInsExtendOutput1Table\fR)
containing the exit status, the first line and full output (as a single string)
for each \fIextend\fR entry, and the other (\fInsExtendOutput2Table\fR)
containing the full output as a series of separate lines.
.IP
If MIBOID is specified, then the configuration and result tables will be rooted
at this point in the OID tree, but are otherwise structured in exactly
the same way. This means that several separate \fIextend\fR
directives can specify the same MIBOID root, without conflicting.
.IP
The exit status and output is cached for each entry individually, and
this can be configured and/or cleared
via the NET-SNMP-AGENT-MIB::nsCacheTable.
.IP "extendfix NAME PROG ARGS"
registers a command that can be invoked on demand, by setting the
appropriate \fInsExtendRunType\fR instance to the value
\fIrun-command(3)\fR.  Unlike the equivalent \fIexecfix\fR,
this directive does not need to be paired with a corresponding
\fIextend\fR entry, and can appear on its own.
.SS "MIB-Specific Extension Commands"
The first group of extension directives invoke arbitrary commands,
and rely on the MIB structure (and management applications) having
the flexibility to accommodate and interpret the output.  This is a
convenient way to make information available quickly and simply, but
is of no use when implementing specific MIB objects, where the extension
must conformto the structure of the MIB (rather than vice versa).
The rest of the extension mechanisms are all concerned with such
MIB-specific situations - starting with "pass-through" scripts.
This requires that the agent was built with support for the
\fIucd-snmp/pass\fR and \fIucd-snmp/pass_persist\fR modules (which
are both included as part of the default build configuration).
.IP "pass [-p priority] MIBOID PROG"
will pass control of the subtree rooted at MIBOID to the specified
PROG command.  GET and GETNEXT requests for OIDs within this tree will
trigger an invocation of this command, called as:
.RS
.IP
PROG -g OID
.IP
PROG -n OID
.RE
.IP
respectively, where OID is the requested OID.
The PROG command should return the response varbind as three separate
lines printed to stdout - the first line should be the OID of the returned
value, the second should be its TYPE (one of the text strings
.B integer, gauge, counter, timeticks, ipaddress, objectid,
or
.B string
), and the third should be the value itself.
.IP
If the command cannot return an appropriate varbind - e.g the specified
OID did not correspond to a valid instance for a GET request, or there
were no following instances for a GETNEXT - then it should exit without
producing any output.  This will result in an SNMP \fInoSuchName\fR
error, or a \fInoSuchInstance\fR exception.
.RS
.RS
.IP "Note:"
The SMIv2 type \fBcounter64\fR
and exception \fInoSuchObject\fR are not supported
.RE
.RE
.IP
A SET request will result in an invocation of the command as:
.RS
.IP
PROG -s OID TYPE VALUE
.RE
.IP
where TYPE is one of the tokens listed above, indicating the type of the
value passed as the third parameter.
.\".RS
.\".RS
.\".IP "Note:"
.\".B counter
.\"(and
.\".B counter64
.\") syntax objects are not valid for SETs
.\".RE
.\".RE
.IP
If the assignment is successful, the command should exit without producing
any output. Errors should be indicated by writing one of the strings
.B not-writable, 
or 
.B wrong-type
to stdout,
and the agent will generate the appropriate error response.
.RS
.RS
.IP "Note:"
The other SNMPv2 errors are not supported.
.RE
.RE
.IP
In either case, the command should exit once it has finished processing.
Each request (and each varbind within a single request) will trigger
a separate invocation of the command.
.IP
The default registration priority is 127.  This can be
changed by supplying the optional -p flag, with lower priority
registrations being used in preference to higher priority values.
.IP "pass_persist [-p priority] MIBOID PROG"
will also pass control of the subtree rooted at MIBOID to the specified
PROG command.  However this command will continue to run after the initial
request has been answered, so subsequent requests can be processed without
the startup overheads.
.IP
Upon initialization, PROG will be passed the string "PING\\n" on stdin,
and should respond by printing "PONG\\n" to stdout.
.IP
For GET and GETNEXT requests, PROG will be passed two lines on stdin,
the command (\fIget\fR or \fIgetnext\fR) and the requested OID.
It should respond by printing three lines to stdout - 
the OID for the result varbind, the TYPE and the VALUE itself -
exactly as for the \fIpass\fR directive above.
If the command cannot return an appropriate varbind,
it should print print "NONE\\n" to stdout (but continue running).
.IP
For SET requests, PROG will be passed three lines on stdin,
the command (\fIset\fR) and the requested OID,
followed by the type and value (both on the same line).
If the assignment is successful, the command should print
"DONE\\n" to stdout.
Errors should be indicated by writing one of the strings
.B not-writable, 
or 
.B wrong-type
to stdout,
and the agent will generate the appropriate error response.
In either case, the command should continue running.
.IP
The default registration priority can be changed using the optional
-p flag, just as for the \fIpass\fR directive.
.SS "Embedded Perl Support"
The previous extension programs can be written in any convenient
programming language - including perl, which is a common choice for
pass-through extensions in particular.  However the Net-SNMP agent
also includes support for embedded perl technology (similar to
\fImod_perl\fR for the Apache web server).  This allows the agent
to interpret perl scripts directly, thus avoiding the overhead of
spawning processes and initializing the perl system when a request is received.
This requires that the agent was built with support for the embedded
perl mechanism, which is not part of the default build environment, and
must be explicitly included by specifying the '--enable-embedded-perl'
option to the configure script when the package is first built.
.PP
If enabled, the following directives will be recognised:
.IP "disablePerl [true|false]"
can turn off embedded perl support entirely (e.g. if there are problems
with the perl installation).
.IP "perlInitFile FILE"
loads the specified initialisation file (instead of the default
DATADIR/snmp/snmp_perl.pl)
immediately before the first \fIperl\fR directive is parsed.
The default initialisation script creates a \fC$agent\fR variable
(a \fCNetSNMP::agent\fR object) which can be used to register
perl-based MIB handler routines.
.IP "perl EXPRESSION"
evaluates the given expression.  This would typically register a
handler routine to be called when a section of the OID tree was
requested:
.RS
.RS
.nf
perl use Data::Dumper;
perl sub myroutine  { print "got called: ",Dumper(@_),"\\n"; }
perl $agent->register('mylink', '.1.3.6.1.8765', \\&myroutine);
.fi
.RE
.RE
.IP
This expression could also source an external file:
.RS
.RS
.nf
perl 'do /path/to/file.pl';
.fi
.RE
.RE
.IP
or perform any other perl-based processing that might be required.
.SS Dynamically Loadable Modules
Most of the MIBs supported by the Net-SNMP agent are implemented as
C code modules, which are compiled and linked into the agent libraries
when the suite was first built.  Such implementation modules can also be
compiled independently and loaded into the running agent once it has
started.  This requires that the agent was built with support for the
\fIucd-snmp/dlmod\fR module (which is included as part of the default
build configuration).
.IP "dlmod NAME PATH"
will load the shared object module from the file PATH (an absolute
filename), and call the initialisation routine \fIinit_NAME\fR.
.RS
.IP "Note:"
If the specified PATH is not a fully qualified filename, it will
be interpreted relative to LIBDIR/snmp/dlmod, and \fC.so\fR
will be appended to the filename.
.RE
.PP
This functionality is also available via SNMP SET requests
to the UCD-DLMOD-MIB.
.SS "Proxy Support"
Another mechanism for extending the functionality of the agent
is to pass selected requests (or selected varbinds) to another
SNMP agent, which can be running on the same host (presumably
listening on a different port), or on a remote system.
This can be viewed as the main agent delegating requests to
the remote one, or acting as a proxy for it.
This requires that the agent was built with support for the
\fIucd-snmp/proxy\fR module (which is included as part of the
default build configuration).
.IP "proxy [-Cn CONTEXTNAME] [SNMPCMD ARGS] HOST OID [REMOTEOID]"
will pass any incoming requests under OID to the agent listening
on the port specified by the transport address HOST.
.RS
.IP "Note:"
To proxy the entire MIB tree, use the OID .1.3
(\fBnot\fR the top-level .1)
.RE
.IP
The \fISNMPCMD ARGS\fR should provide sufficient version and
administrative information to generate a valid SNMP request
(see \fIsnmpcmd(1)\fR).
.RS
.IP "Note:"
The proxied request will \fInot\fR use the same administrative
settings from the original request.
.RE
.IP
If a CONTEXTNAME is specified, this will register the proxy
delegation within the named context in the local agent.
Defining multiple \fIproxy\fR directives for the same OID but
different contexts can be used to query several remote agents
through a single proxy, by specifying the appropriate SNMPv3
context in the incoming request (or using suitable configured
community strings - see the \fIcom2sec\fR directive).
.IP
Specifying the REMOID parameter will map the local MIB tree
rooted at OID to an equivalent subtree rooted at REMOID
on the remote agent.
.IP "Examples:"
.RS
.nf
# assigns the entire mib tree on remotehost1 to the context of the
# same name:
proxy -Cn remotehost1 -v 1 -c public remotehost1 .1.3
# ditto, but for remotehost 2
proxy -Cn remotehost2 -v 1 -c public remotehost2 .1.3
# proxies only the ucdavis enterprises tree to the remote host using snmpv1
proxy -v 1 -c public remotehost .1.3.6.1.4.1.2021
# uses v3 to access remotehost and converts the remote .1.3.6.1.2.1.1
# oid to local .1.3.6.1.3.10 oid (another way to access mulitple hosts
# without using contexts)
proxy -v 3 -l noAuthNoPriv -u user remotehost .1.3.6.1.3.10 .1.3.6.1.2.1.1
.fi
.RE
.SS SMUX Sub-Agents
The Net-SNMP agent supports the SMUX protocol (RFC 1227) to communicate
with SMUX-based subagents (such as \fIgated\fR, \fIzebra\fR or \quagga\fR).
This requires that the agent was built with support for the
\fIsmux\fR module, which is not part of the default build environment, and
must be explicitly included by specifying the '--with-mib-modules=smux'
option to the configure script when the package is first built.
.RS
.IP "Note:"
This extension protocol has been officially deprecated in
favour of AgentX (see below).
.RE
.IP "smuxpeer OID PASS"
will register a subtree for SMUX-based processing, to be
authenticated using the password PASS.  If the subagent
(or "peer") connects to the agent and registers this subtree
.\"
.\" Or a subtree of this subtree ??
.\"
then requests for OIDs within it will be passed to that
SMUX subagent for processing.
.IP
A suitable entry for an OSPF routing daemon (such as \fIgated\fR,
\fIzebra\fR or \fIquagga\fR) might be something like
.RS
.RS
.I smuxpeer .1.3.6.1.2.1.14 ospf_pass
.RE
.RE
.IP "smuxsocket [<transport-specifier>:]<transport-address>[,...]"
defines the address for SMUX peers to communicate with the Net-SNMP agent.
The default is to listen on TCP port 199 on all IPv4 interfaces, unless the 
package has been configured with "--enable-local-smux" at build time,
which causes it to only listen on tcp:127.0.0.1:199 by default.
See the section
.B LISTENING ADDRESSES
in the
.I snmpd(8)
manual page for more information about the format of addresses.
.PP
Note the Net-SNMP agent will only operate as a SMUX \fImaster\fR
agent. It does not support acting in a SMUX subagent role.
.SS AgentX Sub-Agents
The Net-SNMP agent supports the AgentX protocol (RFC 2741) in
both master and subagent roles.
This requires that the agent was built with support for the
\fIagentx\fR module (which is included as part of the
default build configuration), and also that this support is
explicitly enabled (e.g. via the \fIsnmpd.conf\fR file).
.PP
There are two directives specifically relevant to running as
an AgentX master agent:
.IP "master agentx"
will enable the AgentX functionality and cause the agent to
start listening for incoming AgentX registrations.
This can also be activated by specifying the '-x' command-line
option (to specify an alternative listening socket).
.IP "agentXPerms socket_perms [directory_perms [username|userid [groupname|groupid]]]"
Defines the permissions and ownership of the AgentX Unix Domain socket.
socket_perms and directory_perms must be octal digits (see 
.I chmod(1)
). By default this socket is accessible only to subagents which 
have the same userid as the agent.
.PP
There is one directive specifically relevant to running as
an AgentX sub-agent:
.IP "agentPingInterval NUM"
will make the subagent try and reconnect every NUM seconds to the
master if it ever becomes (or starts) disconnected.
.PP
The remaining directives are relevant to both AgentX master
and sub-agents:
.IP "agentXSocket [<transport-specifier>:]<transport-address>[,...]"
defines the address the master agent listens at, or the subagent
should connect to.
The default is the Unix Domain socket /var/agentx/master.
Another possibility is tcp:localhost:705.
See the section
.B LISTENING ADDRESSES
in the
.I snmpd(8)
manual page for more information about the format of addresses.
.RS
.IP "Note:"
Specifying an AgentX socket does \fBnot\fR automatically enable
AgentX functionality (unlike the '-x' command-line option).
.RE
.IP "agentXTimeout NUM"
defines the timeout period (NUM seconds) for an AgentX request.
Default is 1 second.
.IP "agentXRetries NUM"
defines the number of retries for an AgentX request.
Default is 5 retries.
.SH "DEBUGGING AND OTHER EXTENSIBILITY NOTES"
If you're trying to figure out aspects of the various mib modules
(possibly some that you've added yourself), the following may help you
spit out some useful debugging information.  First off, please read
the snmpd manual page on the -D flag.  Then the following
configuration snmpd.conf token, combined with the -D flag, can produce
useful output:
.IP "injectHandler HANDLER modulename"
This will insert new handlers into the section of the mib tree
referenced by "modulename".  The types of handlers available for
insertion are:
.RS
.nf
stash_cache  - Caches information returned from the lower level.  This
               greatly help the performance of the agent, at the cost
               of caching the data such that its no longer "live" for
               30 seconds (in this future, this will be configurable).
               Note that this means snmpd will use more memory as well
               while the information is cached.  Currently this only
               works for handlers registered using the table_iterator
               support, which is only a few mib tables.  To use it,
               you need to make sure to install it before the
               table_iterator point in the chain, so to do this:

                  injectHandler stash_cache NAME table_iterator

               If you want a table to play with, try walking the
               nsModuleTable with and without this injected.

debug        - Prints out lots of debugging information when
               the -Dhelper:debug flag is passed to the snmpd
               application.

read_only    - Forces turning off write support for the given module.

serialize    - If a module is failing to handle multiple requests
               properly (using the new 5.0 module API), this will force
               the module to only receive one request at a time.

bulk_to_next - If a module registers to handle getbulk support, but
               for some reason is failing to implement it properly,
               this module will convert all getbulk requests to
               getnext requests before the final module receives it.
.fi
.RE
.IP "Figuring out module names"
To figure out which modules you can inject things into, snmpwalk the
nsModuleTable which will give you a list of all named modules
registered within the agent.
.SH "EXAMPLE CONFIGURATION FILE"
See the EXAMPLE.CONF file in the top level source directory for a more
detailed example of how the above information is used in real
examples.
.SH "RE-READING snmpd.conf AND snmpd.local.conf"
The Net-SNMP agent can be forced to re-read its configuration files.
It can be told to do so by one of two ways:
.IP 1.
An snmpset of integer(1) to UCD-SNMP-MIB::versionUpdateConfig.0
(.1.3.6.1.4.1.2021.100.11.0)
.IP 2.
A "kill -HUP" signal sent to the snmpd agent process.
.SH "FILES"
SYSCONFDIR/snmp/snmpd.conf
.SH "SEE ALSO"
snmpconf(1), snmpusm(1), snmp.conf(5), snmp_config(5), snmpd(8), EXAMPLE.conf, read_config(3).
.\" Local Variables:
.\"  mode: nroff
.\" End:
