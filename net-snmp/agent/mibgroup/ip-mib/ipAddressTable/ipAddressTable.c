/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for ipAddressTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ipAddressTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "ipAddressTable_interface.h"

oid             ipAddressTable_oid[] = { IPADDRESSTABLE_OID };
int             ipAddressTable_oid_size = OID_LENGTH(ipAddressTable_oid);

void            initialize_table_ipAddressTable(void);


/**
 * Initializes the ipAddressTable module
 */
void
init_ipAddressTable(void)
{
    DEBUGTRACE;

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("ipAddressTable"))
        initialize_table_ipAddressTable();

}

/**
 * Initialize the table ipAddressTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_ipAddressTable(void)
{
    ipAddressTable_registration_ptr user_context;
    u_long          flags;

    DEBUGTRACE;

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _ipAddressTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
ipAddressTable_pre_request(ipAddressTable_registration_ptr user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
ipAddressTable_post_request(ipAddressTable_registration_ptr user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table ipAddressTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ipAddressTable is subid 33 of ip.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.33, length: 8
 */

/*
 * ipAddressTable_allocate_data
 *
 * Purpose: create new ipAddressTable_data.
 */
ipAddressTable_data *
ipAddressTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    /** this might not be right for netsnmp_ipaddress_entry */
    ipAddressTable_data *rtn =
        SNMP_MALLOC_TYPEDEF(netsnmp_ipaddress_entry);

    DEBUGTRACE;

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "ipAddressTable_data.\n");
    }

    return rtn;
}

/*
 * ipAddressTable_allocate_data
 *
 * Purpose: release data data.
 */
void
ipAddressTable_release_data(ipAddressTable_data * data)
{
    DEBUGTRACE;

    /*
     * release memory for the context
     */
    free(data);
}


/*---------------------------------------------------------------------
 * IP-MIB::ipAddressEntry.ipAddressAddrType
 * ipAddressAddrType is subid 1 of ipAddressEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.33.1.1
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE ipAddressAddrType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ipAddressAddrType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ipAddressAddrType_map(u_long * mib_ipAddressAddrType_ptr,
                      u_long raw_ipAddressAddrType)
{
    netsnmp_assert(NULL != mib_ipAddressAddrType_ptr);

    DEBUGTRACE;

    /*
     * value mapping
     * 
     * netsnmp_ipaddress_entry just passes in address length, so we
     * can determing ipv4 from ipv6..
     */
    switch (raw_ipAddressAddrType) {
    case INTERNAL_IPADDRESSADDRTYPE_IPV4:
        *mib_ipAddressAddrType_ptr = INETADDRESSTYPE_IPV4;
        break;

    case INTERNAL_IPADDRESSADDRTYPE_IPV6:
        *mib_ipAddressAddrType_ptr = INETADDRESSTYPE_IPV6;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ipAddressAddrType\n",
                 raw_ipAddressAddrType);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values are
 *  native/rawformat, and the mapping function is called (or suggested) when
 *  necessary.
 */
int
ipAddressTable_indexes_set_tbl_idx(ipAddressTable_mib_index * tbl_idx,
                                   u_long ipAddressAddrType,
                                   char *ipAddressAddr_ptr,
                                   size_t ipAddressAddr_ptr_len)
{
    DEBUGTRACE;

    /*
     * ipAddressAddrType(1)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        ipAddressAddrType_map(&tbl_idx->ipAddressAddrType,
                              ipAddressAddrType)) {
        return MFD_ERROR;
    }

    /*
     * ipAddressAddr(2)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_ipaddress_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    if ( sizeof(tbl_idx->ipAddressAddr) < ipAddressAddr_ptr_len) {
        return MFD_ERROR;
    }
    tbl_idx->ipAddressAddr_len = ipAddressAddr_ptr_len;
    memcpy(tbl_idx->ipAddressAddr, ipAddressAddr_ptr,
           tbl_idx->ipAddressAddr_len * sizeof(tbl_idx->ipAddressAddr[0]));


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
ipAddressTable_indexes_set(ipAddressTable_rowreq_ctx * rowreq_ctx,
                           u_long ipAddressAddrType,
                           char *ipAddressAddr_ptr,
                           size_t ipAddressAddr_ptr_len)
{
    if (MFD_SUCCESS !=
        ipAddressTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                           ipAddressAddrType,
                                           ipAddressAddr_ptr,
                                           ipAddressAddr_ptr_len))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != ipAddressTable_index_to_oid(&rowreq_ctx->oid_idx,
                                         &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-MIB::ipAddressEntry.ipAddressIfIndex
 * ipAddressIfIndex is subid 3 of ipAddressEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.33.1.3
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  1 - 2147483647;
 *
 * It's syntax is InterfaceIndex (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipAddressIfIndex data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressIfIndex_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipAddressIfIndex_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                     long *ipAddressIfIndex_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipAddressIfIndex_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipAddressIfIndex_ptr ) from rowreq_ctx->data->
     */
    (* ipAddressIfIndex_ptr ) = rowreq_ctx->data->if_index;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipAddressEntry.ipAddressType
 * ipAddressType is subid 4 of ipAddressEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.33.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  unicast(1), anycast(2), broadcast(3)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ipAddressType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ipAddressType_map(u_long * mib_ipAddressType_ptr, u_long raw_ipAddressType)
{
    netsnmp_assert(NULL != mib_ipAddressType_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ipAddressType) {
    case INTERNAL_IPADDRESSTYPE_UNICAST:
        *mib_ipAddressType_ptr = IPADDRESSTYPE_UNICAST;
        break;

    case INTERNAL_IPADDRESSTYPE_ANYCAST:
        *mib_ipAddressType_ptr = IPADDRESSTYPE_ANYCAST;
        break;

    case INTERNAL_IPADDRESSTYPE_BROADCAST:
        *mib_ipAddressType_ptr = IPADDRESSTYPE_BROADCAST;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ipAddressType\n",
                 raw_ipAddressType);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ipAddressType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressType_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipAddressType_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                  u_long * ipAddressType_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipAddressType_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipAddressType_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        ipAddressType_map(&(*ipAddressType_ptr),
                          rowreq_ctx->data->ia_type)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipAddressEntry.ipAddressPrefix
 * ipAddressPrefix is subid 5 of ipAddressEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.33.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is RowPointer (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max 2147483647)
 */
/**
 * Extract the current value of the ipAddressPrefix data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressPrefix_ptr_ptr
 *        Pointer to storage for a oid variable
 * @param ipAddressPrefix_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ipAddressPrefix.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ipAddressPrefix_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ipAddressPrefix_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ipAddressPrefix_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                    oid ** ipAddressPrefix_ptr_ptr,
                    size_t * ipAddressPrefix_ptr_len_ptr)
{
    oid * src;
    int len;

   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ipAddressPrefix_ptr_ptr)
                   && (NULL != *ipAddressPrefix_ptr_ptr));
    netsnmp_assert(NULL != ipAddressPrefix_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipAddressPrefix_ptr_ptr ) and (* ipAddressPrefix_ptr_len_ptr ) from rowreq_ctx->data->
     */
    if(NULL == rowreq_ctx->data->ia_prefix_oid) {
        src = nullOid;
        len = nullOidLen / sizeof(oid);
    }
    else {
        src = rowreq_ctx->data->ia_prefix_oid;
        len = rowreq_ctx->data->ia_prefix_oid_len;
    }
    if ((*ipAddressPrefix_ptr_len_ptr) < len) {
        (*ipAddressPrefix_ptr_ptr) =
            malloc(len * sizeof((*ipAddressPrefix_ptr_ptr)[0]));
        if (NULL == (*ipAddressPrefix_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*ipAddressPrefix_ptr_len_ptr) = len;
    memcpy((*ipAddressPrefix_ptr_ptr), src,
           len * sizeof((*ipAddressPrefix_ptr_ptr)[0]));

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ipAddressOrigin data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressOrigin_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipAddressOrigin_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                    u_long * ipAddressOrigin_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipAddressOrigin_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* ipAddressOrigin_ptr ) from rowreq_ctx->data->
     */
    (* ipAddressOrigin_ptr ) = rowreq_ctx->data->ia_origin;

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ipAddressStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressStatus_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipAddressStatus_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                    u_long * ipAddressStatus_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipAddressStatus_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipAddressStatus_ptr ) from rowreq_ctx->data->
     */
    (* ipAddressStatus_ptr ) = rowreq_ctx->data->ia_status;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipAddressEntry.ipAddressCreated
 * ipAddressCreated is subid 8 of ipAddressEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.33.1.8
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipAddressCreated data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressCreated_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipAddressCreated_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                     u_long * ipAddressCreated_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipAddressCreated_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipAddressCreated_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipAddressEntry.ipAddressLastChanged
 * ipAddressLastChanged is subid 9 of ipAddressEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.33.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipAddressLastChanged data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipAddressLastChanged_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipAddressLastChanged_get(ipAddressTable_rowreq_ctx * rowreq_ctx,
                         u_long * ipAddressLastChanged_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipAddressLastChanged_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipAddressLastChanged_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}



/** @} */
/** @} */
/** @{ */
