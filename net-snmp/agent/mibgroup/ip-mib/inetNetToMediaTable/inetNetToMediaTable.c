/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for inetNetToMediaTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "inetNetToMediaTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "inetNetToMediaTable_interface.h"

oid             inetNetToMediaTable_oid[] = { INETNETTOMEDIATABLE_OID };
int             inetNetToMediaTable_oid_size =
OID_LENGTH(inetNetToMediaTable_oid);

void            initialize_table_inetNetToMediaTable(void);


/**
 * Initializes the inetNetToMediaTable module
 */
void
init_inetNetToMediaTable(void)
{
    DEBUGTRACE;

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("inetNetToMediaTable"))
        initialize_table_inetNetToMediaTable();

}

/**
 * Initialize the table inetNetToMediaTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_inetNetToMediaTable(void)
{
    inetNetToMediaTable_registration_ptr user_context;
    u_long          flags;

    DEBUGTRACE;

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _inetNetToMediaTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
inetNetToMediaTable_pre_request(inetNetToMediaTable_registration_ptr
                                user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
inetNetToMediaTable_post_request(inetNetToMediaTable_registration_ptr
                                 user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table inetNetToMediaTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetNetToMediaTable is subid 34 of ip.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.34, length: 8
 */

/*
 * inetNetToMediaTable_allocate_data
 *
 * Purpose: create new inetNetToMediaTable_data.
 */
inetNetToMediaTable_data *
inetNetToMediaTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    /** this might not be right for netsnmp_inetmedia_entry */
    inetNetToMediaTable_data *rtn =
        netsnmp_access_arp_entry_create();

    DEBUGTRACE;

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "inetNetToMediaTable_data.\n");
    }

    return rtn;
}

/*
 * inetNetToMediaTable_allocate_data
 *
 * Purpose: release data data.
 */
void
inetNetToMediaTable_release_data(inetNetToMediaTable_data * data)
{
    DEBUGTRACE;

    /*
     * release memory for the context
     */
    netsnmp_access_arp_entry_free(data);
}


/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddressType
 * inetNetToMediaNetAddressType is subid 2 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.34.1.2
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddressType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-inetNetToMediaNetAddressType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
inetNetToMediaNetAddressType_map(u_long *
                                 mib_inetNetToMediaNetAddressType_ptr,
                                 u_long raw_inetNetToMediaNetAddressType)
{
    netsnmp_assert(NULL != mib_inetNetToMediaNetAddressType_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_inetNetToMediaNetAddressType) {

    case INTERNAL_INETNETTOMEDIANETADDRESSTYPE_IPV4:
        *mib_inetNetToMediaNetAddressType_ptr = INETADDRESSTYPE_IPV4;
        break;

    case INTERNAL_INETNETTOMEDIANETADDRESSTYPE_IPV6:
        *mib_inetNetToMediaNetAddressType_ptr = INETADDRESSTYPE_IPV6;
        break;

    default:
        *mib_inetNetToMediaNetAddressType_ptr = INETADDRESSTYPE_UNKNOWN;
        snmp_log(LOG_ERR,
                 "couldn't map value %d for inetNetToMediaNetAddressType\n",
                 raw_inetNetToMediaNetAddressType);
    }

    return MFD_SUCCESS;
}


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values are
 *  native/rawformat, and the mapping function is called (or suggested) when
 *  necessary.
 */
int
inetNetToMediaTable_indexes_set_tbl_idx(inetNetToMediaTable_mib_index *
                                        tbl_idx,
                                        long inetNetToMediaIfIndex,
                                        u_long
                                        inetNetToMediaNetAddressType,
                                        char *inetNetToMediaNetAddress_ptr,
                                        size_t
                                        inetNetToMediaNetAddress_ptr_len)
{
    DEBUGTRACE;

    /*
     * inetNetToMediaIfIndex(1)/InterfaceIndex/ASN_INTEGER/long(long)//l/a/w/e/R/d/H 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_arp_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->inetNetToMediaIfIndex = inetNetToMediaIfIndex;

    /*
     * inetNetToMediaNetAddressType(2)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        inetNetToMediaNetAddressType_map(&tbl_idx->
                                         inetNetToMediaNetAddressType,
                                         inetNetToMediaNetAddressType)) {
        return MFD_ERROR;
    }

    /*
     * inetNetToMediaNetAddress(3)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_arp_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    if (sizeof(tbl_idx->inetNetToMediaNetAddress) <
        inetNetToMediaNetAddress_ptr_len) {
        return MFD_ERROR;
    }
    tbl_idx->inetNetToMediaNetAddress_len =
        inetNetToMediaNetAddress_ptr_len;
    memcpy(tbl_idx->inetNetToMediaNetAddress, inetNetToMediaNetAddress_ptr,
           tbl_idx->inetNetToMediaNetAddress_len *
           sizeof(tbl_idx->inetNetToMediaNetAddress[0]));


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
inetNetToMediaTable_indexes_set(inetNetToMediaTable_rowreq_ctx *
                                rowreq_ctx, long inetNetToMediaIfIndex,
                                u_long inetNetToMediaNetAddressType,
                                char *inetNetToMediaNetAddress_ptr,
                                size_t inetNetToMediaNetAddress_ptr_len)
{
    if (MFD_SUCCESS !=
        inetNetToMediaTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                inetNetToMediaIfIndex,
                                                inetNetToMediaNetAddressType,
                                                inetNetToMediaNetAddress_ptr,
                                                inetNetToMediaNetAddress_ptr_len))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != inetNetToMediaTable_index_to_oid(&rowreq_ctx->oid_idx,
                                              &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaPhysAddress
 * inetNetToMediaPhysAddress is subid 4 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.34.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 *
 * It's syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max )
 */
/**
 * Extract the current value of the inetNetToMediaPhysAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaPhysAddress_ptr_ptr
 *        Pointer to storage for a char variable
 * @param inetNetToMediaPhysAddress_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by inetNetToMediaPhysAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*inetNetToMediaPhysAddress_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update inetNetToMediaPhysAddress_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
inetNetToMediaPhysAddress_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                              char **inetNetToMediaPhysAddress_ptr_ptr,
                              size_t *
                              inetNetToMediaPhysAddress_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != inetNetToMediaPhysAddress_ptr_ptr)
                   && (NULL != *inetNetToMediaPhysAddress_ptr_ptr));
    netsnmp_assert(NULL != inetNetToMediaPhysAddress_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaPhysAddress_ptr_ptr ) and (* inetNetToMediaPhysAddress_ptr_len_ptr ) from rowreq_ctx->data->
     */
    if ((* inetNetToMediaPhysAddress_ptr_len_ptr ) <
        rowreq_ctx->data->arp_physaddress_len)
        return MFD_ERROR;
    (* inetNetToMediaPhysAddress_ptr_len_ptr ) =
        rowreq_ctx->data->arp_physaddress_len;
    memcpy((* inetNetToMediaPhysAddress_ptr_ptr ),
           rowreq_ctx->data->arp_physaddress,
           (* inetNetToMediaPhysAddress_ptr_len_ptr ) *
           sizeof((* inetNetToMediaPhysAddress_ptr_ptr)[0]));

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaLastUpdated
 * inetNetToMediaLastUpdated is subid 5 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.34.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaLastUpdated data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaLastUpdated_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaLastUpdated_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                              u_long * inetNetToMediaLastUpdated_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaLastUpdated_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaLastUpdated_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaType
 * inetNetToMediaType is subid 6 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.34.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 5/8. Values:  other(1), invalid(2), dynamic(3), static(4), local(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaType_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaType_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                       u_long * inetNetToMediaType_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaType_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaType_ptr ) from rowreq_ctx->data->
     */
    (* inetNetToMediaType_ptr ) = rowreq_ctx->data->arp_type;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaState
 * inetNetToMediaState is subid 7 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.34.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6/8. Values:  reachable(1), stale(2), delay(3), probe(4), invalid(5), unknown(6), incomplete(7)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaState_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaState_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                        u_long * inetNetToMediaState_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaState_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaState_ptr ) from rowreq_ctx->data->
     */
    (* inetNetToMediaState_ptr ) = rowreq_ctx->data->arp_state;

    return MFD_SUCCESS;
}



/** @} */
/**********************************************************************
 **********************************************************************
 ***
 *** Table inetNetToMediaTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetNetToMediaTable is subid 34 of ip.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.34, length: 8
 */
/**
 * create new data context, if specified index is valid.
 *
 * @param inetNetToMediaTable_reg
 *        Pointer to the user registration data
 * @param inetNetToMediaTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS   : success
 * @retval MFD_BAD_VALUE : index not valid
 */
int
inetNetToMediaTable_validate_index(inetNetToMediaTable_registration_ptr
                                   inetNetToMediaTable_reg,
                                   inetNetToMediaTable_rowreq_ctx *
                                   rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * Validate incoming index
     *
     * Check that the values specified in the incoming index are valid
     * values. All of the individual index component functions have been
     * called, so this is the place to make sure they are valid as
     * a whole when combined.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * TODO:
     * update this code or row creation won't work
     */
    if (1) {
        snmp_log(LOG_WARNING, "invalid index for a new row in the "
                 "inetNetToMediaTable table.\n");
        /*
         * TODO:
         * determine failure type.
         *
         * If the index could not ever be created, SNMP_ERR_NOCREATION.
         * If the index can not be created under the  present circumstances
         * (even though it could be created under other circumstances),
         * SNMP_ERR_INCONSISTENTNAME.
         */
        if (0) {
            return SNMP_ERR_NOCREATION;
        } else {
            return SNMP_ERR_INCONSISTENTNAME;
        }
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return rc;
}

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
inetNetToMediaTable_undo_setup(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * commit new valies.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * @param inetNetToMediaTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetNetToMediaTable_commit(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * commit data
     */

    return rc;
}


/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaIfIndex
 * inetNetToMediaIfIndex is subid 1 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.34.1.1
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  1 - 2147483647;
 *
 * It's syntax is InterfaceIndex (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaIfIndex IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetNetToMediaIfIndex index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetNetToMediaTable_validate_index() function.
 */
int
inetNetToMediaIfIndex_check_index(inetNetToMediaTable_rowreq_ctx *
                                  rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetNetToMediaIfIndex is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddressType
 * inetNetToMediaNetAddressType is subid 2 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.34.1.2
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddressType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetNetToMediaNetAddressType index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetNetToMediaTable_validate_index() function.
 */
int
inetNetToMediaNetAddressType_check_index(inetNetToMediaTable_rowreq_ctx *
                                         rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetNetToMediaNetAddressType is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddress
 * inetNetToMediaNetAddress is subid 3 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.34.1.3
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 36;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 36)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddress IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetNetToMediaNetAddress index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetNetToMediaTable_validate_index() function.
 */
int
inetNetToMediaNetAddress_check_index(inetNetToMediaTable_rowreq_ctx *
                                     rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetNetToMediaNetAddress is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaPhysAddress
 * inetNetToMediaPhysAddress is subid 4 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.34.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 *
 * It's syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 36)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaPhysAddress_ptr
 *        A char containing the new value.
 * @param inetNetToMediaPhysAddress_ptr_len
 *        The size (in bytes) of the data pointed to by inetNetToMediaPhysAddress_ptr
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetNetToMediaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, and object with the syntax DisplayString(0..40)
 * will have already been checked for a length between 0 and 40.
 * But if the description also specified that the value must
 * be all uppercase letters, you would enforce that requirement here.
 *
 */
int
inetNetToMediaPhysAddress_check_value(inetNetToMediaTable_rowreq_ctx *
                                      rowreq_ctx,
                                      char *inetNetToMediaPhysAddress_ptr,
                                      size_t
                                      inetNetToMediaPhysAddress_ptr_len)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != inetNetToMediaPhysAddress_ptr);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetNetToMediaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetNetToMediaPhysAddress_undo_setup(inetNetToMediaTable_rowreq_ctx *
                                     rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetNetToMediaPhysAddress and inetNetToMediaPhysAddress_len data
     *  from 'rowreq_ctx->data->inetNetToMediaPhysAddress to 'rowreq_ctx->undo->inetNetToMediaPhysAddress'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetNetToMediaPhysAddress_ptr
 *        A char containing the new value.
 * @param inetNetToMediaPhysAddress_ptr_len
 *        The size (in bytes) of the data pointed to by inetNetToMediaPhysAddress_ptr
 */
int
inetNetToMediaPhysAddress_set(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                              char *inetNetToMediaPhysAddress_ptr,
                              size_t inetNetToMediaPhysAddress_ptr_len)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != inetNetToMediaPhysAddress_ptr);

    /*
     * TODO:
     * set inetNetToMediaPhysAddress value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetNetToMediaPhysAddress_undo(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetNetToMediaPhysAddress and inetNetToMediaPhysAddress_len data
     *  from 'rowreq_ctx->undo->inetNetToMediaPhysAddress to 'rowreq_ctx->data->inetNetToMediaPhysAddress'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaType
 * inetNetToMediaType is subid 6 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.34.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 5/8. Values:  other(1), invalid(2), dynamic(3), static(4), local(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaType
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetNetToMediaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), invalid(2), dynamic(3), static(4), local(5)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetNetToMediaType_check_value(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                               u_long inetNetToMediaType)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetNetToMediaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetNetToMediaType_undo_setup(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetNetToMediaType data
     *  from 'rowreq_ctx->data->inetNetToMediaType to 'rowreq_ctx->undo->inetNetToMediaType'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetNetToMediaType
 *        A long containing the new value.
 */
int
inetNetToMediaType_set(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                       u_long inetNetToMediaType)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (inetNetToMediaType) {
    case INETNETTOMEDIATYPE_OTHER:
        inetNetToMediaType = INTERNAL_INETNETTOMEDIATYPE_OTHER;
        break;

    case INETNETTOMEDIATYPE_INVALID:
        inetNetToMediaType = INTERNAL_INETNETTOMEDIATYPE_INVALID;
        break;

    case INETNETTOMEDIATYPE_DYNAMIC:
        inetNetToMediaType = INTERNAL_INETNETTOMEDIATYPE_DYNAMIC;
        break;

    case INETNETTOMEDIATYPE_STATIC:
        inetNetToMediaType = INTERNAL_INETNETTOMEDIATYPE_STATIC;
        break;

    case INETNETTOMEDIATYPE_LOCAL:
        inetNetToMediaType = INTERNAL_INETNETTOMEDIATYPE_LOCAL;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for inetNetToMediaType\n",
                 inetNetToMediaType);
        return SNMP_ERR_GENERR;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set inetNetToMediaType value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetNetToMediaType_undo(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetNetToMediaType data
     *  from 'rowreq_ctx->undo->inetNetToMediaType to 'rowreq_ctx->data->inetNetToMediaType'
     */


    return MFD_SUCCESS;
}

/*
 * TODO:
 * check dependencies
 *
 * return SNMP_ERR_NOERROR if the all the changes to the row are legal,
 *        an SNMP error code otherwise.
 *
 * (see README-table-inetNetToMediaTable if you don't have dependencies)
 */
int
inetNetToMediaTable_check_dependencies(inetNetToMediaTable_rowreq_ctx *
                                       rowreq_ctx)
{
    int             rc = SNMP_ERR_NOERROR;

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that all new value are legal.
     *
     * This is useful for for tables which have dependencies
     * between columns.
     *
     * For example, two columns allocating a percentage of something
     * should add up to 100%.
     *
     * At this point in the error checking, if anything goes
     * wrong, SNMP_ERR_GENERR is probably the best error code.
     */
    return rc;
}

/** @} */
/** @{ */
