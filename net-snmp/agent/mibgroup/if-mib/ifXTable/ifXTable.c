/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for ifXTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ifXTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "ifXTable_interface.h"

oid             ifXTable_oid[] = { IFXTABLE_OID };
int             ifXTable_oid_size = OID_LENGTH(ifXTable_oid);

void            initialize_table_ifXTable(void);


/**
 * Initializes the ifXTable module
 */
void
init_ifXTable(void)
{
    DEBUGTRACE;

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("ifXTable"))
        initialize_table_ifXTable();

}

/**
 * Initialize the table ifXTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_ifXTable(void)
{
    ifXTable_registration_ptr user_context;
    u_long          flags;

    DEBUGTRACE;

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _ifXTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
ifXTable_pre_request(ifXTable_registration_ptr user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
ifXTable_post_request(ifXTable_registration_ptr user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table ifXTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ifXTable is subid 1 of ifMIBObjects.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.31.1.1, length: 9
 */

/*
 * ifXTable_allocate_data
 *
 * Purpose: create new ifXTable_data.
 */
ifXTable_data  *
ifXTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    /** this might not be right for netsnmp_interface_entry */
    ifXTable_data  *rtn = netsnmp_access_interface_entry_create(NULL);

    DEBUGTRACE;

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "ifXTable_data.\n");
    }

    return rtn;
}

/*
 * ifXTable_allocate_data
 *
 * Purpose: release data data.
 */
void
ifXTable_release_data(ifXTable_data * data)
{
    DEBUGTRACE;

    /*
     * release memory for the context
     */
    netsnmp_access_interface_entry_free(data);
}



/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values are
 *  native/rawformat, and the mapping function is called (or suggested) when
 *  necessary.
 */
int
ifXTable_indexes_set_tbl_idx(ifXTable_mib_index * tbl_idx, long ifIndex)
{
    DEBUGTRACE;

    /*
     * ifIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/r/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_interface_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->ifIndex = ifIndex;


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
ifXTable_indexes_set(ifXTable_rowreq_ctx * rowreq_ctx, long ifIndex)
{
    if (MFD_SUCCESS !=
        ifXTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx, ifIndex))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != ifXTable_index_to_oid(&rowreq_ctx->oid_idx,
                                   &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifName
 * ifName is subid 1 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.1
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the ifName data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifName_ptr_ptr
 *        Pointer to storage for a char variable
 * @param ifName_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ifName.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ifName_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ifName_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ifName_get(ifXTable_rowreq_ctx * rowreq_ctx, char **ifName_ptr_ptr,
           size_t * ifName_ptr_len_ptr)
{
    size_t len = strlen(rowreq_ctx->data->if_name);

   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ifName_ptr_ptr) && (NULL != *ifName_ptr_ptr));
    netsnmp_assert(NULL != ifName_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifName_ptr_ptr ) and (* ifName_ptr_len_ptr ) from rowreq_ctx->data->
     */
    netsnmp_assert( NULL != rowreq_ctx->data->if_name );
    if( len > (* ifName_ptr_len_ptr ) )
        (* ifName_ptr_ptr ) = malloc(len);
    (* ifName_ptr_len_ptr) = len;
    memcpy((*ifName_ptr_ptr), rowreq_ctx->data->if_name,
           (* ifName_ptr_len_ptr));

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifInMulticastPkts
 * ifInMulticastPkts is subid 2 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.2
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInMulticastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInMulticastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInMulticastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                      u_long * ifInMulticastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInMulticastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInMulticastPkts_ptr ) from rowreq_ctx->data->
     */
    (* ifInMulticastPkts_ptr ) = rowreq_ctx->data->if_imcast.low;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifInBroadcastPkts
 * ifInBroadcastPkts is subid 3 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.3
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInBroadcastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInBroadcastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInBroadcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                      u_long * ifInBroadcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInBroadcastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInBroadcastPkts_ptr ) from rowreq_ctx->data->
     */
    (* ifInBroadcastPkts_ptr ) = rowreq_ctx->data->if_ibcast.low;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifOutMulticastPkts
 * ifOutMulticastPkts is subid 4 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutMulticastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutMulticastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutMulticastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                       u_long * ifOutMulticastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutMulticastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutMulticastPkts_ptr ) from rowreq_ctx->data->
     */
    (* ifOutMulticastPkts_ptr ) = rowreq_ctx->data->if_omcast.low;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifOutBroadcastPkts
 * ifOutBroadcastPkts is subid 5 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutBroadcastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutBroadcastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutBroadcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                       u_long * ifOutBroadcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutBroadcastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutBroadcastPkts_ptr ) from rowreq_ctx->data->
     */
    (* ifOutBroadcastPkts_ptr ) = rowreq_ctx->data->if_obcast.low;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInOctets
 * ifHCInOctets is subid 6 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCInOctets data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInOctets_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCInOctets_get(ifXTable_rowreq_ctx * rowreq_ctx, U64 * ifHCInOctets_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCInOctets_ptr);

    /*
     * TODO:
     * get (* ifHCInOctets_ptr ).low and (* ifHCInOctets_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCInOctets_ptr ).low = rowreq_ctx->data->if_ibytes.low;
    (* ifHCInOctets_ptr ).high = rowreq_ctx->data->if_ibytes.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInUcastPkts
 * ifHCInUcastPkts is subid 7 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCInUcastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInUcastPkts_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCInUcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                    U64 * ifHCInUcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCInUcastPkts_ptr);

    /*
     * TODO:
     * get (* ifHCInUcastPkts_ptr ).low and (* ifHCInUcastPkts_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCInUcastPkts_ptr ).low = rowreq_ctx->data->if_iucast.low;
    (* ifHCInUcastPkts_ptr ).high = rowreq_ctx->data->if_iucast.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInMulticastPkts
 * ifHCInMulticastPkts is subid 8 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.8
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCInMulticastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInMulticastPkts_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCInMulticastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                        U64 * ifHCInMulticastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCInMulticastPkts_ptr);

    /*
     * TODO:
     * get (* ifHCInMulticastPkts_ptr ).low and (* ifHCInMulticastPkts_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCInMulticastPkts_ptr ).low =rowreq_ctx->data->if_imcast.low;
    (* ifHCInMulticastPkts_ptr ).high = rowreq_ctx->data->if_imcast.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCInBroadcastPkts
 * ifHCInBroadcastPkts is subid 9 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCInBroadcastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCInBroadcastPkts_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCInBroadcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                        U64 * ifHCInBroadcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCInBroadcastPkts_ptr);

    /*
     * TODO:
     * get (* ifHCInBroadcastPkts_ptr ).low and (* ifHCInBroadcastPkts_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCInBroadcastPkts_ptr ).low = rowreq_ctx->data->if_ibcast.low;
    (* ifHCInBroadcastPkts_ptr ).high = rowreq_ctx->data->if_ibcast.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutOctets
 * ifHCOutOctets is subid 10 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.10
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCOutOctets data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutOctets_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCOutOctets_get(ifXTable_rowreq_ctx * rowreq_ctx,
                  U64 * ifHCOutOctets_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCOutOctets_ptr);

    /*
     * TODO:
     * get (* ifHCOutOctets_ptr ).low and (* ifHCOutOctets_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCOutOctets_ptr ).low = rowreq_ctx->data->if_obytes.low;
    (* ifHCOutOctets_ptr ).high = rowreq_ctx->data->if_obytes.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutUcastPkts
 * ifHCOutUcastPkts is subid 11 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.11
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCOutUcastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutUcastPkts_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCOutUcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                     U64 * ifHCOutUcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCOutUcastPkts_ptr);

    /*
     * TODO:
     * get (* ifHCOutUcastPkts_ptr ).low and (* ifHCOutUcastPkts_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCOutUcastPkts_ptr ).low = rowreq_ctx->data->if_oucast.low;
    (* ifHCOutUcastPkts_ptr ).high = rowreq_ctx->data->if_oucast.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutMulticastPkts
 * ifHCOutMulticastPkts is subid 12 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.12
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCOutMulticastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutMulticastPkts_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCOutMulticastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                         U64 * ifHCOutMulticastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCOutMulticastPkts_ptr);

    /*
     * TODO:
     * get (* ifHCOutMulticastPkts_ptr ).low and (* ifHCOutMulticastPkts_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCOutMulticastPkts_ptr ).low = rowreq_ctx->data->if_omcast.low;
    (* ifHCOutMulticastPkts_ptr ).high = rowreq_ctx->data->if_omcast.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHCOutBroadcastPkts
 * ifHCOutBroadcastPkts is subid 13 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ifHCOutBroadcastPkts data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHCOutBroadcastPkts_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHCOutBroadcastPkts_get(ifXTable_rowreq_ctx * rowreq_ctx,
                         U64 * ifHCOutBroadcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHCOutBroadcastPkts_ptr);

    /*
     * TODO:
     * get (* ifHCOutBroadcastPkts_ptr ).low and (* ifHCOutBroadcastPkts_ptr ).high from rowreq_ctx->data->
     */
    (* ifHCOutBroadcastPkts_ptr ).low = rowreq_ctx->data->if_obcast.low;
    (* ifHCOutBroadcastPkts_ptr ).high = rowreq_ctx->data->if_obcast.high;


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifLinkUpDownTrapEnable
 * ifLinkUpDownTrapEnable is subid 14 of ifXEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  enabled(1), disabled(2)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifLinkUpDownTrapEnable.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifLinkUpDownTrapEnable_map(u_long * mib_ifLinkUpDownTrapEnable_ptr,
                           u_long raw_ifLinkUpDownTrapEnable)
{
    netsnmp_assert(NULL != mib_ifLinkUpDownTrapEnable_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifLinkUpDownTrapEnable) {
    case INTERNAL_IFLINKUPDOWNTRAPENABLE_ENABLED:
        *mib_ifLinkUpDownTrapEnable_ptr = IFLINKUPDOWNTRAPENABLE_ENABLED;
        break;

    case INTERNAL_IFLINKUPDOWNTRAPENABLE_DISABLED:
        *mib_ifLinkUpDownTrapEnable_ptr = IFLINKUPDOWNTRAPENABLE_DISABLED;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't map value %d for ifLinkUpDownTrapEnable\n",
                 raw_ifLinkUpDownTrapEnable);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ifLinkUpDownTrapEnable data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifLinkUpDownTrapEnable_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifLinkUpDownTrapEnable_get(ifXTable_rowreq_ctx * rowreq_ctx,
                           u_long * ifLinkUpDownTrapEnable_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifLinkUpDownTrapEnable_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifLinkUpDownTrapEnable_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        ifLinkUpDownTrapEnable_map(&(*ifLinkUpDownTrapEnable_ptr),
                                   rowreq_ctx->data->
                                   if_link_updown_trap)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifHighSpeed
 * ifHighSpeed is subid 15 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifHighSpeed data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifHighSpeed_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifHighSpeed_get(ifXTable_rowreq_ctx * rowreq_ctx, u_long * ifHighSpeed_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifHighSpeed_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifHighSpeed_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifPromiscuousMode
 * ifPromiscuousMode is subid 16 of ifXEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * It's syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifPromiscuousMode.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifPromiscuousMode_map(u_long * mib_ifPromiscuousMode_ptr,
                      u_long raw_ifPromiscuousMode)
{
    netsnmp_assert(NULL != mib_ifPromiscuousMode_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifPromiscuousMode) {
    case INTERNAL_IFPROMISCUOUSMODE_TRUE:
        *mib_ifPromiscuousMode_ptr = TRUTHVALUE_TRUE;
        break;

    case INTERNAL_IFPROMISCUOUSMODE_FALSE:
        *mib_ifPromiscuousMode_ptr = TRUTHVALUE_FALSE;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ifPromiscuousMode\n",
                 raw_ifPromiscuousMode);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ifPromiscuousMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifPromiscuousMode_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifPromiscuousMode_get(ifXTable_rowreq_ctx * rowreq_ctx,
                      u_long * ifPromiscuousMode_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifPromiscuousMode_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifPromiscuousMode_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        ifPromiscuousMode_map(&(*ifPromiscuousMode_ptr),
                              rowreq_ctx->data->if_promiscuous)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifConnectorPresent
 * ifConnectorPresent is subid 17 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.17
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * It's syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifConnectorPresent.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifConnectorPresent_map(u_long * mib_ifConnectorPresent_ptr,
                       u_long raw_ifConnectorPresent)
{
    netsnmp_assert(NULL != mib_ifConnectorPresent_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifConnectorPresent) {
    case INTERNAL_IFCONNECTORPRESENT_FALSE:
        *mib_ifConnectorPresent_ptr = TRUTHVALUE_FALSE;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ifConnectorPresent",
                 "(assuming TRUE)\n", raw_ifConnectorPresent);
        /** fall through */
    case INTERNAL_IFCONNECTORPRESENT_TRUE:
        *mib_ifConnectorPresent_ptr = TRUTHVALUE_TRUE;
        break;

    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ifConnectorPresent data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifConnectorPresent_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifConnectorPresent_get(ifXTable_rowreq_ctx * rowreq_ctx,
                       u_long * ifConnectorPresent_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifConnectorPresent_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifConnectorPresent_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        ifConnectorPresent_map(&(*ifConnectorPresent_ptr),
                               rowreq_ctx->data->if_connector_present)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifAlias
 * ifAlias is subid 18 of ifXEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.18
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 64;
 *
 * It's syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Extract the current value of the ifAlias data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifAlias_ptr_ptr
 *        Pointer to storage for a char variable
 * @param ifAlias_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ifAlias.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ifAlias_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ifAlias_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ifAlias_get(ifXTable_rowreq_ctx * rowreq_ctx, char **ifAlias_ptr_ptr,
            size_t * ifAlias_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ifAlias_ptr_ptr)
                   && (NULL != *ifAlias_ptr_ptr));
    netsnmp_assert(NULL != ifAlias_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifAlias_ptr_ptr ) and (* ifAlias_ptr_len_ptr ) from rowreq_ctx->data->
     */
    if( rowreq_ctx->data->if_alias ) {
        size_t len = strlen(rowreq_ctx->data->if_alias);
        if( len > (* ifAlias_ptr_len_ptr ) )
            (* ifAlias_ptr_ptr ) = malloc(len);
        (* ifAlias_ptr_len_ptr) = len;
        memcpy((*ifAlias_ptr_ptr), rowreq_ctx->data->if_alias,
               (* ifAlias_ptr_len_ptr));
    }
    else
        (* ifAlias_ptr_len_ptr ) = 0;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifCounterDiscontinuityTime
 * ifCounterDiscontinuityTime is subid 19 of ifXEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.31.1.1.1.19
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifCounterDiscontinuityTime data->
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifCounterDiscontinuityTime_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifCounterDiscontinuityTime_get(ifXTable_rowreq_ctx * rowreq_ctx,
                               u_long * ifCounterDiscontinuityTime_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifCounterDiscontinuityTime_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifCounterDiscontinuityTime_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}



/** @} */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ifXTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ifXTable is subid 1 of ifMIBObjects.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.31.1.1, length: 9
 */
/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ifXTable_undo_setup(ifXTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * commit new valies.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * @param ifXTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ifXTable_commit(ifXTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * commit data
     */

    return rc;
}


/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifIndex
 * ifIndex is subid 1 of ifEntry.
 * It's status is Mandatory, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.1
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * check validity of ifIndex external index portion
 *
 * NOTE: this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ifXTable_validate_index() function.
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 */
int
ifXTable_ifIndex_check_index(ifXTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for the external index ifIndex is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifLinkUpDownTrapEnable
 * ifLinkUpDownTrapEnable is subid 14 of ifXEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  enabled(1), disabled(2)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifLinkUpDownTrapEnable
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  enabled(1), disabled(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ifLinkUpDownTrapEnable_check_value(ifXTable_rowreq_ctx * rowreq_ctx,
                                   u_long ifLinkUpDownTrapEnable)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifLinkUpDownTrapEnable_undo_setup(ifXTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ifLinkUpDownTrapEnable data
     *  from 'rowreq_ctx->data->ifLinkUpDownTrapEnable to 'rowreq_ctx->undo->ifLinkUpDownTrapEnable'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifLinkUpDownTrapEnable
 *        A long containing the new value.
 */
int
ifLinkUpDownTrapEnable_set(ifXTable_rowreq_ctx * rowreq_ctx,
                           u_long ifLinkUpDownTrapEnable)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (ifLinkUpDownTrapEnable) {
    case IFLINKUPDOWNTRAPENABLE_ENABLED:
        ifLinkUpDownTrapEnable = INTERNAL_IFLINKUPDOWNTRAPENABLE_ENABLED;
        break;

    case IFLINKUPDOWNTRAPENABLE_DISABLED:
        ifLinkUpDownTrapEnable = INTERNAL_IFLINKUPDOWNTRAPENABLE_DISABLED;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for ifLinkUpDownTrapEnable\n",
                 ifLinkUpDownTrapEnable);
        return SNMP_ERR_GENERR;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set ifLinkUpDownTrapEnable value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifLinkUpDownTrapEnable_undo(ifXTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ifLinkUpDownTrapEnable data
     *  from 'rowreq_ctx->undo->ifLinkUpDownTrapEnable to 'rowreq_ctx->data->ifLinkUpDownTrapEnable'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifPromiscuousMode
 * ifPromiscuousMode is subid 16 of ifXEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * It's syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifPromiscuousMode
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ifPromiscuousMode_check_value(ifXTable_rowreq_ctx * rowreq_ctx,
                              u_long ifPromiscuousMode)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifPromiscuousMode_undo_setup(ifXTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ifPromiscuousMode data
     *  from 'rowreq_ctx->data->ifPromiscuousMode to 'rowreq_ctx->undo->ifPromiscuousMode'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifPromiscuousMode
 *        A long containing the new value.
 */
int
ifPromiscuousMode_set(ifXTable_rowreq_ctx * rowreq_ctx,
                      u_long ifPromiscuousMode)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (ifPromiscuousMode) {
    case TRUTHVALUE_TRUE:
        ifPromiscuousMode = INTERNAL_IFPROMISCUOUSMODE_TRUE;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for ifPromiscuousMode",
                 "(assuming FALSE)\n", ifPromiscuousMode);
        /** fall through */

    case TRUTHVALUE_FALSE:
        ifPromiscuousMode = INTERNAL_IFPROMISCUOUSMODE_FALSE;
        break;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set ifPromiscuousMode value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifPromiscuousMode_undo(ifXTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ifPromiscuousMode data
     *  from 'rowreq_ctx->undo->ifPromiscuousMode to 'rowreq_ctx->data->ifPromiscuousMode'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifXEntry.ifAlias
 * ifAlias is subid 18 of ifXEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.31.1.1.1.18
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 255a
 *
 * Ranges:  0 - 64;
 *
 * It's syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifAlias_ptr
 *        A char containing the new value.
 * @param ifAlias_ptr_len
 *        The size (in bytes) of the data pointed to by ifAlias_ptr
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ifXTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is in (one of) the range set(s):  0 - 64
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, and object with the syntax DisplayString(0..40)
 * will have already been checked for a length between 0 and 40.
 * But if the description also specified that the value must
 * be all uppercase letters, you would enforce that requirement here.
 *
 */
int
ifAlias_check_value(ifXTable_rowreq_ctx * rowreq_ctx, char *ifAlias_ptr,
                    size_t ifAlias_ptr_len)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifAlias_ptr);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ifXTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ifXTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ifAlias_undo_setup(ifXTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ifAlias and ifAlias_len data
     *  from 'rowreq_ctx->data->ifAlias to 'rowreq_ctx->undo->ifAlias'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ifAlias_ptr
 *        A char containing the new value.
 * @param ifAlias_ptr_len
 *        The size (in bytes) of the data pointed to by ifAlias_ptr
 */
int
ifAlias_set(ifXTable_rowreq_ctx * rowreq_ctx, char *ifAlias_ptr,
            size_t ifAlias_ptr_len)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ifAlias_ptr);

    /*
     * TODO:
     * set ifAlias value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ifAlias_undo(ifXTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ifAlias and ifAlias_len data
     *  from 'rowreq_ctx->undo->ifAlias to 'rowreq_ctx->data->ifAlias'
     */


    return MFD_SUCCESS;
}

/*
 * TODO:
 * check dependencies
 *
 * return SNMP_ERR_NOERROR if the all the changes to the row are legal,
 *        an SNMP error code otherwise.
 *
 * (see README-table-ifXTable if you don't have dependencies)
 */
int
ifXTable_check_dependencies(ifXTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = SNMP_ERR_NOERROR;

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that all new value are legal.
     *
     * This is useful for for tables which have dependencies
     * between columns.
     *
     * For example, two columns allocating a percentage of something
     * should add up to 100%.
     *
     * At this point in the error checking, if anything goes
     * wrong, SNMP_ERR_GENERR is probably the best error code.
     */
    return rc;
}

/** @} */
/** @{ */
