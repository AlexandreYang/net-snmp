/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <openssl/x509.h>
#include <net-snmp/library/cert_util.h>

#include "tlstm-mib.h"
#include "snmpTlstmParamsTable.h"

static int _count_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests);

static Netsnmp_Node_Handler tlstmParamsTable_handler;


/*
 * Initialize the snmpTlstmParamsTable table by defining its contents and how
 * it's structured.
 */
void
init_snmpTlstmParamsTable(void)
{
    const oid                     reg_oid[] = { SNMP_TLS_TM_BASE, 2, 2, 1, 6 };
    netsnmp_table_data_set       *table_set;
    netsnmp_handler_registration *reg;
    uint32_t                      nv = ST_VOLATILE;

    /*
     * create the table structure itself 
     */
    table_set = netsnmp_create_table_data_set("snmpTlstmParamsTable");

    /*
     * set up RowStatus column 
     */
    table_set->rowstatus_column = COLUMN_SNMPTLSTMPARAMSROWSTATUS;

    /*
     * comment this out or delete if you don't support creation of new rows 
     */
    table_set->allow_creation = 1;

    /***************************************************
     * Adding indexes
     */
    DEBUGMSGTL(("tlstmParamsTable:initialize",
                "adding indexes to table snmpTlstmParamsTable\n"));
    /** index: snmpTargetParamsName */
    netsnmp_table_set_add_indexes(table_set, ASN_PRIV_IMPLIED_OCTET_STR, 0);

    DEBUGMSGTL(("tlstmParamsTable:initialize",
                "adding column types to table snmpTlstmParamsTable\n"));
    netsnmp_table_set_multi_add_default_row(
        table_set,
        COLUMN_SNMPTLSTMPARAMSCLIENTFINGERPRINT, ASN_OCTET_STR, 1, NULL, 0,
        /** defval nonVolatile */
        COLUMN_SNMPTLSTMPARAMSSTORAGETYPE, ASN_INTEGER, 1, &nv, sizeof(vn),
        COLUMN_SNMPTLSTMPARAMSROWSTATUS, ASN_INTEGER, 1, NULL, 0, 0);

    /*
     * registering the table with the master agent 
     */
    netsnmp_register_table_data_set(
        netsnmp_create_handler_registration(
            "snmpTlstmParamsTable", snmpTlstmParamsTable_handler,
            reg_oid, OID_LENGTH(reg_oid), HANDLER_CAN_RWRITE),
        table_set, NULL);
    /*
     * register scalars
     */
    reg_oid[10] = 4;
    reg = netsnmp_create_handler_registration(
        "tlstmParamsCount", _count_handler, reg_oid, OID_LENGTH(reg_oid),
        HANDLER_CAN_RONLY);
    if (NULL == reg)
        snmp_log(LOG_ERR,
                 "could not create handler for snmpTlstmParamsCount\n");
    else
        netsnmp_register_scalar(reg);

#if 0
    reg_oid[10] = 5;
    reg = netsnmp_create_handler_registration(
        "tlstmParamsTableLastChanged", NULL, reg_oid,
        OID_LENGTH(reg_oid), HANDLER_CAN_RONLY);
    watcher = netsnmp_create_watcher_info((void*)&_last_changed,
                                          sizeof(_last_changed),
                                          ASN_TIMETICKS,
                                          WATCHER_FIXED_SIZE);
    if ((NULL == reg) || (NULL == watcher))
        snmp_log(LOG_ERR,
                 "could not create handler for snmpTlstmParamsTableLastChanged\n");
    else
        netsnmp_register_watched_scalar(reg, watcher);
#endif
}

/** handles requests for the snmpTlstmParamsTable table, if anything else needs to be done */
static int
snmpTlstmParamsTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    netsnmp_table_data_set_storage *data = NULL;
    netsnmp_table_row              *row;
    netsnmp_table_request_info     *table_info;
    netsnmp_request_info           *request;
    netsnmp_table_data_set         *datatable;
    oid                            *suffix;
    size_t                          suffix_len;
    int                             ret = SNMP_ERR_NOERROR;

    if ((NULL == handler) || (NULL == reginfo) ||
        (NULL == requests) || (NULL == requests->requestvb))
        return SNMPERR_GENERR;

    datatable = (netsnmp_table_data_set *) handler->myvoid;
    suffix = requests->requestvb->name + reginfo->rootoid_len + 2;
    suffix_len =
        requests->requestvb->name_length - (reginfo->rootoid_len + 2);

    if ((NULL == hander) || (NULL == reginfo) ||
        (NULL == requests) || (NULL == requests->requestvb))
        return SNMPERR_GENERR;

    /*
     * requests have already been processed by the master table_dataset
     * handler; now do extra checks...
     */
    DEBUGMSGTL(("tlstmParamsTable:handler",
                "Processing request (mode %s (%d))\n",
                se_find_label_in_slist("agent_mode", reqinfo->mode),
                reqinfo->mode));

    switch (reqinfo->mode) {
    case MODE_SET_RESERVE1:
        for (request = requests; request; request = request->next) {
            if (request->processed)
                continue;

            /*
             * extract our stored data and table info
             */
            row = netsnmp_extract_table_row(request);
            table_info = netsnmp_extract_table_info(request);
            data =
                netsnmp_table_data_set_find_column(data,
                                                   table_info->colnum);


            switch (table_info->colnum) {
            case COLUMN_SNMPTLSTMPARAMSCLIENTFINGERPRINT:
                /** check len/algorithm MIB requirements */
                ret = netsnmp_cert_check_vb_fingerprint(request->requestvb);
                break;          /* case COLUMN_SNMPTLSTMPARAMSCLIENTFINGERPRINT */
            }                   /* switch */
            break;              /* switch column */
        }                       /* for */
    }                           /* switch mode */
#endif

    if (ret != SNMP_ERR_NOERROR)
        netsnmp_set_request_error(reqinfo, request, ret);

    return SNMP_ERR_NOERROR;
}

static int
_count_handler(netsnmp_mib_handler *handler,
               netsnmp_handler_registration *reginfo,
               netsnmp_agent_request_info *reqinfo,
               netsnmp_request_info *requests)
{
    int                     val;
    netsnmp_table_data_set *datatable = (netsnmp_table_data_set *)
        handler->myvoid;

    if (MODE_GET != reqinfo->mode) {
        snmp_log(LOG_ERR, "bad mode in RO handler");
        return SNMP_ERR_GENERR;
    }

    if (NULL == datatable)
        val = 0;
    else
        val = netsnmp_table_set_num_rows(datatable);

    snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE,
                             (u_char *) &val, sizeof(val));

    if (handler->next && handler->next->access_method)
        return netsnmp_call_next_handler(handler, reginfo, reqinfo,
                                         requests);

    return SNMP_ERR_NOERROR;
}
