.TH "mib parsing and datatype manipulation routines." 3 "28 Oct 2003" "net-snmp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mib parsing and datatype manipulation routines. \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_PrefixList\fP"
.br
.ti -1c
.RI "struct \fBparse_hints\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef _PrefixList * \fBPrefixListPtr\fP"
.br
.ti -1c
.RI "typedef _PrefixList \fBPrefixList\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBsprint_realloc_hexstring\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *cp, size_t len)"
.br
.RI "\fIPrints a hexadecimal string into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_asciistring\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const u_char *cp, size_t len)"
.br
.RI "\fIPrints an ascii string into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_octet_string\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an octet string into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_counter64\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a counter into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_opaque\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an object identifier into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_object_identifier\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an object identifier into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_timeticks\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a timetick variable into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_hinted_integer\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, long val, const char decimaltype, const char *hint, const char *units)"
.br
.RI "\fIPrints an integer according to the hint into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_integer\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an integer into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_uinteger\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an unsigned integer into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_gauge\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a gauge value into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_counter\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a counter value into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_networkaddress\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a network address into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_ipaddress\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints an ip-address into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_null\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a null value into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_bitstring\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIPrints a bit string into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_nsapaddress\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsprint_realloc_badtype\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIFallback routine for a bad type, prints 'Variable has bad type' into a buffer.\fP"
.ti -1c
.RI "int \fBsprint_realloc_by_type\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.RI "\fIUniversal print routine, prints a variable into a buffer according to the variable type.\fP"
.ti -1c
.RI "tree * \fBget_tree_head\fP (void)"
.br
.RI "\fIRetrieves the tree head.\fP"
.ti -1c
.RI "char * \fBsnmp_out_toggle_options\fP (char *options)"
.br
.ti -1c
.RI "void \fBsnmp_out_toggle_options_usage\fP (const char *lead, FILE *outf)"
.br
.ti -1c
.RI "char * \fBsnmp_in_options\fP (char *optarg, int argc, char *const *argv)"
.br
.ti -1c
.RI "char * \fBsnmp_in_toggle_options\fP (char *options)"
.br
.ti -1c
.RI "void \fBsnmp_in_toggle_options_usage\fP (const char *lead, FILE *outf)"
.br
.RI "\fIPrints out a help usage for the in* toggle options.\fP"
.ti -1c
.RI "void \fBregister_mib_handlers\fP (void)"
.br
.ti -1c
.RI "void \fBnetsnmp_set_mib_directory\fP (const char *dir)"
.br
.ti -1c
.RI "char * \fBnetsnmp_get_mib_directory\fP (void)"
.br
.RI "\fIset_string calls strdup, so if we allocated memory, free it.\fP"
.ti -1c
.RI "void \fBnetsnmp_fixup_mib_directory\fP (void)"
.br
.RI "\fINot set use hard coded path.\fP"
.ti -1c
.RI "void \fBinit_mib\fP (void)"
.br
.RI "\fIInitialises the mib reader.\fP"
.ti -1c
.RI "void \fBshutdown_mib\fP (void)"
.br
.RI "\fIUnloads all mibs.\fP"
.ti -1c
.RI "void \fBprint_mib\fP (FILE *fp)"
.br
.RI "\fIPrints the MIBs to the file fp.\fP"
.ti -1c
.RI "void \fBprint_ascii_dump\fP (FILE *fp)"
.br
.ti -1c
.RI "void \fBset_function\fP (struct tree *subtree)"
.br
.RI "\fISet's the printing function printomat in a subtree according it's type.\fP"
.ti -1c
.RI "int \fBread_objid\fP (const char *input, oid *output, size_t *out_len)"
.br
.RI "\fIReads an object identifier from an input string into internal OID form.\fP"
.ti -1c
.RI "void \fBnetsnmp_sprint_realloc_objid\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, int *buf_overflow, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "tree * \fBnetsnmp_sprint_realloc_objid_tree\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, int *buf_overflow, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "int \fBsprint_realloc_objid\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "int \fBsnprint_objid\fP (char *buf, size_t buf_len, const oid *objid, size_t objidlen)"
.br
.ti -1c
.RI "void \fBprint_objid\fP (const oid *objid, size_t objidlen)"
.br
.RI "\fIPrints an oid to stdout.\fP"
.ti -1c
.RI "void \fBfprint_objid\fP (FILE *f, const oid *objid, size_t objidlen)"
.br
.RI "\fIPrints an oid to a file descriptor.\fP"
.ti -1c
.RI "int \fBsprint_realloc_variable\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.ti -1c
.RI "int \fBsnprint_variable\fP (char *buf, size_t buf_len, const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.ti -1c
.RI "void \fBprint_variable\fP (const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.RI "\fIPrints a variable to stdout.\fP"
.ti -1c
.RI "void \fBfprint_variable\fP (FILE *f, const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.RI "\fIPrints a variable to a file descriptor.\fP"
.ti -1c
.RI "int \fBsprint_realloc_value\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.ti -1c
.RI "int \fBsnprint_value\fP (char *buf, size_t buf_len, const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.ti -1c
.RI "void \fBprint_value\fP (const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.ti -1c
.RI "void \fBfprint_value\fP (FILE *f, const oid *objid, size_t objidlen, const netsnmp_variable_list *variable)"
.br
.ti -1c
.RI "int \fBbuild_oid_segment\fP (netsnmp_variable_list *var)"
.br
.RI "\fITakes the value in VAR and turns it into an OID segment in var->name.\fP"
.ti -1c
.RI "int \fBbuild_oid_noalloc\fP (oid *in, size_t in_len, size_t *out_len, oid *prefix, size_t prefix_len, netsnmp_variable_list *indexes)"
.br
.ti -1c
.RI "int \fBbuild_oid\fP (oid **out, size_t *out_len, oid *prefix, size_t prefix_len, netsnmp_variable_list *indexes)"
.br
.ti -1c
.RI "int \fBparse_oid_indexes\fP (oid *oidIndex, size_t oidLen, netsnmp_variable_list *data)"
.br
.RI "\fIxxx-rks: should free previous value?\fP"
.ti -1c
.RI "int \fBparse_one_oid_index\fP (oid **oidStart, size_t *oidLen, netsnmp_variable_list *data, int complete)"
.br
.ti -1c
.RI "int \fBdump_realloc_oid_to_string\fP (const oid *objid, size_t objidlen, u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, char quotechar)"
.br
.ti -1c
.RI "tree * \fBget_tree\fP (const oid *objid, size_t objidlen, struct tree *subtree)"
.br
.RI "\fIClone of get_symbol that doesn't take a buffer argument.\fP"
.ti -1c
.RI "void \fBprint_description\fP (oid *objid, size_t objidlen, int width)"
.br
.RI "\fIPrints on oid description on stdout.\fP"
.ti -1c
.RI "void \fBfprint_description\fP (FILE *f, oid *objid, size_t objidlen, int width)"
.br
.RI "\fIPrints on oid description into a file descriptor.\fP"
.ti -1c
.RI "int \fBsnprint_description\fP (char *buf, size_t buf_len, oid *objid, size_t objidlen, int width)"
.br
.ti -1c
.RI "int \fBsprint_realloc_description\fP (u_char **buf, size_t *buf_len, size_t *out_len, int allow_realloc, oid *objid, size_t objidlen, int width)"
.br
.ti -1c
.RI "int \fBget_module_node\fP (const char *fname, const char *module, oid *objid, size_t *objidlen)"
.br
.ti -1c
.RI "int \fBget_wild_node\fP (const char *name, oid *objid, size_t *objidlen)"
.br
.ti -1c
.RI "int \fBget_node\fP (const char *name, oid *objid, size_t *objidlen)"
.br
.ti -1c
.RI "void \fBclear_tree_flags\fP (register struct tree *tp)"
.br
.ti -1c
.RI "void \fBprint_oid_report\fP (FILE *fp)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_labeledoid\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_oid\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_suffix\fP (void)"
.br
.ti -1c
.RI "void \fBprint_oid_report_enable_symbolic\fP (void)"
.br
.ti -1c
.RI "char * \fBuptime_string\fP (u_long timeticks, char *buf)"
.br
.RI "\fIConverts timeticks to hours, minutes, seconds string.\fP"
.ti -1c
.RI "oid * \fBsnmp_parse_oid\fP (const char *argv, oid *root, size_t *rootlen)"
.br
.RI "\fIGiven a string, parses an oid out of it (if possible).\fP"
.ti -1c
.RI "const char * \fBparse_octet_hint\fP (const char *hint, const char *value, unsigned char **new_val, int *new_val_len)"
.br
.ti -1c
.RI "u_char \fBmib_to_asn_type\fP (int mib_type)"
.br
.ti -1c
.RI "int \fBnetsnmp_str2oid\fP (const char *S, oid *O, int L)"
.br
.RI "\fIConverts a string to its OID form.\fP"
.ti -1c
.RI "int \fBnetsnmp_oid2chars\fP (char *C, int L, const oid *O)"
.br
.RI "\fIConverts an OID to its character form.\fP"
.ti -1c
.RI "int \fBnetsnmp_oid2str\fP (char *S, int L, oid *O)"
.br
.RI "\fIConverts an OID to its string form.\fP"
.ti -1c
.RI "int \fBsnprint_by_type\fP (char *buf, size_t buf_len, netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_hexstring\fP (char *buf, size_t buf_len, const u_char *cp, size_t len)"
.br
.ti -1c
.RI "int \fBsnprint_asciistring\fP (char *buf, size_t buf_len, const u_char *cp, size_t len)"
.br
.ti -1c
.RI "int \fBsnprint_octet_string\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_opaque\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_object_identifier\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_timeticks\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_hinted_integer\fP (char *buf, size_t buf_len, long val, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_integer\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_uinteger\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_gauge\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_counter\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_networkaddress\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_ipaddress\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_null\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_bitstring\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_nsapaddress\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_counter64\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.ti -1c
.RI "int \fBsnprint_badtype\fP (char *buf, size_t buf_len, const netsnmp_variable_list *var, const struct enum_list *enums, const char *hint, const char *units)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "tree * \fBtree_head\fP"
.br
.ti -1c
.RI "tree * \fBMib\fP"
.br
.ti -1c
.RI "oid \fBRFC1213_MIB\fP [] = { 1, 3, 6, 1, 2, 1 }"
.br
.ti -1c
.RI "PrefixList \fBmib_prefixes\fP []"
.br
.in -1c
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "int build_oid_segment (netsnmp_variable_list * var)"
.PP
Takes the value in VAR and turns it into an OID segment in var->name.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIvar\fP\fP
The variable.
.PP
\fBReturns: \fP
.in +1c
SNMPERR_SUCCESS or SNMPERR_GENERR 
.PP
Definition at line 3387 of file mib.c.
.SS "void fprint_description (FILE * f, oid * objid, size_t objidlen, int width)"
.PP
Prints on oid description into a file descriptor.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIf\fP\fP
The file descriptor to print to. 
.TP
\fB\fIobjid\fP\fP
The object identifier. 
.TP
\fB\fIobjidlen\fP\fP
The object id length. 
.TP
\fB\fIwidth\fP\fP
Number of subidentifiers. 
.PP
Definition at line 4261 of file mib.c.
.SS "void fprint_objid (FILE * f, const oid * objid, size_t objidlen)"
.PP
Prints an oid to a file descriptor.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIf\fP\fP
The file descriptor to print to. 
.TP
\fB\fIobjid\fP\fP
The oid to print 
.TP
\fB\fIobjidlen\fP\fP
The length of oidid. 
.PP
Definition at line 3115 of file mib.c.
.SS "void fprint_variable (FILE * f, const oid * objid, size_t objidlen, const netsnmp_variable_list * variable)"
.PP
Prints a variable to a file descriptor.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIf\fP\fP
The file descriptor to print to. 
.TP
\fB\fIobjid\fP\fP
The object id. 
.TP
\fB\fIobjidlen\fP\fP
The length of teh object id. 
.TP
\fB\fIvariable\fP\fP
The variable to print. 
.PP
Definition at line 3262 of file mib.c.
.SS "struct tree* get_tree (const oid * objid, size_t objidlen, struct tree * subtree)"
.PP
Clone of get_symbol that doesn't take a buffer argument.
.PP
\fBSee also: \fP
.in +1c
get_symbol 
.PP
Definition at line 4216 of file mib.c.
.SS "struct tree* get_tree_head (void)"
.PP
Retrieves the tree head.
.PP
\fBReturns: \fP
.in +1c
the tree head. 
.PP
Definition at line 2044 of file mib.c.
.SS "int get_wild_node (const char * name, oid * objid, size_t * objidlen)"
.PP
\fBSee also: \fP
.in +1c
comments on find_best_tree_node for usage after first time. 
.PP
Definition at line 5262 of file mib.c.
.SS "void init_mib (void)"
.PP
Initialises the mib reader.
.PP
Reads in all settings from the environment. 
.PP
Definition at line 2515 of file mib.c.
.SS "void netsnmp_fixup_mib_directory (void)"
.PP
Not set use hard coded path.
.PP
Definition at line 2468 of file mib.c.
.SS "char* netsnmp_get_mib_directory (void)"
.PP
set_string calls strdup, so if we allocated memory, free it.
.PP
Definition at line 2421 of file mib.c.
.SS "int netsnmp_oid2chars (char * C, int L, const oid * O)"
.PP
Converts an OID to its character form.
.PP
in example 5 . 1 . 2 . 3 . 4 . 5 = 12345
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIC\fP\fP
The character buffer. 
.TP
\fB\fIL\fP\fP
The length of the buffer. 
.TP
\fB\fIO\fP\fP
The oid.
.PP
\fBReturns: \fP
.in +1c
0 on Sucess, 1 on failure. 
.PP
Definition at line 6004 of file mib.c.
.SS "int netsnmp_oid2str (char * S, int L, oid * O)"
.PP
Converts an OID to its string form.
.PP
in example 5 . 'h' . 'e' . 'l' . 'l' . 'o' = 'hello\\0' (null terminated)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIS\fP\fP
The character string buffer. 
.TP
\fB\fIL\fP\fP
The length of the string buffer. 
.TP
\fB\fIO\fP\fP
The oid.
.PP
\fBReturns: \fP
.in +1c
0 on Sucess, 1 on failure. 
.PP
Definition at line 6032 of file mib.c.
.SS "int netsnmp_str2oid (const char * S, oid * O, int L)"
.PP
Converts a string to its OID form.
.PP
in example 'hello' = 5 . 'h' . 'e' . 'l' . 'l' . 'o'
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIS\fP\fP
The string. 
.TP
\fB\fIO\fP\fP
The oid. 
.TP
\fB\fIL\fP\fP
The length of the oid.
.PP
\fBReturns: \fP
.in +1c
0 on Sucess, 1 on failure. 
.PP
Definition at line 5969 of file mib.c.
.SS "int parse_oid_indexes (oid * oidIndex, size_t oidLen, netsnmp_variable_list * data)"
.PP
xxx-rks: should free previous value?
.PP
Definition at line 3557 of file mib.c.
.SS "void print_description (oid * objid, size_t objidlen, int width)"
.PP
Prints on oid description on stdout.
.PP
\fBSee also: \fP
.in +1c
\fBfprint_description\fP 
.PP
Definition at line 4245 of file mib.c.
.SS "void print_mib (FILE * fp)"
.PP
Prints the MIBs to the file fp.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIfp\fP\fP
The file descriptor to print to. 
.PP
Definition at line 2695 of file mib.c.
.SS "void print_objid (const oid * objid, size_t objidlen)"
.PP
Prints an oid to stdout.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIobjid\fP\fP
The oid to print 
.TP
\fB\fIobjidlen\fP\fP
The length of oidid. 
.PP
Definition at line 3101 of file mib.c.
.SS "void print_variable (const oid * objid, size_t objidlen, const netsnmp_variable_list * variable)"
.PP
Prints a variable to stdout.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIobjid\fP\fP
The object id. 
.TP
\fB\fIobjidlen\fP\fP
The length of teh object id. 
.TP
\fB\fIvariable\fP\fP
The variable to print. 
.PP
Definition at line 3246 of file mib.c.
.SS "int read_objid (const char * input, oid * output, size_t * out_len)"
.PP
Reads an object identifier from an input string into internal OID form.
.PP
When called, out_len must hold the maximum length of the output array.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIinput\fP\fP
the input string. 
.TP
\fB\fIoutput\fP\fP
the oid wirte. 
.TP
\fB\fIout_len\fP\fP
number of subid's in output.
.PP
\fBReturns: \fP
.in +1c
1 if successful.If an error occurs, this function returns 0 and MAY set snmp_errno. snmp_errno is NOT set if SET_SNMP_ERROR evaluates to nothing. This can make multi-threaded use a tiny bit more robust. 
.PP
Definition at line 2793 of file mib.c.
.SS "void set_function (struct tree * subtree)"
.PP
Set's the printing function printomat in a subtree according it's type.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIsubtree\fP\fP
The subtree to set. 
.PP
Definition at line 2716 of file mib.c.
.SS "void shutdown_mib (void)"
.PP
Unloads all mibs.
.PP
Definition at line 2672 of file mib.c.
.SS "void snmp_in_toggle_options_usage (const char * lead, FILE * outf)"
.PP
Prints out a help usage for the in* toggle options.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIlead\fP\fP
The lead to print for every line. 
.TP
\fB\fIoutf\fP\fP
The file descriptor to write to. 
.PP
Definition at line 2283 of file mib.c.
.SS "oid* snmp_parse_oid (const char * argv, oid * root, size_t * rootlen)"
.PP
Given a string, parses an oid out of it (if possible).
.PP
It will try to parse it based on predetermined configuration if present or by every method possible otherwise. If a suffix has been registered using NETSNMP_DS_LIB_OIDSUFFIX, it will be appended to the input string before processing.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIargv\fP\fP
The OID to string parse 
.TP
\fB\fIroot\fP\fP
An OID array where the results are stored. 
.TP
\fB\fIrootlen\fP\fP
The max length of the array going in and the data length coming out.
.PP
\fBReturns: \fP
.in +1c
The root oid pointer if successful, or NULL otherwise. 
.PP
Definition at line 5577 of file mib.c.
.SS "int sprint_realloc_asciistring (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const u_char * cp, size_t len)"
.PP
Prints an ascii string into a buffer.
.PP
The characters pointed by *cp are encoded as an ascii string.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIcp\fP\fP
the array of characters to encode. 
.TP
\fB\fIlen\fP\fP
the array length of cp.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 365 of file mib.c.
.SS "int sprint_realloc_badtype (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Fallback routine for a bad type, prints 'Variable has bad type' into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1929 of file mib.c.
.SS "int sprint_realloc_bitstring (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a bit string into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1790 of file mib.c.
.SS "int sprint_realloc_by_type (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Universal print routine, prints a variable into a buffer according to the variable type.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1964 of file mib.c.
.SS "int sprint_realloc_counter (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a counter value into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1558 of file mib.c.
.SS "int sprint_realloc_counter64 (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a counter into a buffer.
.PP
The variable var is encoded as a counter value.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 863 of file mib.c.
.SS "int sprint_realloc_gauge (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a gauge value into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1485 of file mib.c.
.SS "int sprint_realloc_hexstring (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const u_char * cp, size_t len)"
.PP
Prints a hexadecimal string into a buffer.
.PP
The characters pointed by *cp are encoded as hexadecimal string.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIcp\fP\fP
the array of characters to encode. 
.TP
\fB\fIlen\fP\fP
the array length of cp.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 263 of file mib.c.
.SS "int sprint_realloc_hinted_integer (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, long val, const char decimaltype, const char * hint, const char * units)"
.PP
Prints an integer according to the hint into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may _NOT_ be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1211 of file mib.c.
.SS "int sprint_realloc_integer (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints an integer into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1285 of file mib.c.
.SS "int sprint_realloc_ipaddress (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints an ip-address into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1687 of file mib.c.
.SS "int sprint_realloc_networkaddress (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a network address into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1621 of file mib.c.
.SS "int sprint_realloc_null (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a null value into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1746 of file mib.c.
.SS "int sprint_realloc_object_identifier (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints an object identifier into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1067 of file mib.c.
.SS "int sprint_realloc_octet_string (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints an octet string into a buffer.
.PP
The variable var is encoded as octet string.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 425 of file mib.c.
.SS "int sprint_realloc_opaque (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints an object identifier into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 977 of file mib.c.
.SS "int sprint_realloc_timeticks (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints a timetick variable into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1137 of file mib.c.
.SS "int sprint_realloc_uinteger (u_char ** buf, size_t * buf_len, size_t * out_len, int allow_realloc, const netsnmp_variable_list * var, const struct enum_list * enums, const char * hint, const char * units)"
.PP
Prints an unsigned integer into a buffer.
.PP
If allow_realloc is true the buffer will be (re)allocated to fit in the  needed size. (Note: *buf may change due to this.)
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIbuf\fP\fP
Address of the buffer to print to. 
.TP
\fB\fIbuf_len\fP\fP
Address to an integer containing the size of buf. 
.TP
\fB\fIout_len\fP\fP
Incremented by the number of characters printed. 
.TP
\fB\fIallow_realloc\fP\fP
if not zero reallocate the buffer to fit the  needed size. 
.TP
\fB\fIvar\fP\fP
The variable to encode. 
.TP
\fB\fIenums\fP\fP
The enumeration ff this variable is enumerated. may be NULL. 
.TP
\fB\fIhint\fP\fP
Contents of the DISPLAY-HINT clause of the MIB. See RFC 1903 Section 3.1 for details. may be NULL. 
.TP
\fB\fIunits\fP\fP
Contents of the UNITS clause of the MIB. may be NULL.
.PP
\fBReturns: \fP
.in +1c
1 on success, or 0 on failure (out of memory, or buffer to small when not allowed to realloc.) 
.PP
Definition at line 1388 of file mib.c.
.SS "char* uptime_string (u_long timeticks, char * buf)"
.PP
Converts timeticks to hours, minutes, seconds string.
.PP
CMU compatible does not show centiseconds.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fItimeticks\fP\fP
The timeticks to convert. 
.TP
\fB\fIbuf\fP\fP
Buffer to write to, has to be at  least 64 Bytes large.
.PP
\fBReturns: \fP
.in +1c
The buffer
.PP
\fBSee also: \fP
.in +1c
uptimeString 
.PP
Definition at line 5547 of file mib.c.
.SH "VARIABLE DOCUMENTATION"
.PP 
.SS "PrefixList mib_prefixes[]"
.PP
\fBInitial value:\fP
.PP
.nf
 {
    {&Standard_Prefix[0]},      
    {'.iso.org.dod.internet.mgmt.mib-2'},
    {'.iso.org.dod.internet.experimental'},
    {'.iso.org.dod.internet.private'},
    {'.iso.org.dod.internet.snmpParties'},
    {'.iso.org.dod.internet.snmpSecrets'},
    {NULL, 0}                   
}
.fi
.PP
Definition at line 160 of file mib.c.
