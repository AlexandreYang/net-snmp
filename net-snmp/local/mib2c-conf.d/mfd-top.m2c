#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
## mfd function params
@eval $mfd_base_params="netsnmp_mfd_registration *mfdr, netsnmp_request_info *requests"@
########################################################################
@open ${name}.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *       version $Revision$ of $RCSfile$ 
 */
@include generic-header-top.m2i@

/* other required module components */
config_require(${name}_interface);
config_require(${name}_data_access);
config_require(${name}_data_get);
config_require(${name}_data_set);

/* OID and column number definitions for table $table */
#include "${name}_oids.h"

/* enum definions */
#include "${name}_enums.h"

/* *********************************************************************
 * function declarations
 */
void init_$name(void);

/* *********************************************************************
 * Table declarations
 */
@foreach $table table@
@    include m2c_setup_table.m2i@
@    include details-table.m2i@
/* *********************************************************************
 * When you register your mib, you get to provide a generic
 * pointer that will be passed back to you for most of the
 * functions calls.
 */
@    if "$m2c_context_reg" eq ""@
    /** TODO: update typedef to correct pointer type.
     * (or add @eval $@m2c_context_reg = "TYPE"@ and regenerate code) */
@        eval $m2c_context_reg = "void *"@
@    end@
typedef $m2c_context_reg ${context}_reg_data;

@    include generic-data-context.m2i@

/* *********************************************************************
 * undo context
 * We're just going to use the same data structure for our
 * undo_context. If you want to do something more efficent,
 * define your typedef here.
 */
typedef ${context}_data ${context}_undo_data;

@    include generic-table-indexes.m2i@

/* *********************************************************************
 * context
 * When your functions are called, you will be passed a
 * ${context}_ctx pointer.
 */
typedef struct ${context}_ctx_s {
    netsnmp_index        oid_idx;
    oid                  oid_tmp[MAX_OID_LEN]; /* xxx-rks: shrink this */
    ${context}_idx       tbl_idx;
    
    ${context}_data      data;
    ${context}_undo_data undo;

    /*
     * TODO: add any other useful data
     *       (e.g. flags for when a column has been set)
     */
    
} ${context}_ctx;

typedef struct ${table}_ref_ctx_s {
    ${table}_ctx *ctx;
} ${table}_ref_ctx;

/* *********************************************************************
 * function prototypes
 */
netsnmp_container *${table}_container_init(netsnmp_mfd_registration *reg);

@    include mfd-access-${m2c_table_access}-header.m2i@

@    if $m2c_data_context ne "generated"@
    ${table}_ctx * _${table}_allocate_ctx(netsnmp_mfd_registration *reg);
@        if $m2c_data_allocate == 1@
    ${context}_data *${context}_allocate_data(void);
@        end@

@   end@
@   if $m2c_table_writable@
@      if $m2c_table_dependencies == 1@
    int ${table}_check_dependencies(netsnmp_mfd_registration *reg, ${table}_ctx * ctx);
@      end@
    int ${context}_reversible_commit($mfd_base_params, ${table}_ctx * ctx);
    int ${context}_final_commit($mfd_base_params, ${table}_ctx * ctx);
@   end@ # writable

@end@ # for each

@include generic-header-bottom.m2i@
######################################################################
## Do the .c file
######################################################################
@open ${name}.c@
/*
 * Note: this file originally auto-generated by mbi2c using
 *       version $Revision$ of $RCSfile$ 
 */
@include generic-source-includes.m2i@

#include "ppk_interface.h"

@foreach $table table@
@    include m2c_setup_table.m2i@
int ${context}_pre_request(netsnmp_mfd_registration *reg, u_long id);
int ${context}_post_request(netsnmp_mfd_registration *reg, u_long id);
@end@

/**
 * Initializes the $name module
 */
void
init_$name(void)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

  /* here we initialize all the tables we're planning on supporting */
  @foreach $table table@
    if (should_init("$table"))
        initialize_table_$table();

  @end@
}

########################################################################
##
@foreach $table table@
@    include m2c_setup_table.m2i@
/**
 * Initialize the table $table 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_$table(void)
{
    netsnmp_mfd_registration mfdr;

    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    /* *************************************************
     * create the table registration information structures
     */
    mfdr = SNMP_MALLOC_TYPEDEF(netsnmp_mfd_registration);
    if (!mfdr) {
        snmp_log(LOG_ERR, "mfd registration malloc failed in "
                          "initialize_table_$table");
        return; /** Serious error. */
    }

    /*
     * If you want to keep a pointer to table specific data,
     * allocate it here and assign it to mfdr->mfd_user_ctx
     */
    /** mfdr->mfd_user_ctx = SNMP_MALLOC_TYPEDEF(my_structure_type); */

    /*
     * OPTIONAL pre/post request handlers
     */
    mfdr.pre_request = (Netsnmp_MFD_Organize_Op*)${table}_pre_request;
    mfdr.post_request = (Netsnmp_MFD_Organize_Op*)${table}_post_request;

    /*
     * REQUIRED for get request handling
     */
    mfdr.get_values = (Netsnmp_MFD_Request_Op*)${table}_get_values;
    
@   if $m2c_table_writable@
    /*
     * REQUIRED for set request handling
     */
    mfdr.object_syntax_checks = (Netsnmp_MFD_Request_Op*)${table}_check_objects;
    mfdr.undo_setup = (Netsnmp_MFD_Request_Op*)${table}_undo_setup;
    mfdr.set_values = (Netsnmp_MFD_Request_Op*)${table}_set_values;
    mfdr.undo_sets = (Netsnmp_MFD_Request_Op*)${table}_undo_values;
    mfdr.undoable_commit = (Netsnmp_MFD_Request_Op*)${table}_reversible_commit;
    mfdr.final_commit = (Netsnmp_MFD_Request_Op*)${table}_final_commit;
    
@      if $m2c_table_dependencies == 1@
    /*
     * REQUIRED for tables with dependencies
     */
    mfdr.consistency_checks = (Netsnmp_MFD_Request_Op*)${table}_check_dependencies;

@      end@
@   end@ # writable
    /*
     * call interface initialization code
     */
    _${table}_initialize_table(&mfdr);
}

/**
 * pre-request callback
 *
 * This is a useful place to make sure you have access to your
 * data source, and perhaps to cache it.
 *
 * @param mfdr Pointer to the netsnmp_mfd_registration for the handler.
 * @param id The request id from the incoming pdu. Hopefully unique,
 *           but no guarantees.
 *
 * @return SNMP_ERR_NOERROR on success.
 *         SNMP_ERR_RESOURCEUNAVAILABLE if you can not get your data.
 *         SNMP_ERR_GENERR for any other error
 */
int
${context}_pre_request(netsnmp_mfd_registration *reg, u_long id)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    /*
     * TODO: pre-request setup
     */
}

/**
 * post-request callback
 *
 * This is a useful place to clean up after a request. If you
 * cached data, you could clean up here.
 *
 * @param mfdr Pointer to the netsnmp_mfd_registration for the handler.
 * @param id The request id from the incoming pdu. Hopefully unique,
 *           but no guarantees.
 *
 * @return SNMP_ERR_NOERROR on success.
 *         SNMP_ERR_GENERR for any other error (ignored)
 */
int
${context}_post_request(netsnmp_mfd_registration *reg, u_long id)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    /*
     * TODO: post-request cleanup
     */
}


@end@

########################################################################
## Do support files
########################################################################
@run generic-table-oids.m2c@
@run generic-table-enums.m2c@
@run mfd-interface.m2c@
@run mfd-data-access.m2c@
@run mfd-data-get.m2c@
@run mfd-data-set.m2c@
@run mfd-makefile.m2m@
@run mfd-readme.m2c@
@run subagent.m2c@
##@run mib2c.column_enums.conf@
##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
