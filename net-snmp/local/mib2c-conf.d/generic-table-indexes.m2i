########################################################################
## generic include for XXX. Don't use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
/*
 * This structure is used to represent the index for a table.
 */
@eval $m2c_gi_others = (count_indexes($table) - 1)@
typedef struct ${table}_idx {

    void *owner; /* object that is responsible for freeing this memory */

@foreach $node index@
@    include m2c_setup_node.m2i@
    /** $node.syntax = $node.perltype = $node.type */
@    if $m2c_node_needlength == 0@
   $m2c_decl   $node;
@    else@
@        eval $m2c_gi_maxlen = (126 - $node.oidlength - $m2c_gi_others)@
@        if $m2c_node_maxlen > $m2c_gi_maxlen@
@            eval $m2c_node_maxlen = $m2c_gi_maxlen@
    /** 128 - 1(entry) - 1(col) - $m2c_gi_others(other indexes) = $m2c_node_maxlen */
@        end@
   $m2c_decl   $node[$m2c_node_maxlen];
   size_t      ${node}_len;
@    end@ # needlength

@end@ # foreach
    /*
     * TODO: add any data needed to allow you to locate this row again.
     *       (e.g. keep a pointer to the row data)
     */
    $m2c_data_context *data; /* example */

} ${table}_idx;

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
