############################################################  -*- c -*-
###generic include for XXX. Do not use directly.
###
### $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
##//####################################################################
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@if $m2c_processing_type eq 'h'@

void ${table}_container_init(netsnmp_container **container_ptr_ptr,
                             netsnmp_cache *cache);
int ${context}_cache_load(netsnmp_container *container);
void ${context}_cache_free(netsnmp_container *container);

@if $m2c_include_examples == 1@
$example_start
/* *********************************************************************
 * Since we have no idea how you really access your data, we'll go with
 * a worst case example: a flat text file.
 @   if $m2c_data_transient != 2@
 @      print Example code is for fully transient data. Either turn off@
 @      print m2c_include_examples or set m2c_data_transient to 2.@
 @      exit@
 @   end@
 */
#define MAX_LINE_SIZE 256
$example_end
@end@ // example
@end@ // m2c_processing_type eq 'h'
##//####################################################################
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@if $m2c_processing_type eq 'c'@
/**
 * container-cached overview
 *
 */

/***********************************************************************
 *
 * cache
 *
 ***********************************************************************/
/**
 * container initialization
 *
 * @param container_ptr_ptr A pointer to a container pointer. If you
 *        create a custom container, use this parameter to return it
 *        to the MFD helper. If set to NULL, the MFD helper will
 *        allocate a container for you.
 * @param  cache A pointer to a cache structure. You can set the timeout
 *         and other cache flags using this pointer.
 *
 *  This function is called at startup to allow you to customize certain
 *  aspects of the access method. For the most part, it is for advanced
 *  users. The default code should suffice for most cases. If no custom
 *  container is allocated, the MFD code will create one for your.
 *
 *  This is also the place to set up cache behavior. The default, to
 *  simply set the cache timeout, will work well with the default
 *  container. If you are using a custom container, you may want to
 *  look at the cache helper documentation to see if there are any
 *  flags you want to set.
 *
 * @remark
 *  This would also be a good place to do any initialization needed
 *  for you data source. For example, opening a connection to another
 *  process that will supply the data, opening a database, etc.
 */
void
${table}_container_init(netsnmp_container **container_ptr_ptr,
                        netsnmp_cache *cache)
{
    if((NULL == cache) || (NULL == container_ptr_ptr)) {
        snmp_log(LOG_ERR,"bad params to ${table}_container_init\n");
        return;
    }

    /*
     * For advanced users, you can use a custom container. If you
     * do not create one, one will be created for you.
     */
    *container_ptr_ptr = NULL;

    /*
     * Also for advance users, you can set parameters for the
     * cache. Do not change the magic pointer, as it is used
     * by the MFD helper.
     */
    cache->timeout = 30; /* seconds */
}

/**
 * load cache data
 *
 * @param container container to which items should be inserted
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_RESOURCE_UNAVAILABLE : Can't access data source
 * @retval MFD_ERROR                : other error.
 *
 *  This function is called to cache the index(es) (and data, optionally)
 *  for the every row in the data set.
 *
 * @remark
 *  While loading the cache, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you can limit yourself to setting the indexes and saving any
 *  information you will need later. Then use the saved information in
 *  ${context}_row_prep() for populating data.
 *
 * @note
 *  If you need consistency between rows (like you want statistics
 *  for each row to be from the same time frame), you should set all
 *  data here.
 *
 */
int
${context}_cache_load(netsnmp_container *container)
{
    ${context}_rowreq_ctx *rowreq_ctx;
@if $m2c_include_examples == 1@
    
    /*
     * this example code is based on a data source that is a
     * text file to be read and parsed.
     */
    FILE *filep;
    char line[MAX_LINE_SIZE];
@foreach $node index@
@    include m2c_setup_node.m2i@
        /** $m2c_node_summary */
@    if $m2c_node_needlength == 1@
@        eval $m2c_gi_maxlen = (126 - $node.oidlength - $m2c_gi_others)@
@        if $m2c_node_maxlen > $m2c_gi_maxlen@
@            eval $m2c_node_maxlen = $m2c_gi_maxlen@
        /** 128 - 1(entry) - 1(col) - $m2c_gi_others(other indexes) = $m2c_node_maxlen */
@        end@
@    end@ # needlength
@    include node-storage.m2i@
@end@ // foreach
@end@ // examples

    DEBUGTRACE;

@if $m2c_include_examples == 1@
$example_start
    /*
     * open our data file.
     */
    filep = fopen("/etc/dummy.conf", "r");
    if(NULL ==  filep) {
        return MFD_RESOURCE_UNAVAILABLE;
    }

$example_end
@end@ // example
    /*
     * TODO: update container
     *
     * loop over your data, allocate, set index, insert into the container
     */
    while( 1 ) {
        /*
         * TODO: check for end of data
         *
         * bail out if there is no more data
         */
@   if $m2c_include_examples == 0@
        if( ${context}_OUT_OF_DATA() )
            break;
@   else@
$example_start
    /*
     * get a line (skip blank lines)
     */
    do {
        if (!fgets(line, sizeof(line), filep)) {
            /* we're done */
            fclose(filep);
            filep = NULL;
        }
    } while (filep && (line[0] == '\n'));

    /*
     * check for end of data
     */
    if(NULL == filep)
        break;

    /*
     * TODO: parse line
     * parse line into variables *
     */
$example_end
@    end@ # example

        /*
         * allocate an row context and set the index(es)
         */
@if $m2c_data_allocate == 1@
        rowreq_ctx = ${context}_allocate_rowreq_ctx(NULL);
@else@
        rowreq_ctx = ${context}_allocate_rowreq_ctx();
@end@
        if(MFD_SUCCESS != ${context}_indexes_set(rowreq_ctx
@   foreach $node index@
@      include m2c_setup_node.m2i@
@        if $m2c_node_needlength == 1@
                               , ${node}, ${node}_len
@        else@
                               , $node
@        end@
@   end@ # foreach index
               )) {
            snmp_log(LOG_ERR,"error setting index while loading "
                     "${context} cache.\n");
            ${context}_release_rowreq_ctx(rowreq_ctx);
            continue;
        }

        /*
         * TODO: populate data context
         */
@if $m2c_data_transient == 0@ # persistent
    /* non-TRANSIENT data: no need to copy. set pointer to data */
@else@
    /*
     * TRANSIENT or semi-TRANSIENT data:
     * can copy data in row_prep or here, depending on when you
     * want to take the hit. Either copy the data now, or save
     * any info needed and do it in row_prep.
     */
@end@
        
        /*
         * insert into table container
         */
        CONTAINER_INSERT(container, rowreq_ctx);
    }
@if $m2c_include_examples == 1@

$example_start
    if(NULL != filep)
        fclose(filep);
$example_end
@end@ # example

    return MFD_SUCCESS;
}

/**
 * cache clean up
 *
 * @param container container with all current items
 *
 *  This optional callback is called prior to all
 *  item's being removed from the container. If you
 *  need to do any processing before that, do it here.
 *
 * @note
 *  The MFD helper will take care of releasing all the
 *  row contexts, so you don't need to worry about that.
 */
void
${context}_cache_free(netsnmp_container *container)
{
}

@end@ // m2c_processing_type eq 'c'
########################################################################
##//####################################################################
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@if $m2c_processing_type eq 'i'@
/**
 * @internal
 */
static int
_cache_load(netsnmp_cache *cache, void *vmagic)
{
    DEBUGTRACE;

    if((NULL == cache) || (NULL == cache->magic)) {
        snmp_log(LOG_ERR, "invalid cache for ${table}_cache_load\n");
        return -1;
    }
    DEBUGMSGTL(("ifTable/cache", "ifTable_load %p/%p\n",
                cache, cache->magic));

    netsnmp_assert(0 == cache->valid);
    
    /*
     * call user code
     */
    return ${table}_cache_load((netsnmp_container*)cache->magic);
}

/**
 * @internal
 */
static void
_cache_item_free(${context}_rowreq_ctx *rowreq_ctx, void *context)
{
    DEBUGTRACE;

    if(NULL == rowreq_ctx)
        return;

    ${context}_release_rowreq_ctx(rowreq_ctx);
}

/**
 * @internal
 */
static void
_cache_free(netsnmp_cache *cache, void *magic)
{
    netsnmp_container *container;

    DEBUGTRACE;

    if((NULL == cache) || (NULL == cache->magic)) {
        snmp_log(LOG_ERR, "invalid cache in ${context}_cache_free\n");
        return;
    }

    container = (netsnmp_container*)cache->magic;

    /*
     * call user code
     */
    ${table}_cache_free(container);
    
    /*
     * free all items. inefficient, but easy.
     */
    CONTAINER_CLEAR(container,
                    (netsnmp_container_obj_func *)_cache_item_free,
                    NULL);
}

/**
 * @internal
 * initialize the iterator container with functions or wrappers
 */
void
_${table}_container_init(${context}_interface_ctx *if_ctx)
{
    DEBUGTRACE;
    
@    if 0@
    /*
     * find cache
     */
    if_ctx->cache =
        netsnmp_cache_find_by_oid(PARTNER_oid, OID_LENGTH(PARTNER_oid));
@    else@
    /*
     * set up the cache
     */
    if_ctx->cache = netsnmp_cache_create(30, /* timeout in seconds */
                                         _cache_load, _cache_free,
                                         ${context}_oid,
                                         ${context}_oid_size);
@    end@ // shared cache

    if(NULL == if_ctx->cache) {
        snmp_log(LOG_ERR, "error creating cache for ${context}\n");
        return;
    }

    ${table}_container_init(&if_ctx->container, if_ctx->cache);
    if(NULL == if_ctx->container)
        if_ctx->container = netsnmp_container_find("${table}:table_container");
    if(NULL == if_ctx->container) {
        snmp_log(LOG_ERR,"error creating container in "
                 "${table}_container_init\n");
        return;
    }
    if_ctx->cache->magic = (void*)if_ctx->container;
}

@end@ // m2c_processing_type eq 'i'
########################################################################
##//####################################################################
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
##//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@if $m2c_processing_type eq 'r'@
##
  container-cached summary
  ------------------------
    The container-cached data access code is for cases when you want to
    cache your data in the agent/sub-agent.

    ... to be continued...


########################################################################
  Updating the Index
  ------------------
    TODO : update index for the raw data
    FUNC : ${table}_indexes_set
    WHERE: ${table}_data_access.c

    This is a convenience function for setting the index context from
    the native C data. Where necessary, value mapping should be done.

    @if $mfd_readme_verbose == 1@
    This function should update the table index values (found in
    tbl_idx) for the given raw data.

    @end@

@end@ // m2c_processing_type eq 'r'
########################################################################
##//####################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
