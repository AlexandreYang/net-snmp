#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
@include mfd-access-unsorted-external-setup.m2i@
##
/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    ${table}_loop_init_context(loop)
 *    ${table}_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          ${table}_loop_save_position(loop,pos);
 *       ${table}_loop_get_next(loop,data)
 *    }
 *    ${table}_loop_get_data(pos,data)
 *    ${table}_loop_cleanup_context(loop)
 */

/**
 * initialization for ${context} data access
 *
 * init_data is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param ${context}_reg Pointer to ${context}_registration
 *
 * @return MFD_SUCCESS : success.
 *         MFD_ERROR   : unrecoverable error.
 */
int
${table}_loop_init_data($mfd_aue_param_decl)
{
    DEBUGTRACE;

@ifconf ${table}_init_data.m2i@
@   include ${table}_init_data.m2i@
@else@
@   if $m2c_include_examples == 1@
$example_start
    /*
     * if you are the sole writer for the file, you could
     * open it here. However, as stated earlier, we are assuming
     * the worst case, which in this case means that the file is
     * written to by someone else, and might not even exist when
     * we start up. So we can't do anything here.
     */
$example_end
@   end@

    return MFD_SUCCESS;
@end@ #ifconf
}

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * initialize the iterator loop context for a new iteration loop.
 *
 * Summary
 * -------
 *  This function will be called before the start of a new itertion over
 *  the data. The loop context that is initialized here will be passed to
 *  ${table}_loop_get_first and ${table}_loop_get_next.
 *
 *  Set the loop context variable loop_ctx_ref->loop_ctx so that the iteration
 *  functions (get_first and get_next) can locate the apropriate data
 *  context.
 *
 * More Details
 * ------------
 * @param $mfd_aue_param_cmt
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @return MFD_SUCCESS     : success.
 *         MFD_END_OF_DATA : an empty data set.
 *         MFD_ERROR       : other error.
 */
int
${table}_loop_init_context( $mfd_aue_param_decl, ${context}_ref_loop_ctx *loop_ctx_ref)
{
    DEBUGTRACE;

    netsnmp_assert(loop_ctx_ref);
    
    /*
     * allocate memory for new structure
     */
    loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(${table}_loop_context);
    if(NULL == loop_ctx_ref->loop_ctx)
        return MFD_ERROR;

    /*
     * allocate a temporary context to use during iteration
     */
    loop_ctx_ref->loop_ctx->rowreq_ctx = ${context}_allocate_rowreq_ctx();
    if(NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
        SNMP_FREE(loop_ctx_ref->loop_ctx);
        return MFD_RESOURCE_UNAVAILABLE;
    }

    /*
     * TODO:
     * set up loop context
     */
@if $m2c_include_examples == 1@
$example_start
    /*
     * open our data file.
     */
    loop_ctx_ref->loop_ctx->filep = fopen("/etc/dummy.conf", "r");
    if(NULL ==  loop_ctx_ref->loop_ctx->filep) {
        return MFD_RESOURCE_UNAVAILABLE;
    }

$example_end
@end@

    return MFD_SUCCESS;
}

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to return set the index(es) for the first
 *  ${table}_data in the data set.

 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourslef to setting the indexes. Extracting the
 *  can be put off until the desired row is found See the notes on
 *  ${table}_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and it's indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  ${table}_loop_init_context, save it in your
 *  ${context}_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  ${table}_loop_get_next, and simply call that function.]
 *
 * @param $mfd_aue_param_cmt
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @return MFD_SUCCESS     : success.
 *         MFD_END_OF_DATA : no data available
 *         MFD_ERROR       : error.
 */
int
${table}_loop_get_first( $mfd_aue_param_decl, ${context}_ref_loop_ctx *loop_ctx_ref,
                    ${context}_ref_rowreq_ctx *rowreq_ctx_ref)
{
    DEBUGTRACE;

    netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
    netsnmp_assert(rowreq_ctx_ref);

    /*
     * we just need the index for now. Reuse the one in the loop context's
     * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
     */
    rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

@ifconf ${table}_update_idx.m2i@
@   include ${table}_update_idx.m2i@
@else@
@   if $m2c_include_examples == 1@
$example_start
    /*
     * get a line (skip blank lines)
     */
    do {
        if (!fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
                   loop_ctx_ref->loop_ctx->filep)) {
            /* we're done */
            fclose(loop_ctx_ref->loop_ctx->filep);
            loop_ctx_ref->loop_ctx->filep = NULL;
        }
    } while (loop_ctx_ref->loop_ctx->filep && loop_ctx_ref->loop_ctx->line[0] == '\n');

    /*
     * check for end of data
     */
    if(NULL == loop_ctx_ref->loop_ctx->filep)
        return MFD_END_OF_DATA;
$example_end
@    end@ # example

    /*
     * TODO:
     * set local vars for index from loop_ctx_ref->loop_ctx
     *  this can be done in one of two ways:
     */
    
    /*
     * 1) individually
     */
@   foreach $node index@
@      include m2c_setup_node.m2i@
        /*
         * TODO:
         * set rowreq_ctx_ref->rowreq_ctx->tbl_idx->$node
@      if $m2c_node_needlength == 1@
         *     and rowreq_ctx_ref->tbl_idx->${node}_len
@      end@
         */
@   end@ #foreach

    /*
     * OR
     */

        /*
         * 2) by calling ${context}_indexes_set()
         * ${context}_indexes_set(rowreq_ctx_ref->tbl_idx,
@   foreach $node index@
@      include m2c_setup_node.m2i@
@        if $m2c_node_needlength == 1@
    *       ${node}_ptr, ${node}_len
@        else@
    *       $node
@        end@
@   end@ # foreach index
    *      );
    */
@end@ #ifconf

    return MFD_SUCCESS;
}

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in ${table}_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param $mfd_aue_param_cmt
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @return MFD_SUCCESS     : success.
 *         MFD_END_OF_DATA : no more data available
 *         MFD_ERROR       : error.
 */
int
${table}_loop_get_next( $mfd_aue_param_decl, ${context}_ref_loop_ctx *loop_ctx_ref,
                        ${context}_ref_rowreq_ctx *rowreq_ctx_ref)
{
    DEBUGTRACE;

    netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
    netsnmp_assert(rowreq_ctx_ref);
    
@if $m2c_include_examples == 1@
$example_start
    /*
     * in this example, get first does the same thing as get next...
     */
    return ${table}_loop_get_first($mfd_aue_param, loop_ctx_ref, rowreq_ctx_ref);
$example_end
@else@
    return MFD_SUCCESS;
@end@ # example
}

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  ${table}_loop_get_data().
@if $m2c_data_transient != 0@ # persistent
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
@end@
 *
@if $m2c_data_transient != 0@ # persistent
 * More Details
 * ------------
@   if $m2c_data_transient == 1@ # short term
 *  Since your data is semi-TRANSIENT data, you could just keep a pointer
 *  to the data in the loop reference. The data should then be copied in
 *  ${table}_loop_get_data().
@   else@ # $m2c_data_transient == 2@ # copy immediately
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
@   end@
@end@
 * @param $mfd_aue_param_cmt
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @return MFD_SUCCESS : success.
 *         MFD_ERROR   : error.
 */
int
${table}_loop_save_position($mfd_aue_param_decl,
                       ${context}_ref_loop_ctx *loop_ctx_ref,
                       ${context}_ref_loop_ctx *save_loop_ctx_ref,
                       int reuse)
{
    DEBUGTRACE;

    netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

    /*
     * TODO:
     * 1) allocate new loop context, unless you can reuse a previous pointer.
     * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
     */
    if((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
        save_loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(${table}_loop_context);
    if(NULL == save_loop_ctx_ref->loop_ctx) {
        snmp_log(LOG_ERR, "could not allocate memory\n");
        return MFD_ERROR;
    }

    /*
     * if you can reuse a previously saved contex, just swap
     * it out with the loop iterator
     */
    if(reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
        ${context}_rowreq_ctx * tmp_rowreq_ctx = save_loop_ctx_ref->loop_ctx->rowreq_ctx;
        save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
    }
    else {
        /*
         * take the current pointer
         */
        save_loop_ctx_ref->loop_ctx->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
        
        /*
         * allocate a new context to replace the one you just took.
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = ${context}_allocate_rowreq_ctx();
        if(NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
            SNMP_FREE(loop_ctx_ref->loop_ctx);
            return MFD_ERROR;
        }
    }
 
@if $m2c_data_transient == 0@ # persistent
    /** non-TRANSIENT data: no need to copy */
@elsif $m2c_data_transient == 1@ # short term
    /** semi-TRANSIENT data: will copy data when index found */
    /** only need to copy pertinent data from loop context */
@elsif $m2c_data_transient == 2@ # copy immediately
    /*
     * TRANSIENT data: copy all the data.
     */
@end@
@if $m2c_include_examples == 1@
$example_start
@  if $m2c_data_transient == 1@ # short term
    /** save line to do that */
    memcpy(save_loop_ctx_ref->loop_ctx->line, loop_ctx_ref->loop_ctx->line,
           sizeof(loop_ctx_ref->loop_ctx->line));
@  elsif $m2c_data_transient == 2@ # copy immediately
@    foreach $node nonindex@
@      include m2c_setup_node.m2i@
    /*
     * TODO:
     * set rowreq_ctx_ref->${m2c_data_item}$node
     *     from the loop context
     */
@    end@
@  end@
$example_end
@end@ # example
    
    return MFD_SUCCESS;
}

@if $m2c_data_transient != 0@ # 
/**
 * set ${table}_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  ${table}_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param $mfd_aue_param_cmt
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
${table}_loop_get_data( $mfd_aue_param_decl, ${context}_ref_loop_ctx *loop_ctx_ref,
                           ${context}_ref_rowreq_ctx *rowreq_ctx_ref)
{
    DEBUGTRACE;

    netsnmp_assert((NULL != loop_ctx_ref) && (NULL != loop_ctx_ref->loop_ctx));
    netsnmp_assert(NULL != rowreq_ctx_ref);
    netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

    /*
     * take temporary row request context from loop context
     */
    rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
    loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;
    
    /*
     * copy data to the data context (rowreq_ctx_ref->${m2c_data_item})
     */
##@if $m2c_include_examples == 1@
##$example_start
@   foreach $node nonindex@
@      include m2c_setup_node.m2i@
    /*
     * $m2c_node_summary
     */
@   eval $m2c_ctx_lh = "rowreq_ctx_ref->$m2c_ctx_rh"@
@   eval $m2c_ctx_lhs = "rowreq_ctx_ref->$m2c_ctx_rhs"@
@   eval $m2c_ctx_rh = "loop_ctx_ref->loop_ctx->TODO_FIND_$node"@
@   eval $m2c_ctx_rhs = "loop_ctx_ref->loop_ctx->TODO_FIND_${node}_len@"@
@   include generic-value-map.m2i@
    
@   end@
##$example_end
##@end@

   return MFD_SUCCESS;
}

@end@ # if $m2c_data_transient != 0

/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param $mfd_aue_param_cmt
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @return MFD_SUCCESS : success.
 *         MFD_ERROR   : error.
 */
int
${table}_loop_cleanup_context( $mfd_aue_param_decl, ${context}_ref_loop_ctx *loop_ctx_ref)
{
    DEBUGTRACE;
    
    netsnmp_assert(loop_ctx_ref);
    
    if(!loop_ctx_ref->loop_ctx)
        return MFD_ERROR;

    /*
     * release the row request context, if it wasn't taken
     */
    if(loop_ctx_ref->loop_ctx->rowreq_ctx)
        ${context}_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

    /*
     * TODO:
     * release resources
     */
@if $m2c_include_examples == 1@
$example_start
    /*
     * close file
     */
    if(loop_ctx_ref->loop_ctx->filep)
        fclose(loop_ctx_ref->loop_ctx->filep);
$example_end
    
@end@
    /*
     * free loop context
     */
    free(loop_ctx_ref->loop_ctx);
    
    return MFD_SUCCESS;
}

########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
