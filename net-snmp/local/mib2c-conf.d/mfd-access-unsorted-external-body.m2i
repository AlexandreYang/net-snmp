#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
@include mfd-access-unsorted-external-setup.m2i@
##
/**
 * initialization for ${context} data access
 *
 * init_data is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param ${context}_reg Pointer to ${context}_registration
 *
 * @return MFD_SUCCESS : success.
 *         MFD_ERROR   : unrecoverable error.
 */
int
    ${table}_init_data($mfd_aue_param_decl)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@ifconf ${table}_init_data.m2i@
@   include ${table}_init_data.m2i@
@else@
@if $m2c_include_examples == 1@
$example_start
    /*
     * if you are the sole writer for the file, you could
     * open it here. However, as stated earlier, we are assuming
     * the worst case, which in this case means that the file is
     * written to by someone else, and might not even exist when
     * we start up. So we can't do anything here.
     */
$example_end
@end@

    return MFD_SUCCESS;
}

@if $m2c_data_transient != 0@ # 
/**
 * set ${table}_data from a data context
 *
 * Once the loop iteration has completed and the best match has been
 * found, this function will be called to copy the data to a newly
 * created context.
 *
 * @param $mfd_aue_param_cmt
 * @param loop_ref pointer to your loop reference.
 * @param ctx_ref pointer to a context reference.
 */
int
${table}_get_data( $mfd_aue_param_decl, ${table}_ref_loop *loop_ref,
                           ${table}_ref_ctx *ctx_ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    netsnmp_assert((NULL != loop_ref) && (NULL != loop_ref->itr_ctx));
    netsnmp_assert(NULL != ctx_ref);
    
@if $m2c_include_examples == 1@
$example_start
    ctx_ref->ctx = loop_ref->itr_ctx->ctx;
    loop_ref->itr_ctx->ctx = NULL;
    
    /*
     * copy data to the context
     */
@   foreach $node nonindex@
@      include m2c_setup_node.m2i@
    /** TODO: set ctx_ref->${m2c_data_item}$node
@      if $m2c_data_transient == 1@ # short term
     **       from loop_ref->line */
@      else@
     **       from orig_${m2c_data_item}$node */
@      end@
@   end@
$example_end
@end@

   return MFD_SUCCESS;
}

@end@

@if $m2c_include_examples == 1@
$example_start
/**
 * Update the index for the current iterator position.
 *
 * This example routine updates the index for the current row. It is
 * called by the get_first and get_next functions.
 *
 * @return MFD_SUCCESS     : success
 *         MFD_END_OF_DATA : no data is available
 *         MFD_ERROR       : error.
 */
static int
${table}_read_and_update_index( $mfd_aue_param_decl,
                       ${table}_ref_loop *loop_ref,
                       ${table}_ref_ctx *ctx_ref)
{
    int rc;

    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@ifconf ${table}_update_idx.m2i@
@   include ${table}_update_idx.m2i@
@else@
    
    /*
     * mfd wrappers just need the index for now.
     * reuse ctx.tbl_idx.
     */
    ctx_ref->ctx = loop_ref->itr_ctx->ctx;

    /*
     * get a line (skip blank lines)
     */
    do {
        if (!fgets(loop_ref->itr_ctx->line, sizeof(loop_ref->itr_ctx->line),
                   loop_ref->itr_ctx->filep)) {
            /* we're done */
            fclose(loop_ref->itr_ctx->filep);
            loop_ref->itr_ctx->filep = NULL;
        }
    } while (loop_ref->itr_ctx->filep && loop_ref->itr_ctx->line[0] == '\n');

    /*
     * check for end of data
     */
    if(NULL == loop_ref->itr_ctx->filep)
        return MFD_END_OF_DATA;

             
@foreach $node index@
@    include m2c_setup_node.m2i@
    /* TODO: parse loop_ref->line to set ctx_ref->tbl_idx->$node */
@end@
@end@

    return rc;
}
$example_end
@end@

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * initialize the iterator loop context for a new iteration loop.
 *
 * This function will be called before the start of a new itertion over
 * the data.
 *
 * Set the loop_context variable ref->itr_ctx to the first data point
 * structure of your choice (from which you can find the next one).  This
 * could be anything from the first node in a linked list, to an integer
 * pointer containing the beginning of an array variable.
 *
 * @param $mfd_aue_param_cmt
 * @param ref  Pointer to your loop reference.
 *
 * @return MFD_SUCCESS     : success.
 *         MFD_END_OF_DATA : an empty data set.
 *         MFD_ERROR       : other error.
 */
int
${table}_init_loop_ctx( $mfd_aue_param_decl, ${table}_ref_loop *ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    /*
     * allocate memory for new structure
     */
    ref->itr_ctx = SNMP_MALLOC_TYPEDEF(${table}_loop_ctx);
    if(NULL == ref->itr_ctx)
        return MFD_ERROR;

    /*
     * TODO: set loop context
     */
@if $m2c_include_examples == 1@
$example_start
    /*
     * allocate a context to use
     */
    ref->itr_ctx->ctx = ${context}_allocate_ctx();
    if(NULL == ref->itr_ctx->ctx) {
        SNMP_FREE(ref->itr_ctx);
        return MFD_ERROR; /* xxx-rks: resource unavailable? */
    }

    /*
     * open our data file.
     */
    ref->itr_ctx->filep = fopen("/etc/dummy.conf", "r");
    if(NULL ==  ref->itr_ctx->filep) {
        return MFD_ERROR; /* xxx-rks: resource unavailable? */
    }

$example_end
@end@

    return MFD_SUCCESS;
}

/**
 * clean up a loop reference
 *
 * This function will be called to release a loop reference once
 * the iteration has completed.
 *
 * @param $mfd_aue_param_cmt
 * @param ref  Pointer to your loop reference.
 *
 * @return MFD_SUCCESS : success.
 *         MFD_ERROR   : error.
 */
int
${table}_cleanup_loop_ctx( $mfd_aue_param_decl, ${table}_ref_loop *ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));
    
@if $m2c_include_examples == 1@
$example_start
    if(!ref->itr_ctx)
        return MFD_ERROR;

if(ref->itr_ctx->ctx)
    ${context}_release_ctx(ref->itr_ctx->ctx);
 
    /*
     * close file
     */
    if(ref->itr_ctx->filep)
        fclose(ref->itr_ctx->filep);
    
    /*
     * free loop context
     */
    free(ref->itr_ctx);
$example_end
@end@
    
    return MFD_SUCCESS;
}

/**
 * duplicate the current loop reference
 *
 * During loop iteration, the iterator keeps track of the row that
 * is the current best match. This function is called when the
 * current row is a better match than any previous row.
 * You should update the table index for the current row, along with
 * any other pertinent data in your loop reference structure.
 *
@if $m2c_data_transient != 0@ # persistent
 * Since your data is transient, we need to make a copy of it before
 * the iterator moves on to the next row.
 *
@   if $m2c_data_transient == 1@ # short term
* Since your data is semi-TRANSIENT data, you could just keep a pointer
* to the data in the loop reference. The data should then be copied in
* ${table}_get_data().
@   else@ # $m2c_data_transient == 2@ # copy immediately
* Since your data is TRANSIENT data, you should make a copy of it here.
* One idea would be to copy it space allocated in the loop reference
* structure. Another would be to simply have a pointer in the loop
* reference structure, and allocate memory here.
@   end@
 *
@end@
 * @param $mfd_aue_param_cmt
 * @param loop_ref  Reference to current loop context.
 * @param loop_save Reference to a loop context for saving the current position
 *                  If reuse is not set or loop_save->itr_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  itr_ctx.
 * @param reuse     Indicates if an existing loop_save->itr_ctx may be reused.
 *
 * @return MFD_SUCCESS : success.
 *         MFD_ERROR   : error.
 */
int
${table}_save_position($mfd_aue_param_decl,
                       ${table}_ref_loop *loop_ref,
                       ${table}_ref_loop *loop_save,
                       int reuse)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@if $m2c_include_examples == 1@
$example_start

    /*
     * allocate new loop context, unless we can reuse a previous pointer
     */
    if((0 == reuse) || (NULL == loop_save->itr_ctx))
        loop_save->itr_ctx = SNMP_MALLOC_TYPEDEF(${table}_loop_ctx);
    if(NULL == loop_save->itr_ctx) {
        snmp_log(LOG_ERR, "could not allocate memory\n");
        return MFD_ERROR;
    }

    /*
     * if we can reuse a previously saved contex, just swap
     * it out with the loop iterator
     */
    if(reuse && loop_save->itr_ctx->ctx) {
        ifXTable_ctx * tmp_ctx = loop_save->itr_ctx->ctx;
        loop_save->itr_ctx->ctx = loop_ref->itr_ctx->ctx;
        loop_ref->itr_ctx->ctx = tmp_ctx;
    }
    else {
        /*
         * take the current pointer
         */
        loop_save->itr_ctx->ctx = loop_ref->itr_ctx->ctx;
        
        /*
         * allocate a new context to replace the one we took.
         * shouldn't need the locked flag or the filep pointer.
         * (well, we *could* use it to do things a little differently;
         * like if we know we had the file locked and wanted to save
         * the current offset for writing back new values... but we are
         * trying to keep this example simple.)
         */
        loop_ref->itr_ctx->ctx = ${context}_allocate_ctx();
        if(NULL == loop_ref->itr_ctx->ctx) {
            SNMP_FREE(loop_ref->itr_ctx);
            return MFD_ERROR; /* xxx-rks: resource unavailable? */
        }
    }

 
@if $m2c_data_transient == 0@ # persistent
    /** non-TRANSIENT data: no need to copy */
@elsif $m2c_data_transient == 1@ # short term
    /** semi-TRANSIENT data: will copy data when index found */
    /** have to save line to do that */
    memcpy(loop_save->itr_ctx->line, loop_ref->itr_ctx->line,
           sizeof(loop_ref->itr_ctx->line));
@elsif $m2c_data_transient == 2@ # copy immediately
    /*
     * TRANSIENT data: we are using a buffer in the loop ctx,
     * So we need to copy the data.
     */
    /*
     * for this example, it would be cheap to just save line.
     * but we'll assume worst case, and just go ahead and setup
     * the individual data items...
     */
@   foreach $node nonindex@
@      include m2c_setup_node.m2i@
    /** TODO: set ctx_ref->${m2c_data_item}$node
     **       from loop_ref->line */
@   end@
@end@
$example_end
@end@ # example
    
    return MFD_SUCCESS;
}

/**
 * get the first data index
 *
 * Use the loop_ref set up in ${table}_init_loop_ctx
 * to set the indexes for the first object.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set ctx_ref->ctx and it's indexes.
 *
 * ctx_ref->ctx will be NULL. You should allocate a new context
 * for this loop. [Alternatively, you could allocate one in
 * ${table}_init_loop_ctx, save it in your
 * ${table}_ref_loop, and use it here.]
 *
 * Once you have your context pointer, you should set the index (or indexes)
 * in ctx_ref->ctx->tbl_idx to the appropriate value for this row. [If you
 * use your loop_ref cleverly, you might be able to put this work in
 * ${table}_get_next, and simply call that function.]
 *
 * @param $mfd_aue_param_cmt
 * @param ref  Pointer to your loop reference.
 * @param ref  Pointer to a context reference.
 *
 * @return MFD_SUCCESS     : success.
 *         MFD_END_OF_DATA : no data available
 *         MFD_ERROR       : error.
 */
int
${table}_get_first( $mfd_aue_param_decl, ${table}_ref_loop *loop_ref,
                    ${table}_ref_ctx *ctx_ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@if $m2c_include_examples == 1@
$example_start
    /*
     * check for end of data
     */
    if(NULL == loop_ref->itr_ctx->filep)
        return MFD_END_OF_DATA;

/*
 * do actual read of data in update_index, since get and get_next do
 * the same thing...
 */
    return ${table}_read_and_update_index($mfd_aue_param, loop_ref, ctx_ref);
$example_end
@else@
    return MFD_SUCCESS;
@end@ # example
}

/**
 * get the next data index
 *
 * Use the loop_ref set up in ${table}_init_loop_ctx
 * to set the indexes for the next object.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in ctx_ref->ctx->tbl_idx.
 *
 * ctx_ref->ctx will have been set in ${table}_get_first.
 *
 * ou should set the index (or indexes) in ctx_ref->ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param $mfd_aue_param_cmt
 * @param ref  Pointer to your loop reference.
 * @param ref  Pointer to a context reference.
 *
 * @return MFD_SUCCESS     : success.
 *         MFD_END_OF_DATA : no more data available
 *         MFD_ERROR       : error.
 */
int
${table}_get_next( $mfd_aue_param_decl, ${table}_ref_loop *loop_ref,
                        ${table}_ref_ctx *ctx_ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@if $m2c_include_examples == 1@
$example_start
    /*
     * check for end of data
     */
    if(NULL == loop_ref->itr_ctx->filep)
        return MFD_END_OF_DATA;

/*
 * do actual read of data in update_index, since get and get_next do
 * the same thing...
 */
    return ${table}_read_and_update_index($mfd_aue_param, loop_ref, ctx_ref);
$example_end
@else@
    return MFD_SUCCESS;
@end@ # example
}

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
