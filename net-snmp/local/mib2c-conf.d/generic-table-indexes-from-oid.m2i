#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
/**
 * extract ${context} indexes from a netsnmp_index
 *
 * @return SNMP_ERR_NOERROR  : no error
 *         SNMP_ERR_GENERR   : error
 */
int
${context}_index_from_oid(netsnmp_index *oid_idx,
                         ${context}_mib_index *mib_idx)
{
@include generic-table-indexes-varbind-setup.m2i@

    DEBUGMSGT(("mfd:table:trace:${name}",">%s\n",__FUNCTION__));

    /*
     * parse the oid into the individual index components
     */
    err = parse_oid_indexes( oid_idx->oids, oid_idx->len,
                             &var_$m2c_dii_first );
    if (err == SNMP_ERR_NOERROR) {
        /*
         * copy out values
         */
@    eval $m2c_node_name = ""@ # purge node name to re-eval $m2c_node_var_name
@    foreach $node index@
@        eval $m2c_node_var_name = "var_${node}."@
@        include m2c_setup_node.m2i@
@        if $m2c_node_needlength == 1@
         if(var_${node}.val_len > sizeof(mib_index->$node))
             err = SNMP_ERR_GENERR;
         else {
             memcpy(mib_index->${node}, var_${node}.string, var_${node}.val_len);
             mib_index->${node}_len = var_${node}.val_len;
         }
@        else@
    mib_idx->$node = $m2c_node_var_val;
@        end@
@    end@ # foreach
@    eval $m2c_node_var_name = ""@ #reset custom name
@    eval $m2c_node_name = ""@ # purge node name to re-eval $m2c_node_var_name


    }

    /*
     * parsing may have allocated memory. free it.
     */
    snmp_reset_var_buffers( &var_$m2c_dii_first );

    return err;
}


##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
