#!/usr/local/bin/perl -w

#
# Description: 
#
# This program, given an OID reference as an argument, creates some
# template mib module files to be used with the ucd-snmp agent.  It is
# far from perfect and will not generate working modules, but it
# significantly shortens development time by outlining the basic
# structure.
#
# Its up to you to verify what it does and change the default values
# it returns.
#

use SNMP;
use FileHandle;

#use strict 'vars';
$SNMP::save_descriptions=1;
$SNMP::use_long_names=1;
$SNMP::use_enums=1;
SNMP::initMib();

$configfile="mib2c.conf";
$dodata = 0;
$doparser = 0;
$debug=0;

sub usage {
    print "$0 [-h] [-c configfile] [-f prefix] mibNode\n\n";
    print "  -h\t\tThis message.\n\n";
    print "  -c configfile\tSpecifies the configuration file to use\n\t\tthat dictates what the output of mib2c will look like.\n\n";
    print "  -f prefix\tSpecifies the output prefix to use.  All code\n\t\twill be put into prefix.c and prefix.h\n\n";
    print "  mibNode\tThe name of the top level mib node you want to\n\t\tgenerate code for.  By default, the code will be stored in\n\t\tmibNode.c and mibNode.h (use the -f flag to change this)\n\n";
    1;
}	

while($#ARGV >= 0) {
    $_ = shift;
    $configfile = shift if (/-c/);
    $dodata = 1 if (/-d/);
    $doparser = 1 if (/-p/);
    usage && exit(1) if (/-h/);
    $outputName = shift if (/-f/);
    $oid = $_ if (/^[^-]/);
}
 
read_config($configfile);
#
# internal conversion tables
#

%accessToUCD = qw(ReadOnly RONLY ReadWrite RWRITE 
		  WriteOnly RWRITE Create RWRITE);

#  The lengths of the defined 'variableN' structures
@varLengths = (2,4,7,8,13);

if (!defined($oid)) {
    print STDERR "You didn\'t specify a mib oid to convert!\n";
    usage();
    exit(1);
}

$mib = $SNMP::MIB{$oid};
$_ = $commaoid = $fulloid = $mib->{'objectID'};
if (!defined ($fulloid)) {
    print STDERR "Couldn\'t find mib reference: $oid\n";
    exit(1);
}
s/[^.]//g;
$commaoid =~ s/\./,/g;
$commaoid =~ s/^,//g;

$outputName = $mib->{'label'} if (!defined($outputName));
$OUTPUTNAME = uc($outputName);
$vroutine="$outputName";
print "outputting to $outputName.c and $outputName.h ...\n";

#============================================
#
#   Walk the MIB tree, and construct strings
#     holding the various fragments of code needed.
#
#   'loadMib' returns the length of the longest OID suffix
#     encountered.
#
#   The variables constructed and used are:
#
#   (in the header file)
#	functionInfo :	A list of definitions for the table-handling functions,
#			and routines for SETtable variables.
#			(The main scalar handling routine is handled implicitly)
#
#   (in the code file)
#	structinfo :	The contents of the variableN structure listing
#			the variables handled, including type, access level,
#			OID suffix and 'magic number'
#
#	caseStatements:	A hash array (indexed by variable routine name)
#			containing the body of the switch statement
#			used for returning the appropriate values.
#			At a minimum, this consists of the various 'case' labels
#			If full type information is available (from mib2c.conf)
#			then this will also include a default initialiser,
#			and setting of a 'write_method' (if appropriate).
#
#	writeFuncs:	A list of function skeletons for setting variables
#			(for variables with suitable access levels).
#			Note that this list will not include functions
#			for variables which don't provide type information
#			in the mib2c.conf file (even if such variables are
#			defined as writeable in the variableN structure).
#
#============================================
$count = 0;
$depth = loadMib($mib,0)-1;

#  Determine which 'variableN' structure is needed
for($varlen = 0; $varlen <= $#varLengths; $varlen++) {
  last if ($depth <= $varLengths[$varlen]);
}
$varlen = $varLengths[$varlen];


#============================================
#
#   Output the header file
#
#============================================
open(DOTH,">$outputName.h");
print DOTH (eval "\"$variableTypes{'code-dot-c-init'}{'code'}\"") . "\n";;
close(DOTH);



#============================================
#
#   Output the code file:
#	Initialisation and main variable routine.
#
#============================================

open(DOTC,">$outputName.c");
print DOTC (eval "\"$variableTypes{'code-main-part'}{'code'}\"") . "\n\n";;

#============================================
#
#	Table-handling routines.
#
#============================================
foreach $vtable (@table_list) {
    print DOTC (eval "\"$variableTypes{'code-var_table'}{'code'}\"") . "\n\n";;
}

#============================================
#
#	Writing routines.
#	   (and reporting on the results)
#
#============================================
print DOTC "$writeFuncs";
close(DOTC);




print "  depth: $depth\n";
print "  Number of Lines Created:\n";
system("wc -l $outputName.c $outputName.h");
print "Done.\n";


#============================================
#
#  loadMib:
#	Recursive routine to walk the mib,
#	and construct the various code fragment strings.
#
#============================================
sub loadMib {
    my $mib = shift;
    my $depth = shift;
    $depth = $depth + 1;
    my $name = $mib->{'label'};
    my $cname = uc($name);
    print "doing $mib->{label} : $mib->{objectID}\n" if $debug;
    if (defined($mib->{'access'}) && 
	$mib->{'access'} =~ /ReadOnly|ReadWrite|WriteOnly|Create/) {
	$caseStatement = "    case $cname:\n";
	$count = $count + 1;
	$subid = $mib->{'objectID'};
	$subid =~ s/$fulloid\.//;
	$subid =~ s/\./,/g;
	$structinfo .= sprintf("#define   %-20s  $count\n", $cname);
	if (!defined($variableTypes{$mib->{'type'}})) {
	    $caseStatement .= "/* unknown type: $mib->{type}.  mib2c can not set up a default value for this mib value */\n";
	    # $defineStatements .= "/* unknown type: $mib->{type}.  mib2c can not handle this mib value: */\n";
	    $count = $count + 1;
	    print STDERR "unknown type:  $mib->{type} for $mib->{label}\n";
	    $structinfo .= 
		sprintf("/* unknown type: $mib->{type}.  mib2c can not handle this mib value: */\n{ %-20s, %-14s, %-6.6s, %s, %d, { %s } },\n",
			$cname, "UNKNOWN_TYPE_$mib->{type}",
			$accessToUCD{$mib->{'access'}},
			"var_$vroutine",
			$depth-1, $subid);
	} else {
	    if ($mib->{'access'} =~ /ReadWrite|WriteOnly|Create/) {
		createWriteFunction($mib->{'label'}, $mib->{'type'});
		$caseStatement .= "      *write_method = write_$mib->{label};\n";
	    }
	    $x = $variableTypes{$mib->{'type'}}{'defaultInit'};
	    $x =~ s/\n/\n        /g;
	    $x = "        " . $x;
	    $caseStatement .= $x . "\n";
	    $structinfo .= 
		sprintf("  { %-20s, %-14s, %-6.6s, %s, %d, { %s } },\n",
			$cname, $variableTypes{$mib->{'type'}}{'asnType'},
			$accessToUCD{$mib->{'access'}},
			"var_$vroutine",
			$depth-1, $subid);
	}
	$caseStatement .= "\n";
	$caseStatements{$vroutine} .= $caseStatement;
	# $defineStatements .= sprintf("#define   %-20s  $count\n", $cname);
    }
    my $children = $$mib{'children'}; 
    my $i;
    my $newdepth = $depth;
    foreach $i (@{$children}) {
	if ( $name =~ /Table$/ ) {
	    $vroutine="$name";
    	    $functionInfo .= "unsigned char *var_$name(struct variable *, oid *, int *, int, int *, WriteMethod **write_method);\n";
	    push @table_list, $name;
	    $newdepth = max(loadMib($i, $depth), $newdepth);
	    $vroutine="$outputName";
	}
	else {
	    $newdepth = max(loadMib($i, $depth), $newdepth);
	}
    }
    return $newdepth;
}

sub max {
    my $x = shift;
    my $y = shift;
    return ($x > $y) ? $x : $y;
}


#============================================
#
#  createWriteFunction:
#	Construct a write function for the current variable,
#	including a declaration for the header file.
#
#============================================
sub createWriteFunction {
    my $name = shift;
    my $type = shift;

    $writeFuncs .= eval("\"$variableTypes{'code-write-func'}{'code'}\"") . 
	"\n\n";
    $functionInfo .= "int write_$name(int, u_char *,u_char, int, u_char *,oid*, int);\n";
}

sub read_config() {
    my $configfile = shift;
    my ($type, $lasttoken);
    my $fh = new FileHandle;
    if ( $fh->open("<$configfile") ) {
	while(<$fh>) {
	    next if /^\s*#/;
	    if (/type:\s*(.*)/) {
		if (defined($type) && defined($lasttoken) && 
		    defined ($variableTypes{$type}{$lasttoken})) {
		    chomp($variableTypes{$type}{$lasttoken});
		}
		$type = $1;
		chomp($type);
	    } elsif (/include:\s*(.*)/) {
		read_config($1);
	    } elsif (/copy:\s*(.*)/) {
		my $item;
		chomp($1);
		foreach $item (keys(%{$variableTypes{$1}})) {
		    $variableTypes{$type}{$item} = $variableTypes{$1}{$item};
		}
	    } else {
		if (/\s*([^:]*):(\s*.*)/) {
		    if (!defined($variableTypes{$type}{$1})) {
			if (defined($type) && defined($lasttoken) && 
			    defined ($variableTypes{$type}{$lasttoken})) {
			    chomp($variableTypes{$type}{$lasttoken});
			}
			$variableTypes{$type}{$1} = $2;
			$lasttoken = $1;
			$variableTypes{$type}{$1} =~ s/^\t+//;
		    } else {
			# duplicate entry:  tack it on.
			my ($x, $y) = ($1, $2);
			$y =~ s/^\t+//;
			$variableTypes{$type}{$x} .= "\n" . $y;
		    }
		} else {
		    # continuation line, it started with spaces or a +
		    s/^\s*//;
		    s/^\+//; 
		    $variableTypes{$type}{$lasttoken} .= "\n" . $_;
		    chomp($variableTypes{$type}{$lasttoken});
		}
	    }
	}
	$fh->close();
    } else {
	warn "Config file ($configfile) not found.\n";
    }
}

