#!/usr/bin/perl

use strict;
use 5.8.0;

use File::Basename;
use File::Path;
use Sys::Hostname;
use Cwd qw(getcwd realpath);

package NetSNMP::Cert;

our $VERSION      = '0.2.0b';

our $PROG         = ::basename($0);
our $DEBUG        = 0;
our $ERR          = -1;

# required executables
our $OPENSSL     = $ENV{NET_SNMP_CRT_OPENSSL}  || 'openssl';
our $CFGTOOL     = $ENV{NET_SNMP_CRT_CFGTOOL}  || 'net-snmp-config';

# default config files
our $CFGFILE     = $ENV{NET_SNMP_CRT_CFGFILE}  || 'net-snmp-cert.conf';
our $SSLCFG      = $ENV{NET_SNMP_CRT_SSLCFG}   || 'openssl.conf';

# default cmd logs
our $OUTLOG      = $ENV{NET_SNMP_CRT_OUTLOG}   || '.cmd.out.log';
our $ERRLOG      = $ENV{NET_SNMP_CRT_ERRLOG}   || '.cmd.err.log';

# default cert dirs
our $TLSDIR      = $ENV{NET_SNMP_CRT_TLSDIR}   || 'tls';
our $CRTDIR      = $ENV{NET_SNMP_CRT_CRTDIR}   || 'certs';
our $NEWCRTDIR   = $ENV{NET_SNMP_CRT_NEWCRTDIR}|| 'newcerts';
our $CADIR       = $ENV{NET_SNMP_CRT_CADIR}    || 'ca-certs';
our $PRIVDIR     = $ENV{NET_SNMP_CRT_PRIVDIR}  || 'private';

our $SERIAL      = $ENV{NET_SNMP_CRT_SERIAL}   || '.serial';
our $INDEX       = $ENV{NET_SNMP_CRT_INDEX}    || '.index';

our $DEFCADAYS   = $ENV{NET_SNMP_CRT_DEFCADAYS} || 1825;
our $DEFCRTDAYS  = $ENV{NET_SNMP_CRT_DEFCRTDAYS}|| 365;

our @TLSDIRS     = ($CRTDIR, $NEWCRTDIR, $CADIR, $PRIVDIR);

our @CRTSUFFIXES = qw(.pem .csr .der .crt);

our @X509FMTS = qw(text modulus serial subject_hash issuer_hash hash subject
		    purpose issuer startdate enddate dates fingerprint C);

sub dprint {
  my $str = shift;
  my $opts = shift;
  my $dlevel = shift || 1;
  my $flag = (defined $opts ? int($opts->{debug} >= $dlevel) : 1);
  my ($pkg, $file, $line, $sub) = caller(1);
  my ($pkg0, $file0, $line0) = caller(0);
  print("${sub}():$line0: $str") if $flag;
}

sub dwarn {
  my $str = shift;
  my $opts = shift;
  my $dlevel = shift || 1;
  my $flag = (defined $opts ? $opts->{debug} >= $dlevel : 1);
  my ($pkg, $file, $line, $sub) = caller(1);
  my ($pkg0, $file0, $line0) = caller(0);
  warn("${sub}():$line0: $str") if $flag;
}

sub vprint {
  my $str = shift;
  my $opts = shift;
  my $flag = (defined $opts ? $opts->{verbose} : 1);
  my $debug = (defined $opts ? $opts->{debug} : 1);
  my ($pkg, $file, $line, $sub) = caller(1);
  my ($pkg0, $file0, $line0) = caller(0);
  $str = ($debug ? "${sub}():$line0: $str" : "$str");
  print("$str") if $flag;
}

sub vwarn {
  my $str = shift;
  my $opts = shift;
  my $flag = (defined $opts ? $opts->{verbose} : 1);
  my ($pkg, $file, $line, $sub) = caller(1);
  my ($pkg0, $file0, $line0) = caller(0);
  warn("${sub}():$line0: $str") if $flag;
}

sub rsystem {
  my $cmd = shift;
  my $flag = shift;

  # if not running as root try to use sudo
  if ($>) {
    $cmd = "sudo $flag $cmd";
  } else {
    if ($flag =~ /-b/) {
      $cmd = "$cmd \&";
    }
  }
  die("cmd failed($!): $cmd\n") if system("$cmd");
}

sub usystem {
  my $cmd = shift;

  die("cmd failed($!): $cmd\n") if system("$cmd");
}

sub home_dir {
  my $cdir = ::getcwd();

  chdir("~");
  my $dir = ::getcwd();
  chdir($cdir);

  return $dir;
}

sub find_bin_dir {
  # This code finds the path to the currently invoked program and
  my $dir;

  $0 =~ m%^(([^/]*)(.*)/)([^/]+)$%;
  if ($1) {
    if ($2) {
      # Invoked using a relative path.  CD there and use pwd.
      $dir = `cd $1 && pwd`;
      chomp $dir;
    } else {
      # Invoked using an absolute path; that's it!
      $dir = $3;
    }
  } else {
    # No path.  Look in PATH for the first instance.
    foreach my $p (split /:/, $ENV{PATH}) {
      $p ||= '.';
      -x "$p/$4" or next;
      $dir = $p;
    }
  }
  $dir or die "Cannot locate program '$0'!";
}

sub fq_rel_path {
  my $path = shift;
  my $cwd = ::getcwd();
  my $rdir = shift || $cwd;

  chdir($rdir) or die("can't change directory: $rdir");
  # get fully qualified path
  if ($path !~ m|^/|) {
    my $pwd = `pwd`; chomp $pwd;
    $path = "$pwd/$path";
    $path = ::realpath($path) if -e $path;
  }
  chdir($cwd) or die("can't change directory: $cwd");

  return $path;
}

sub dir_empty
  {
    my $path = shift;
    opendir(DIR, $path);
    foreach (readdir(DIR)) {
      next if /^\.\.?$/;
      closedir(DIR);
      return 0;
    }
    closedir(DIR);
    return 1;
  }

sub make_dirs {
  my $opts = shift;
  my $dir = shift;
  my $mode = shift;
  my @dirs = @_;

  my $wd = ::getcwd();

  NetSNMP::Cert::dprint("make dirs [$dir:@dirs] from $wd\n", $opts);

  ::mkpath($dir, $opts->{verbose}, $mode) or die("error - can't make $dir")
    if defined $dir and not -d $dir;

  foreach my $subdir (@dirs) {
    my $d = "$subdir";
    $d = "$dir/$d" if defined $dir;
    NetSNMP::Cert::dprint("making directory: $d\n", $opts) unless -d $d;
    mkdir($d, $mode) or die("error - can't make $d") unless -d $d;
  }
}

sub in_set {
  my $elem = shift;
  my $set = shift;
  for my $e (eval($set)) {
    return 1 if $e == $elem;
  }
  return 0;
}

sub in_arr {
  my $elem = shift;
  my $arr = shift;
  for my $e (@{$arr}) {
    return 1 if $e eq $elem;
  }
  return 0;
}

sub version {
  my $ret = (@_ ? shift : 1);
  print "$NetSNMP::Cert::PROG: $NetSNMP::Cert::VERSION\n";
  exit($ret);
}

sub usage {
  my $ret = (@_ ? shift : 1);
  my $arg = shift;

  print "Command not implmeneted yet: $arg\n" if $ret == 2;
  print "\n   NAME:\n";
  print "     $NetSNMP::Cert::PROG: [$NetSNMP::Cert::VERSION] - ";
  print "Net-SNMP Certificate Management Tool\n";
  print "\n   DESCRIPTION:\n";
  print "     net-snmp-cert creates, signs, installs and displays X.509\n";
  print "     certificates used in the operation of Net-SNMP/(D)TLS.\n";
  print "\n   SYNOPSIS:\n";
  print "     net-snmp-cert [--help|-?]\n";
  print "     net-snmp-cert [--version|-V]\n";
  print "     net-snmp-cert genca    [<flags>] [<dn-opts>] [--ca <ca>]\n";
  print "     net-snmp-cert gencert  [<flags>] [<dn-opts>] [--ca <ca>]\n";
  print "     net-snmp-cert gencsr   [<flags>] [<dn-opts>] [--crt <crt>]\n";
  print "     net-snmp-cert signcsr  [<flags>] [--install] --csr <csr> --ca <ca>\n";
  print "     net-snmp-cert showca   [<flags>] [<format-opts>] [<file>|<search-tag>]\n";
  print "     net-snmp-cert showcert [<flags>] [<format-opts>] [<file>|<search-tag>]\n";
  print "     net-snmp-cert import   <file>\n";
  print "\n   COMMANDS:\n";
  print "     genca    -- generate a signed CA certificate suitable for signing other\n";
  print "                 certificates. default: self-signed unless --ca <ca> supplied\n\n";
  print "     gencert  -- generate a signed certificate suitable for identification, or\n";
  print "                 validation. default: self-signed unless --ca <ca> supplied\n\n";
  print "     gencsr   -- generate a certificate signing request. will create a new\n";
  print "                 key and certificate unless --crt <crt> supplied\n\n";
  print "     signcsr  -- sign a certificate signing request specified by --csr <csr>\n";
  print "                 with the CA certificate specified by --ca <ca>\n";
  print "     import   -- import an identity or CA certificate\n";
  print "     showca,\n";
  print "     showcert -- show CA or identity certificate(s). may pass fully qualified\n";
  print "                 file or directory name, or a search-tag which prefix matches\n";
  print "                 installed CA or identity certificate file name(s)\n";
  print "                 see FORMAT OPTIONS to specify output format\n\n";
  print "\n   FLAGS:\n";
  print "     -?, --help            -- show this text and exit\n";
  print "     -V, --version         -- show version string and exit\n";
  print "     -D, --debug           -- raise debug level (-D -D for higher level)\n";
  print "     -F, --force           -- force overwrite of existing output files\n";
  print "     -I, --nointeractive   -- non-interactive run (default interactive)\n";
  print "     -Q, --noverbose       -- non-verbose output (default verbose)\n";
  print "     -C, --cfgdir   <dir>  -- configuration dir (see man(5) snmp_config)\n";
  print "     -T, --tlsdir   <dir>  -- root for cert storage (default <cfgdir>/tls)\n";
  print "     -f, --cfgfile  <file> -- config (default <cfgdir>/net-snmp-cert.conf)\n";
  print "     -i, --identity <id>   -- identity to use from config\n";
  print "     -t, --tag      <tag>  -- application tag (default 'snmp')\n";
  print "     --<cfg-param>[=<val>] -- additional config params\n";  
  print "\n   CERTIFICATE OPTIONS (<cert-opts>):\n";
  print "     -a, --ca <ca>         -- CA certificate used to sign request\n";
  print "     -r, --csr <csr>       -- certificate signing request\n";
  print "     -x, --crt <crt>       -- certificate\n";
  print "     -y, --install         -- install result in local repository\n";
  print "     -z, --self-sign       -- self-sign (default)\n";
  print "\n   DISTINGUISHED NAME OPTIONS (<dn-opts>):\n";
  print "     -e, --email <email>       -- email name\n";
  print "     -h, --host <host>         -- DNS host name, or IP address\n";
  print "     -d, --days <days>         -- number of days certificate is valid\n";
  print "     -n, --cn <cn>             -- common name (CN)\n";
  print "     -o, --org <org>           -- organiztion name\n";
  print "     -u, --unit <unit>         -- organiztion unit name\n";
  print "     -c, --country <country>   -- country code (e.g., US)\n";
  print "     -p, --province <province> -- province name (synomynous w/ state)\n";
  print "     -p, --state <state>       -- state name (synomynous w/ province)\n";
  print "     -l, --locality <locality> -- locality name (e.g, town)\n";
  print "     -s, --san <san>           -- subjectAltName, repeat for each <san>\n";
  print "                               -- <san> value format (<FMT>:<VAL>):\n";
  print "                               --   DNS:net-snmp.org\n";
  print "                               --   IP:192.168.1.1\n";
  print "                               --   EMAIL:admin\@net-snmp.org\n";
  print "                               --   URI:http://net-snmp.org\n";
  print "\n   FORMAT OPTIONS (<format-opts>): \n";
  print "     --text         -- full text description\n";
  print "     --subject      -- subject description\n";
  print "     --subject_hash -- hash of subject for indexing\n";
  print "     --issuer       -- issuer description\n";
  print "     --issuer_hash  -- hash of issuer for indexing\n";
  print "     --fingerprint  -- SHA1 digest of DER\n";
  print "     --serial       -- serial number\n";
  print "     --modulus      -- modulus of the public key\n";
  print "     --dates        -- start and end dates\n";
  print "     --purpose      -- displays allowed uses\n";
  print "     --C            -- C code description\n";
  print "\n   EXAMPLES: \n";
  print "     net-snmp-cert genca --cn ca-net-snmp.org --days 1000\n";
  print "     net-snmp-cert gencert -t snmpd --cn host.net-snmp.org\n";
  print "     net-snmp-cert gencsr -t snmpapp\n";
  print "     net-snmp-cert signcsr --ca ca-net-snmp.org --csr snmpapp\n";
  print "     net-snmp-cert showcerts --subject --issuer --dates snmpapp\n";
  print "     net-snmp-cert showcas --fingerprint --dates ca-net-snmp.org\n";
  print "     net-snmp-cert genca -f .snmp/net-snmp-cert.conf -i nocadm -I\n\n";

  exit $ret;
}

sub cfg_path {
  my $path;

  $path = `$NetSNMP::Cert::CFGTOOL --snmpconfpath`;
  chomp $path;
  return (wantarray ? split(':', $path) : $path);
}

sub find_cfgfile {
  my $dir = shift;
  my $file = shift;

  if (defined $dir and -d $dir and 
      defined $file and $file !~ /^[\.\/]/) {
    return fq_rel_path("$dir/$file") if -f "$dir/$file";
  }

  if (defined $file) {
    if (-f $file) {
      return fq_rel_path($file);
    } else {
      return $file; # file is not found, complain later
    }
  }
  
  my @path = cfg_path();
  unshift(@path, $dir) if defined $dir;
  while (@path) {
    my $p = pop(@path);
    next if $p eq '/var/lib/snmp';
    if (-r "$p/$NetSNMP::Cert::CFGFILE") {
      return fq_rel_path("$p/$NetSNMP::Cert::CFGFILE");
    }
  }

  return $file;
}

sub find_cfgdir {
  my $dir = shift;
  my $file = shift;

  if (defined $dir) {
    $dir = NetSNMP::Cert::fq_rel_path($dir);
    return $dir;
  }

  if (defined $file and -f $file) {
    $dir = ::dirname($file);
    return NetSNMP::Cert::fq_rel_path($dir);
  } else {
    my @path = cfg_path();
    # search first for writeable tls dir
    # for root search top down, for user bottom up
    while (@path) {
      $dir = ($> ? pop(@path): shift(@path));
      next if $dir eq '/var/lib/snmp';
      return $dir if -d "$dir/$NetSNMP::Cert::TLSDIR" and 
	             -w "$dir/$NetSNMP::Cert::TLSDIR";
    }
    @path = cfg_path();
    # if no tls dir found, pick first writable config dir
    # for root search top down, for user bottom up
    while (@path) {
      $dir = ($> ? pop(@path): shift(@path));
      next if $dir eq '/var/lib/snmp';
      return $dir if -d $dir and -w $dir;
    }
  }
  # this should never happen
  return undef;
}

sub find_certs {
  my $opts = shift;
  my $dir = shift || 'certs';
  my $targ = shift;
  my $suffix_regex;
  my $cwd = ::getcwd();

  if ($dir eq 'csrs') {
    $dir = $NetSNMP::Cert::NEWCRTDIR;
    $suffix_regex = '\.csr|\.pem';
  } else {
    $suffix_regex = '\.crt|\.pem';
  }

  NetSNMP::Cert::dprint("find_certs(1:$cwd):$dir:$targ:$suffix_regex\n", $opts);

  if ($targ =~ /\.?\//) {
    # see if targ could be file - calc orig. rel. path
    my $arg = NetSNMP::Cert::fq_rel_path($targ, $opts->{rdir});
    $cwd = ::getcwd();
    NetSNMP::Cert::dprint("find_certs(2:$cwd):$dir:$arg\n", $opts);
    # targ is a file name - use it
    return (wantarray ? ($arg) : $arg) if -f $arg;
    # else mark as dir if it is
    $targ = "$arg" if -d $arg;
  }
  
  $targ =~ s/\/*$/\// if -d $targ;
  NetSNMP::Cert::dprint("find_certs(3):$dir:$targ\n", $opts);
  
  # find certs in targ if a dir (in tlsdir, or relative)
  $dir = $1 if $targ =~ s/^(\S+)\/([^\/\s]*)$/$2/ and -d $1;

  my $d = join(":", <$dir/$targ*>);
  NetSNMP::Cert::dprint("find_certs(4):${dir}:$targ:$cwd:$d\n", $opts);

  my @certs;
  foreach (<$dir/$targ*>) {
    NetSNMP::Cert::dprint("checkin($dir:$targ): $_\n", $opts);
    next unless /^$dir\/$targ(.*$suffix_regex)?$/;
    # return exact match if not wantarray()
    return $_ if (not wantarray()) and /^$dir\/$targ($suffix_regex)?$/;
    NetSNMP::Cert::dprint("pushing: $_\n", $opts);
    push(@certs, $_);
  }

  return (wantarray ? @certs : $certs[0]);
}

sub check_output_file {
  my $opts = shift;
  my $file = shift;
  my $interactive = shift;
  my $continue = 1;

  if (-w $file) {
    if ($interactive) {
      print "Output file ($file) exists; will be overwritten\nContinue [y/N]:";
      $continue = <STDIN>; chomp $continue;
      $continue = 0 if $continue =~ /^\s*$|^no?\s*$/i;
    } else {
      if ($opts->{force}) {
	NetSNMP::Cert::vprint("Output file ($file) exists; overwriting...\n", $opts);
      } else {
	NetSNMP::Cert::vprint("Output file ($file) exists; exiting...\n", $opts);
	$continue = 0;
      }
    }
  } elsif (-e $file) {
    NetSNMP::Cert::vprint("Output file ($file) not writable; exiting...\n", $opts);
    $continue = 0;
  }
  exit(1) unless $continue;
}

sub is_server {
  my $tag = shift;
  return 1 if $tag eq 'snmpd' or $tag eq 'snmptrapd';
  return 0;
}

sub x509_format {
  my $opts = shift;
  my $fmt;

  foreach my $f (@NetSNMP::Cert::X509FMTS) {
    $fmt .= " -$f" if defined $opts->{$f};
  }

  return $fmt;
}

sub make_openssl_conf {
  my $file = shift;
  return if -r $file;

  open(F, ">$file") or die("could not open $file");

  print F <<'END';
#
# Net-SNMP (D)TLS OpenSSL configuration file.
#

# This definition stops the following lines choking if HOME isn't
# defined.
HOME		= .
dir		= .
RANDFILE	= $dir/.rand
MD		= sha1
KSIZE		= 2048
CN		= net-snmp.org
EMAIL		= admin@net-snmp.org
COUNTRY	 = US
STATE		= California
LOCALITY	= Davis
ORG		= Net-SNMP Developers
ORG_UNIT	= SNMP-TLS
SAN             = email:copy
DAYS            = 365
CRLDAYS         = 30

default_days	= $ENV::DAYS		# how long to certify for
default_crl_days= $ENV::CRLDAYS		# how long before next CRL
default_md	= $ENV::MD		# which md to use.

database	= $dir/.index		# database index file.
serial		= $dir/.serial 		# The current serial number
certs		= $dir/certs		# identity certs
new_certs_dir	= $dir/newcerts		# default place for new certs.
ca_certs_dir	= $dir/ca-certs		# default place for new certs.
key_dir		= $dir/private

crl_dir		= $dir/crl		# crl's
crlnumber	= $dir/.crlnumber	# the current crl number
					# must be commented out to leave V1 CRL
crl		= $crl_dir/crl.pem	# The current CRL

preserve	= no			# keep passed DN ordering
unique_subject	= yes			# Set to 'no' to allow creation of
					# certificates with same subject.
# Extra OBJECT IDENTIFIER info:
oid_section		= new_oids

[ new_oids ]

# Add new OIDs in here for use by 'ca' and 'req'.
# Add a simple OID like this:
# testoid1=1.2.3.4
# Use config file substitution like this:
# testoid2=${testoid1}.5.6

####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]
# certificate	= $ca_certs_dir/$ENV::TAG.crt 	# CA certificate so sign with
name_opt 	= ca_default		# Subject Name options
cert_opt 	= ca_default		# Certificate field options
policy		= policy_match
copy_extensions = copy                  # copy v3 extensions (subjectAltName)
subjectAltName  = copy

# For the CA policy
[ policy_match ]
countryName		= match
stateOrProvinceName	= match
organizationName	= match
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional

# For the 'anything' policy
# At this point in time, you must list all acceptable 'object'
# types.
[ policy_anything ]
countryName		= optional
stateOrProvinceName	= optional
localityName		= optional
organizationName	= optional
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional

####################################################################
[ req ]
default_bits		= $ENV::KSIZE
default_md		= $ENV::MD
distinguished_name	= req_distinguished_name
string_mask 		= MASK:0x2002
req_extensions          = v3_req

[ req_distinguished_name ]
countryName			= Country Name (2 letter code)
countryName_default		= $ENV::COUNTRY
countryName_min			= 2
countryName_max			= 2

stateOrProvinceName		= State or Province Name (full name)
stateOrProvinceName_default	= $ENV::STATE

localityName			= Locality Name (eg, city)
localityName_default		= $ENV::LOCALITY

0.organizationName		= Organization Name (eg, company)
0.organizationName_default	= $ENV::ORG

organizationalUnitName		= Organizational Unit Name (eg, section)
organizationalUnitName_default	= $ENV::ORG_UNIT

commonName			= Common Name (eg, your name or your server\'s hostname)
commonName_max			= 64
commonName_default              = $ENV::CN

emailAddress			= Email Address
emailAddress_max		= 64
emailAddress_default            = $ENV::EMAIL

[ v3_req ]

# Extensions to add to a certificate request
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment

# Import the email address and/or specified SANs.
subjectAltName = $ENV::SAN

[ v3_ca_create ]
# Extensions to add to a CA certificate
basicConstraints = CA:TRUE
# This will be displayed in Netscape's comment listbox.
nsComment = "OpenSSL Generated Certificate (net-snmp)"

# PKIX recommendation.
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always

# Import the email address and/or specified SANs.
subjectAltName = $ENV::SAN

[ v3_ca_sign ]
# Extensions to add when 'ca' signs a request.
basicConstraints = CA:FALSE
# This will be displayed in Netscape's comment listbox.
nsComment = "OpenSSL Generated Certificate (net-snmp)"

# PKIX recommendations harmless if included in all certificates.
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always

[ v3_ca_sign_ca ]
# Extensions to add when 'ca' signs a ca request.
basicConstraints = CA:TRUE

# This will be displayed in Netscape's comment listbox.
nsComment = "OpenSSL Generated Certificate (net-snmp)"

# PKIX recommendations harmless if included in all certificates.
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always

END
 
}

package NetSNMP::Cert::Obj;

sub new {
  my $class = shift;
  my $cfield = shift;
  my $parent = shift;
  my $ind = shift;
  my $this = {};
  bless($this, $class);

  # initialize hash of keys which are dynamically created or internal
  $this->{AUTOKEYS}{AUTOKEYS}++;

  # store a reference to ourselves so our children can find us
  $this->autoSet('CFIELD', $cfield);
  $this->autoSet($cfield , $this);
  $this->autoSet('CHILDREN', []);
  $this->autoSet('INDEX', $ind) if defined $ind;

  if (defined $parent) {
    # cache 'app' in all objs for easy reference
    $this->autoSet('app', $parent->inherit('app'));
    my $app = $this->{app};

    die("net-snmp-cert: error: no NetSNMP::Cert::App context provided")
      if not defined $app or not ref $app eq 'NetSNMP::Cert::App';
    # save children for list traversal
    push(@{$parent->{CHILDREN}}, $this) unless $parent eq $this;
  } else {
    # we are the top of the list
    $parent = $this;
  }
  $this->autoSet('PARENT' , $parent);

  return $this;
}

sub autoSet {
  my $this = shift;
  my $key = shift;
  if (@_) {
    my $val = shift;
    $this->{AUTOKEYS}{$key}++;
    $this->{$key} = $val;
  }
  return exists $this->{AUTOKEYS}{$key};
}

sub inherit {
  my $this = shift;
  my $field = shift;

  # cmd opts override config settings
  if (exists $this->{app} and exists $this->{app}->{OPTS}) {
    my $opts = $this->{app}->{OPTS};
    return $opts->{$field} if defined $opts->{$field};
  }

  # return our field if we have it
  return $this->{$field} if defined $this->{$field};

  # terminate recursion at top and return undef if not found
  return undef if not defined $this->{PARENT} or $this->{PARENT} eq $this;

  # recurse to parent
  $this->{PARENT}->inherit($field);
}

sub resolve {
  my $this = shift;
  my $opts = $this->inherit('OPTS');
  my $val = shift;

  NetSNMP::Cert::dprint("resolving: $val\n", $opts);

  $val =~ s/(\$(\w+))/$this->inherit($2) or die("unresolved reference in config: $1")/ge;
  $val =~ s/(\&\{(.*?)\})/$2/gee;

  NetSNMP::Cert::dprint("resolved: $val\n", $opts);

  return $val
}

sub delete {
  my $this = shift;
  my $opts = $this->inherit('OPTS');

  NetSNMP::Cert::dprint("Obj::delete: ($this) [$this->{CFIELD}]\n", $opts);

  my $parent = $this->{PARENT};
  my @children = @{$this->{CHILDREN}};

  foreach my $child (@children) {
    $child->delete();
  }

  NetSNMP::Cert::dwarn("Obj: children not freed\n", $opts) if @{$this->{CHILDREN}};

  # delete all our self-references
  delete($this->{$this->{CFIELD}}) if exists $this->{CFIELD};
  delete($this->{PARENT});
  delete($this->{CHILDREN});

  $parent->disown($this) if defined $parent and ref($parent) =~ /NetSNMP::Cert/;
}

sub disown {
  my $this = shift;
  my $thechild = shift;
  my $opts = $this->inherit('OPTS');
  my $ind = 0;

  NetSNMP::Cert::dprint("Obj::disown: ($this) [$this->{CFIELD}] disowning ($thechild) [$thechild->{CFIELD}]\n", $opts);

  foreach my $child (@{$this->{CHILDREN}}) {
    last if $child eq $thechild;
    $ind++;
  }
  if ($ind < @{$this->{CHILDREN}}) {
    splice(@{$this->{CHILDREN}}, $ind, 1);
  } else {
    NetSNMP::Cert::dwarn("Child ($thechild) not found in object ($this)\n", $opts);
  }
}

sub disabled {
  my $this = shift;
  return (exists $this->{disable} ? $this->{disable} : 0);
}

my %cfg = (
	   'name' => 1,
	   'type' => 2,
	   'id' => 6,
	  );

sub cfgsort {
  my $self = shift;
  my $a = shift;
  my $b = shift;
  return -1 if exists $cfg{$a} and not exists $cfg{$b};
  return 1 if exists $cfg{$b} and not exists $cfg{$a};
  return $cfg{$a} <=> $cfg{$b} if exists $cfg{$a} and exists $cfg{$b};
  return -1 if !ref($self->{$a}) and ref($self->{$b});
  return 1 if !ref($self->{$b}) and ref($self->{$a});
  return -1 if ref($self->{$a}) =~ /NetSNMP::Cert/ and ref($self->{$b}) !~ /NetSNMP::Cert/;
  return 1 if ref($self->{$b}) =~ /NetSNMP::Cert/ and ref($self->{$a}) !~ /NetSNMP::Cert/;
  return 0;
}

sub dump {
  my $self = shift;
  my $indent = shift;
  my $self_str = $self->{CFIELD};
  my @data_keys =  grep {!$self->autoSet($_)} keys %$self;
  my @lines;

  push(@lines, "\n" . ' ' x $indent . "$self_str = {\n") if defined $indent;

  {
    my $indent = (defined $indent ? $indent + 3 : 0);
    foreach my $key (sort {cfgsort($self, $NetSNMP::Cert::Obj::a,$NetSNMP::Cert::Obj::b)}
		     (sort @data_keys)) {
      if (ref($self->{$key}) =~ /NetSNMP::Cert/) {
	push(@lines, $self->{$key}->dump($indent));
      } elsif (ref($self->{$key}) =~ /ARRAY/) {
	push(@lines, "\n") if ref(${$self->{$key}}[0]) !~ /NetSNMP::Cert/;
	foreach my $elem (@{$self->{$key}}) {
	  if (ref($elem) =~ /NetSNMP::Cert/) {
	    push(@lines, $elem->dump($indent));
	  } else {
	    push(@lines, ' ' x $indent . "$key = $elem\n");
	  }
	}
      } else {
	my $str = $key . (defined $self->{$key} ? " = $self->{$key}\n" : "\n");
	push(@lines, ' ' x $indent . $str);
      }
    }
  }

  push(@lines, ' ' x $indent . "}; # end $self_str\n") if defined $indent;
  return @lines;
}

sub DESTROY {
  my $this = shift;

  print("Obj::DESTROY  $this [", ref $this, "]\n") if $NetSNMP::Cert::DEBUG >= 3;
}

package NetSNMP::Cert::App;
use vars qw(@ISA);
use Getopt::Long qw(GetOptionsFromArray :config gnu_getopt no_ignore_case pass_through);

@ISA = qw(NetSNMP::Cert::Obj);

sub new {
  my $class = shift;
  my @args = @_;   # ARGV can be supplied now, or call parseArgs later

  # the app is god, it is its own parent
  my $this = $class->SUPER::new('app');

  bless($this, $class);

  $this->initOpts();

  # parse command line
  $this->parseArgs(@args);

  # make a new empty config and init, but parsing is postponed
  $this->{config} = new NetSNMP::Cert::Config($this);

  return $this;
}

sub checkReqs {
  my $app = shift;

  die("$NetSNMP::Cert::OPENSSL does not exist or is not executable")
    if system("$NetSNMP::Cert::OPENSSL version > /dev/null 2>&1");

  my $ossl_ver = `$NetSNMP::Cert::OPENSSL version`; chomp $ossl_ver;
  $ossl_ver =~ s/^OpenSSL\s+([\d\.]+).*$/$1/;
  my $ossl_min_ver = $NetSNMP::Cert::OPENSSL_MIN_VER;

  die("$NetSNMP::Cert::OPENSSL (v$ossl_ver): must be $ossl_min_ver or later")
    if ($ossl_ver cmp $ossl_min_ver) < 0;

  die("$NetSNMP::Cert::CFGTOOL not found: please install")
    if system("$NetSNMP::Cert::CFGTOOL > /dev/null 2>&1");
}

sub initOpts {
  my $app = shift;
  my $opts = {};
  $app->autoSet('OPTS', $opts);

  # Define directories we need.
  $opts->{bindir} = NetSNMP::Cert::find_bin_dir();

  $opts->{out} = "> $NetSNMP::Cert::OUTLOG";
  $opts->{err} = "2> $NetSNMP::Cert::ERRLOG";
  $opts->{interactive} = 0; # disabled for now, will be default
  $opts->{verbose} = 1;

  # set up paths for app install and runtime env
  $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
  $ENV{PATH} = "$opts->{bindir}:$ENV{PATH}";

  # default all privs to -rw-------
  umask(077);
}

sub parseArgs {
  my $app = shift;
  my $opts = $app->{OPTS};
  my @args = @_;

  $opts->{cmd} = shift(@args) if $args[0] !~ /^\s*-/;

  GetOptionsFromArray(\@args, $opts, 'help|?', 'version|V', 'debug|D+',
		      'interactive!', 'I', 'verbose!', 'Q', 'force|F',
		      'cfgfile|f=s', 'cfgdir|C=s', 'tlsdir|tlsDir|T=s', 
		      'tag|t=s', 'identity|i=s');

  # save extra args for command specific processing
  $opts->{cmdargs} = [@args]; 

  NetSNMP::Cert::usage(0) if $opts->{help};
  NetSNMP::Cert::version(0) if $opts->{version};
  NetSNMP::Cert::usage(1) unless $opts->{cmd};
  NetSNMP::Cert::usage(2, '--identity') if $opts->{identity};
  NetSNMP::Cert::usage(2, '--interactive') if $opts->{interactive};

  # Check debug option first
  $NetSNMP::Cert::DEBUG = $opts->{debug};
  $opts->{err} = $opts->{out} = "" if $opts->{debug};
  $opts->{interactive} = not $opts->{I} if defined $opts->{I};
  $opts->{verbose} = not $opts->{Q} if defined $opts->{Q};

  # search for cfgdir and cfgfile based on opts and confpath
  $opts->{cfgdir} = NetSNMP::Cert::find_cfgdir($opts->{cfgdir},$opts->{cfgfile});
  $opts->{cfgfile} = NetSNMP::Cert::find_cfgfile($opts->{cfgdir},$opts->{cfgfile});
}

sub handleTlsDir {
  my $app = shift;
  my $opts = $app->{OPTS};
  my $config = $app->{config};
  my $dir = $opts->{tlsdir};
  my $file;
  my $cmd;

  $dir ||= $config->inherit('tlsDir');
  
  if (not defined $dir) {
    my $cfgdir = $opts->{cfgdir};
    die("undefined cfgdir: unable to creat tlsdir: exiting...\n") unless defined $cfgdir;
    $dir = "$cfgdir/$NetSNMP::Cert::TLSDIR";
  }

  NetSNMP::Cert::dprint("tlsDir is: $dir\n", $opts);
  $dir = NetSNMP::Cert::fq_rel_path($dir);
  NetSNMP::Cert::dprint("tlsDir is: $dir\n", $opts);

  NetSNMP::Cert::dprint("tlsDir not found, creating\n", $opts) unless -d $dir;
  NetSNMP::Cert::make_dirs($opts, $dir, 0700, @NetSNMP::Cert::TLSDIRS);

  $file = "$dir/$NetSNMP::Cert::SERIAL";
  if (not -f $file) {
    $cmd = "echo '01' > $file";
    NetSNMP::Cert::dprint("$cmd\n", $opts);
    NetSNMP::Cert::usystem($cmd); 
    chmod(0600, $file);
  }

  $file = "$dir/$NetSNMP::Cert::INDEX";
  if (not -f $file) {
    $cmd = "touch $file";
    NetSNMP::Cert::dprint("$cmd\n", $opts);
    NetSNMP::Cert::usystem($cmd);
    chmod(0600, $file);
  }

  $file = "$dir/$NetSNMP::Cert::SSLCFG";
  if (not -f $file) {
    NetSNMP::Cert::dprint("make_openssl_conf($file)", $opts);
    NetSNMP::Cert::make_openssl_conf($file);
    chmod(0600, $file);
  }

  NetSNMP::Cert::dprint("handleTlsDir: done\n", $opts);
  return $dir;
}

sub opensslEnv {
  my $app = shift;
  my $config = $app->{config};
  my $opts = $app->{OPTS};

  my $cn = shift;
  my $days = shift;

  # XXX - need to handle config'd identity here
  my $name = $config->inherit("name");
  my $host = $config->inherit("host");
  my $email = $config->inherit("email");
  my $country = $config->inherit("country");
  my $state = $config->inherit("state");
  my $locality = $config->inherit("locality");
  my $org = $config->inherit("org");
  my $org_unit = $config->inherit("unit") || $config->inherit("orgUnit");
  my $san;
  my $md = $config->inherit("msgDigest");
  my $ksize = $config->inherit("keySize");

  $san = join('\,\ ',@{$config->inherit("subjectAltName")}) if ref $config->inherit("subjectAltName");
  $san = join('\,\ ',@{$config->inherit("san")}) if ref $config->inherit("san");
  $san =~ s/EMAIL:/email:/g;
  my $env;

  $env .= " CN=$cn" if defined $cn;
  $env .= " KSIZE=$ksize" if defined $ksize;
  $env .= " MD=$md" if defined $md;
  $env .= " COUNTRY=$country" if defined $country;
  $env .= " STATE=$state" if defined $state;
  $env .= " LOCALITY=$locality" if defined $locality;
  $env .= " ORG=$org" if defined $org;
  $env .= " ORG_UNIT=$org_unit" if defined $org_unit;
  $env .= " EMAIL=$email" if defined $email;
  $env .= " SAN=$san" if defined $san;
  $env .= " DAYS=$days" if defined $days;

  NetSNMP::Cert::dprint("opensslEnv: $env\n", $opts);

  return $env;
}

sub genCa {
  my $app = shift;
  my $config = $app->{config};
  my $opts = $app->{OPTS};
  my $host = $config->inherit('host') || ::hostname();
  my $days = $config->inherit('caDays') || $config->inherit('days') || $NetSNMP::Cert::DEFCADAYS;
  my $cn = $config->inherit('cn') || $config->inherit('commonName') || "ca-$host";
  my $ca = $config->inherit('ca');

  my $env = $app->opensslEnv($cn, $days);

  my $outCrt = "$NetSNMP::Cert::CADIR/$cn.crt";
  my $outKey = "$NetSNMP::Cert::PRIVDIR/$cn.key";
  
  NetSNMP::Cert::check_output_file($opts, $outCrt, $config->inherit('interactive'));
  NetSNMP::Cert::check_output_file($opts, $outKey, $config->inherit('interactive'));

  my $cmd = "$env openssl req -new -nodes -days $days -batch -keyout $outKey -out $outCrt -config $NetSNMP::Cert::SSLCFG";

  if (defined $ca) {
    # we have to gen a csr and then sign it, must preserve CA:TRUE
    my $outCsr = "$NetSNMP::Cert::NEWCRTDIR/$cn.csr";
    NetSNMP::Cert::check_output_file($opts, $outCsr, $config->inherit('interactive'));
    $cmd = "$env openssl req -new -nodes -days $days -batch -keyout $outKey -out $outCsr -config $NetSNMP::Cert::SSLCFG -extensions v3_ca_create";
    NetSNMP::Cert::dprint("genCa (gencsr): $cmd\n", $opts);
    NetSNMP::Cert::usystem("$cmd $opts->{out} $opts->{err}");

    my $ca_base = ::basename($ca, @NetSNMP::Cert::CRTSUFFIXES);
    NetSNMP::Cert::dprint("ca_base: $ca_base\n", $opts);
    $cmd = "$env openssl ca -batch -days $days -cert $ca -keyfile $NetSNMP::Cert::PRIVDIR/$ca_base.key -in $outCsr -out $outCrt -config $NetSNMP::Cert::SSLCFG -extensions v3_ca_sign_ca";

    NetSNMP::Cert::dprint("genCa (signcsr): $cmd\n", $opts);
    NetSNMP::Cert::usystem("$cmd $opts->{out} $opts->{err}");
  } else {
    $cmd = "$cmd -x509 -extensions v3_ca_create";
    NetSNMP::Cert::dprint("genCa: $cmd\n", $opts);
    NetSNMP::Cert::usystem("$cmd $opts->{out} $opts->{err}");
  }

  NetSNMP::Cert::vprint("CA Generated:\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::CADIR/$cn.crt\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::PRIVDIR/$cn.key\n", $opts);
}

sub genCert {
  my $app = shift;
  my $config = $app->{config};
  my $opts = $app->{OPTS};
  my $host = $config->inherit("host") || ::hostname();
  my $email = $config->inherit("email") || getlogin() . "\@$host";
  my $days = $config->inherit('crtDays') || $config->inherit('days') || $NetSNMP::Cert::DEFCRTDAYS;
  my $cn = $config->inherit('cn') || $config->inherit('commonName');
  my $ca = $config->inherit('ca');

  my $tag = $opts->{tag} || 'snmp';
  $cn ||= (NetSNMP::Cert::is_server($tag) ? $host : $email);

  my $env = $app->opensslEnv($cn, $days);
  
  my $outCrt = "$NetSNMP::Cert::CRTDIR/$tag.crt";
  my $outKey = "$NetSNMP::Cert::PRIVDIR/$tag.key";
  
  NetSNMP::Cert::check_output_file($opts, $outCrt, $config->inherit('interactive'));
  NetSNMP::Cert::check_output_file($opts, $outKey, $config->inherit('interactive'));

  my $cmd = "$env openssl req -new -x509 -extensions v3_req -nodes -days $days -batch -keyout $outKey -out $outCrt -config $NetSNMP::Cert::SSLCFG";

  NetSNMP::Cert::dprint("genCert: $cmd\n", $opts);

  NetSNMP::Cert::usystem("$cmd $opts->{out} $opts->{err}");

  NetSNMP::Cert::vprint("Certificate Generated:\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::CRTDIR/$tag.crt\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::PRIVDIR/$tag.key\n", $opts);
}

sub genCsr {
  my $app = shift;
  my $isCa = shift;
  my $config = $app->{config};
  my $opts = $app->{OPTS};
  my $host = $config->inherit("host") || ::hostname();
  my $email = $config->inherit("email") || getlogin() . "\@$host";
  my $days = $config->inherit('crtDays') || $config->inherit('days') || $NetSNMP::Cert::DEFCRTDAYS;
  my $cn = $config->inherit('cn') || $config->inherit('commonName');
  my $tag = $opts->{tag} || 'snmp';

  $cn ||= (NetSNMP::Cert::is_server($tag) ? $host : $email);

  my $env = $app->opensslEnv($cn, $days);
  
  my $outCrt = "$NetSNMP::Cert::NEWCRTDIR/$tag.csr";
  my $outKey = "$NetSNMP::Cert::PRIVDIR/$tag.key";
  
  NetSNMP::Cert::check_output_file($opts, $outCrt, $config->inherit('interactive'));
  NetSNMP::Cert::check_output_file($opts, $outKey, $config->inherit('interactive'));

  my $cmd = "$env openssl req -new -nodes -extensions v3_req -days $days -batch -keyout $outKey -out $outCrt -config $NetSNMP::Cert::SSLCFG";
  $cmd .= " -extensions v3_ca_create" if $isCa;

  NetSNMP::Cert::dprint("genCsr: $cmd\n", $opts);

  NetSNMP::Cert::usystem("$cmd $opts->{out} $opts->{err}");

  NetSNMP::Cert::vprint("Certificate Signing Request Generated:\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::NEWCRTDIR/$tag.csr\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::PRIVDIR/$tag.key\n", $opts);
}

sub signCsr {
  my $app = shift;
  my $isCa = shift;
  my $config = $app->{config};
  my $opts = $app->{OPTS};
  my $host = $config->inherit("host") || ::hostname();
  my $email = $config->inherit("email") || getlogin() . "\@$host";
  my $days = $config->inherit('crtDays') || $config->inherit('days') || $NetSNMP::Cert::DEFCRTDAYS;
  my $cn = $config->inherit('cn') || $config->inherit('commonName');
  my $tag = $config->inherit('tag') || 'DOES_THIS_MATTER';
  my $install = $config->inherit('install');

  $cn = (NetSNMP::Cert::is_server($tag) ? $host : $email);

  my $env = $app->opensslEnv($cn, $days);
  
  my $ca = $opts->{ca};
  NetSNMP::Cert::dprint("ca: $ca\n", $opts);
  my $ca_base = ::basename($ca, @NetSNMP::Cert::CRTSUFFIXES);
  NetSNMP::Cert::dprint("ca_base: $ca_base\n", $opts);
  my $csr = $opts->{csr};
  NetSNMP::Cert::dprint("csr: $csr\n", $opts);
  my $csr_base = ::basename($csr, @NetSNMP::Cert::CRTSUFFIXES);
  NetSNMP::Cert::dprint("csr_base: $csr_base\n", $opts);

  my $outdir = ($install ? $NetSNMP::Cert::CRTDIR : $NetSNMP::Cert::NEWCRTDIR);

  my $outCrt = "$outdir/$csr_base.crt";
  
  NetSNMP::Cert::check_output_file($opts, $outCrt, $config->inherit('interactive'));

  # XXX - handle keyfile search??
  my $cmd = "$env openssl ca -batch -days $days -extensions v3_ca_sign -cert $ca -keyfile $NetSNMP::Cert::PRIVDIR/$ca_base.key -in $csr -out $outCrt -config $NetSNMP::Cert::SSLCFG";

  $cmd .= ($isCa ? " -extensions v3_ca_sign_ca" : " -extensions v3_ca_sign");

  NetSNMP::Cert::dprint("signCsr: $cmd\n", $opts);

  NetSNMP::Cert::usystem("$cmd $opts->{out} $opts->{err}");

  NetSNMP::Cert::vprint("Signed Certificate Signing Request:\n", $opts);
  NetSNMP::Cert::vprint("  $csr\n", $opts);
  NetSNMP::Cert::vprint("with CA:\n", $opts);
  NetSNMP::Cert::vprint("  $ca\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::PRIVDIR/$ca_base.key\n", $opts);
  NetSNMP::Cert::vprint("Generated Certificate:\n", $opts);
  NetSNMP::Cert::vprint("  $NetSNMP::Cert::NEWCRTDIR/$csr_base.crt\n", $opts);
}

sub show {
  my $app = shift;
  my $type = shift || 'certs';
  my $config = $app->{config};
  my $opts = $app->{OPTS};
  my $stag = shift(@{$opts->{cmdargs}});
  my $fmt = NetSNMP::Cert::x509_format($opts) || '-subject';
  my $cmd;

  my $cwd = ::getcwd();
  NetSNMP::Cert::dprint("show ($cwd):$type:$stag:$fmt\n", $opts);
  NetSNMP::Cert::vprint("$opts->{tlsdir}:\n", $opts);
  
  foreach my $c (NetSNMP::Cert::find_certs($opts, $type, $stag)) {
    print "\n$c:\n";
    $cmd = "openssl x509 -in $c -noout $fmt";
    NetSNMP::Cert::dprint("show: $cmd\n", $opts);
    NetSNMP::Cert::usystem("$cmd");
    print "\n";
  }
}

sub run {
  my $app = shift;
  my $opts = $app->{OPTS};
  my $cmd = $opts->{cmd};

  # be sure we have tools to run the app
  $app->checkReqs();

  # lazy config parsing postponed until here, will not reparse
  $app->{config}->parse();

  # find tlsdir/subdirs or make it
  $opts->{tlsdir} = $app->handleTlsDir();

  #  change dir tls dir - the cwd for all commands - save cwd first
  $opts->{rdir} = ::getcwd();
  chdir($opts->{tlsdir}) or die("could not change directory: $opts->{tlsdir}");

  # display context
  NetSNMP::Cert::dprint("PATH: $ENV{PATH}\n\n", $opts);
  NetSNMP::Cert::dprint("config file: $opts->{cfgfile}\n", $opts);
  NetSNMP::Cert::dprint("config dir:  $opts->{cfgdir}\n", $opts);
  NetSNMP::Cert::dprint("tls dir:     $opts->{tlsdir}\n", $opts);

  my $cmdstr = join(' ', $cmd, @{$opts->{cmdargs}});
  NetSNMP::Cert::dprint("command:     $cmdstr\n", $opts);
  
  GetOptionsFromArray(\@{$opts->{cmdargs}}, $opts, 'ca|a=s', 'csr|r=s', 'crt|x=s',
		      'cn|n=s', 'email|e=s', 'host|h=s', 'san|s=s@', 'org|o=s', 'unit|u=s',
		      'country|c=s', 'state|province|p=s', 'locality|l=s', 'days|d=s',
		      @NetSNMP::Cert::X509FMTS);

  # find ca, crt, csr args if present and return fully qualified path
  # XXX - should refactor cut paste code
  if (defined $opts->{ca}) {
    my $ca;
    $ca = NetSNMP::Cert::find_certs($opts, 'ca-certs', $opts->{ca});
    die("unable to locate CA certificate ($opts->{ca})\n") unless -e $ca;
    die("unable read CA certificate ($opts->{ca})\n") unless -r $ca;
    $opts->{ca} = $ca;
  }
  if (defined $opts->{crt}) {
    my $crt;
    $crt = NetSNMP::Cert::find_certs($opts, 'certs', $opts->{crt});
    die("unable to locate certificate ($opts->{crt})\n") unless -e $crt;
    die("unable read certificate ($opts->{crt})\n") unless -r $crt;
    $opts->{crt} = $crt;
  }
  if (defined $opts->{csr}) {
    my $csr;
    $csr = NetSNMP::Cert::find_certs($opts, 'csrs', $opts->{csr});
    die("unable to locate CSR certificate ($opts->{csr})\n") unless -e $csr;
    die("unable read CSR certificate ($opts->{csr})\n") unless -r $csr;
    $opts->{csr} = $csr;
  }

  NetSNMP::Cert::dprint("processing extra args...\n", $opts);
  my @args;
  while (@{$opts->{cmdargs}}) {
    my $arg = shift(@{$opts->{cmdargs}});
    NetSNMP::Cert::dprint("found: arg --> $arg\n", $opts);
    if ($arg =~ /^-+(\w+)(?:=(.*?))?\s*$/) {
      NetSNMP::Cert::dprint("found: arg($1) val($2)\n", $opts);
      if (exists $opts->{$1}) {
   	NetSNMP::Cert::vwarn("option ($1) already set: overwriting", $opts);
      } 
      $opts->{$1} = (defined $2 ? $2 : 1);
    } else {
      push(@args, $arg);
    }
  }
  @{$opts->{cmdargs}} = @args;

  if ($cmd =~ /^genca$/) {
    NetSNMP::Cert::usage(1) if defined $opts->{crt} or defined $opts->{csr};
    $app->genCa($opts->{ca});
  } elsif ($cmd =~ /^gence?rt$/) {
    NetSNMP::Cert::usage(1) if defined $opts->{crt} or defined $opts->{csr};
    $app->genCert($opts->{ca});
  } elsif ($cmd =~ /^gencsr$/) {
    NetSNMP::Cert::usage(1) if defined $opts->{ca} or defined $opts->{csr};
    $app->genCsr($opts->{crt});
  } elsif ($cmd =~ /^signcsr$/) {
    NetSNMP::Cert::usage(1) unless defined $opts->{ca} and defined $opts->{csr};
    $app->signCsr();
  } elsif ($cmd =~ /^show(ce?rts?)?$/) {
    $app->show('certs');
  } elsif ($cmd =~ /^showcas?$/) {
    $app->show('ca-certs');
  } elsif ($cmd =~ /^import(ca|cert)?$/) {
    $app->import($1);
  } else {
    NetSNMP::Cert::usage();
  }
}

package NetSNMP::Cert::Config;
use vars qw(@ISA);
@ISA = qw(NetSNMP::Cert::Obj);

sub new {
  my $class = shift;
  my $parent = shift;
  my $this = $class->SUPER::new('config', $parent);

  bless($this, $class);
}

sub parse {
  my $config = shift;
  my $app = $config->{app};
  my $opts = $app->{OPTS};
  my $cfgfile = shift;
  $cfgfile ||= $opts->{cfgfile};

  return '0 but true' if $config->{PARSED};
  return '0 but true' unless defined $cfgfile;

  open( CONFIG, "<$cfgfile" )
    or die "error - could not open configuration file: $cfgfile";

  while (<CONFIG>) {
    next if /^\s*#/ or /^\s*$/;

    if (/^\s*(\w+)(?:\(([\)\(\d\,\.]+)\))?\s*=\s*{/) {
      my $obj = $1;
      my $indices = $2 || 1;

      $indices = "1..$indices" if $indices =~ /^\d+$/;
      NetSNMP::Cert::dprint("object: $obj ($indices) = {\n", $opts);

      # Found an object.
      if ( $obj eq 'identity' ) {
	my $pos = tell(CONFIG);
	for my $index (eval($indices)) {
	  # must reset cfg file pos each loop
	  seek(CONFIG,$pos,0);
	  push( @{$config->{$obj}}, NetSNMP::Cert::Identity::parse(*CONFIG, $config, $index) );
	}
      } else {
        die "error - unrecognized object ($1) at scope (config)";
      }
    } elsif (/^\s*(\w+)\s*=?\s*(.*?)\s*$/) {
      my $key = $1;
      my $val = $2;

      $val = $config->resolve($val) if $val =~ /\$\w+|\&\{.*?\}/;
      # Found a symbol.
      NetSNMP::Cert::dprint("  $key = $val\n", $opts);

      if ( defined $config->{$key} ) {
        die "error - duplicate symbol $key";
      } else {
        $config->{$key} = (defined $val ? $val : 1 );
      }
    } elsif (/^\s*env\s*(\w+=\S+)\s*$/) {
      # Found an environment variable.
      NetSNMP::Cert::dprint("$&\n", $opts);
      push(@{$config->{env}}, $1);
    } else {
      die("error in config file [$cfgfile:line $.]");
    }
  }

  NetSNMP::Cert::dprint("end parse config\n", $opts);
  close(CONFIG);

  # augment with any config directives supplied in opts
  foreach my $cfg (@{$opts->{config}}) {
    NetSNMP::Cert::dprint("augmenting config: $cfg\n", $opts);

    $config->autoSet($1, (defined($2) ? $2 : 1 ))
      if $cfg =~ /^\s*(\w+)\s*=?\s*(.*?)\s*$/;
  }
  $config->autoSet('PARSED', 1);
  return $config->{PARSED};
}

package NetSNMP::Cert::Identity;
use vars qw(@ISA);
@ISA = qw(NetSNMP::Cert::Obj);

sub new {
  my $class = shift;
  my $this = shift || $class->SUPER::new('identity', @_);
  my $ind = $this->{INDEX} || 1;

  $this->autoSet('name', "$this->{type}.$ind") unless exists $this->{name};

  $this->autoSet('LOG','') unless exists $this->{LOG};
  $this->autoSet('TTY_LOG','') unless exists $this->{TTY_LOG};

  bless($this, $class);
}


sub parse {
  my $FILE = shift;
  my $parent = shift;
  my $ind = shift || 1;
  my $opts = $parent->inherit('OPTS');
  my $identity = new NetSNMP::Cert::Obj('identity', $parent, $ind);

  NetSNMP::Cert::dprint("parse identity\n", $opts);

  while (<$FILE>) {
    next if /^\s*#/ or /^\s*$/;

    if (/^\s*(\w+)\s*=\s*{/) {
      # Found an object.
      if ( $1 eq 'role' ) {
	push( @{$identity->{$1}}, NetSNMP::Cert::Role::parse($FILE, $identity));
      } else {
	die "error - can't have nested $1";
      }
    } elsif (/^\s*(\w+)\s*=?\s*(.*?)\s*$/) {
      my $key = $1;
      my $val = $2;

      # Found a symbol.
      NetSNMP::Cert::dprint("  $key = $val\n", $opts);

      $val = $identity->resolve($val) if $val =~ /\$\w+|\&\{.*?\}/;

      if ( defined $identity->{$key} ) {
        die "error - duplicate symbol $key";
      } else {
        $identity->{$key} = $val;
      }
    } elsif (/\s*\}\s*\;/) {
      # End of definition.
      NetSNMP::Cert::dprint("end parse identity\n", $opts);
      return new NetSNMP::Cert::Identity($identity);
    } else {
      die("error in config file [$opts->{cfgfile}:line $.]");
    }
  }
  die "error - unexpected end of conf file";
}

package main;

my $app = new NetSNMP::Cert::App(@ARGV);

$app->run();

