#!/usr/bin/perl -w

#
# A simple configuration file builder based on questions listed in
# it's own configuration file.  It would certainly be easy to use this
# for other (non-snmp) programs as well.
#

use Getopt::Std;
use Term::ReadLine;
use IO::Dir;
use IO::File;
use Data::Dumper;

# globals
%tokenitems=qw(line 1 info 1 comment 1);
%arrayitems=qw(question 1 validanswer 1);

#defaults
$opts{'c'} = "/usr/local/share/snmp/snmpconf";

# read the argument string
getopts("adhfc:pir:R:", \%opts);

# display help
if ($opts{'h'}) {
    print "$0 [-h] [-d] [-f] [-c config_directory] [FILETOCREATE...]\n";
    print "  -c conf_dir  use alternate configuration directory.\n";
    print "  -f           overwrite existing files without prompting\n";
    print "  -d           turn on debugging output\n";
    print "  -i           install created files into /usr/local/share/snmp.\n";
    print "  -p           install created files into $ENV{HOME}/.snmp.\n";
    print "  -a           Don't ask any questions, just read in current\n";
    print "                   current .conf files and comment them\n";
    print "  -f           Overwrite existing files without asking.\n";
    print "  -r all|none  Read in all or none of the .conf files found.\n";
    print "  -R file,...  Read in a particular list of .conf files.\n";
    exit;
}

# setup terminal interface.
$term = new Term::ReadLine 'snmpconf';

# read in configuration file set
read_config_files($opts{'c'}, \%filetypes);
debug(Dumper(\%filetypes));

#
# Find existing files to possibly read in.
#
foreach my $i (qw(/usr/local/share/snmp /usr/local/etc/snmp .), "$ENV{HOME}/.snmp") {
    debug("searching $i\n");
    foreach my $ft (keys(%filetypes)) {
	debug("searching for $i/$ft\n");
	$knownfiles{"$i/$ft"} = $ft if (-f "$i/$ft");
	my $localft = $ft;
	$localft =~ s/.conf/.local.conf/;
	$knownfiles{"$i/$localft"} = $ft if (-f "$i/$localft");
    }
}

#
# Ask the user if they want them to be read in and read them
#
if (keys(%knownfiles)) {
    my @files;
    if (defined($opts{'r'})) {
	if ($opts{'r'} eq "all" || $opts{'r'} eq "a") {
	    @files = keys(%knownfiles);
	} elsif ($opts{'r'} ne "none" && $opts{'r'} ne "n") {
	    print "unknown argument to -r: $opts{'r'}\n";
	    exit(1);
	}
    } elsif(defined($opts{'R'})) {
	@files = split(/\s*,\s*/,$opts{'R'});
	foreach my $i (@files) {
	    my $x = $i;
	    $x =~ s/.*\/([^\/]+)$/$1/;
	    $knownfiles{$i} = $x;
	}
	print "reading: ", join(",",@files),"\n";
    } else {
	my @files = display_menu(-head => "The following configuration files were found:\n",
				 -tail => "Would you like me to read them in?  Their content will be added to the\noutput files created by this session.\nValid answer examples: \"all\", \"none\",\"1,2,5\"\n",
				 -multiple => 1,
				 -question => 'Read in which',
				 -defaultvalue => 'all',
				 sort keys(%knownfiles));
    }
    foreach my $i (@files) {
	debug("reading $i\n");
	read_config($i, $knownfiles{$i});
    }
}

if ($#ARGV >= 0) {
    #
    # loop through requested files.
    #
    foreach my $i (@ARGV) {
	if (!defined($filetypes{$i})) {
	    warn "invalid file: $i\n";
	} else {
	    if ($opts{'a'}) {
		$didfile{$i} = 1;
	    } else {
		build_file($term, $i, $filetypes{$i});
	    }
	}
    }
} else {
    #
    # ask user to select file type to operate on.
    #
    while(1) {
	my $line = display_menu(-head => "Select file to create:\n",
				-question => 'Select File',
				-otheranswers => ['quit', 'q'],
				keys(%filetypes));
	last if ($line eq "q" or $line eq "quit");
	debug("file selected: $line\n");
	build_file($term, $line, $filetypes{$line});
    }
}

#
# Write out the results to the output files.
#
output_files(\%filetypes, $term);


#
# Display the files that have been created for the user.
#
print "The following files were created:\n";
foreach my $i (keys(%didfile)) {
    if ($didfile{$i} ne "1") {
	if ($opts{'i'}) {
	    system("mv /usr/local/share/snmp/$i /usr/local/share/snmp/$i.bak");
	    system("mv $didfile{$i} /usr/local/share/snmp");
	    print "  $didfile{$i} installed in /usr/local/share/snmp\n";
	} elsif ($opts{'p'}) {
	    system("mv $ENV{HOME}/.snmp/$i $ENV{HOME}/.snmp/$i.bak");
	    system("mv $i $ENV{HOME}/.snmp");
	    print "  $didfile{$i} installed in $ENV{HOME}/.snmp\n";
	} else {
	    print "  $didfile{$i} ",
	    ($i ne $didfile{$i})?"[ from $i specifications]":" ","\n";
	    if ($opts{'d'}) {
		open(I,$didfile{$i});
		debug("    " . join("    ",<I>) . "\n");
		close(I);
	    }
	}
    }
}

#
# build a particular type of file by operating on sections
#
sub build_file {
    my ($term, $filename, $fileconf) = @_;
    $didfile{$filename} = 1;
    my (@lines);
    while(1) {
	my $line = display_menu(-head => "Select configuration section for $filename to operate on:\n",
				-otheranswers => ['finished','f'],
				-question => "Select section",
				-numeric => 1,
				map { $_->{'title'}[0] } @$fileconf);

	return @lines if ($line eq "finished" || $line eq "f");
	do_section($fileconf->[$line-1]);
    }
}

#
# configure a particular section by operating on token types
#
sub do_section {
    my $confsect = shift;
    my @lines;
    while(1) {
	print "\nSection: $confsect->{'title'}[0]\n";
	print "Description:\n";
	print "  ", join("\n  ",@{$confsect->{'description'}}),"\n";
	my $line =
	    display_menu(-head => "Select from:\n",
			 -otheranswers => ['finished','f','list','l'],
			 -question => 'Select section',
			 -descriptions => [map { $confsect->{$_}{info}[0] } 
					   keys(%{$confsect->{'thetokens'}})],
			 keys(%{$confsect->{'thetokens'}}));
	return @lines if ($line eq "finished" || $line eq "f");
	if ($line eq "list" || $line eq "l") {
	    print "Lines defined for section \"$confsect->{title}[0]\" so far:\n";
	    foreach my $i (keys(%{$confsect->{'thetokens'}})) {
		print "  ",join("\n  ",@{$confsect->{$i}{'results'}}),"\n";
	    }
	    next;
	}
	do_line($line, $confsect->{$line});
    }
    return;
}

#
# Ask all the questions related to a particular line type
#
sub do_line {
    my $token = shift;
    my $confline = shift;
    my (@answers, $counter, $i);
#    debug(Dumper($confline));
    print "\nConfiguring: $token\n";
    print "Description:\n  ",join("\n    ",@{$confline->{'info'}}),"\n\n";
    for($i=0; $i <= $#{$confline->{'question'}}; $i++) {
	if (defined($confline->{'question'}[$i]) &&
	    $confline->{'question'}[$i] ne "") {
	    my $q = $confline->{'question'}[$i];
	    $q =~ s/\$(\d+)/$answers[$1]/g;
	    debug("after: $term, $q, ",$confline->{'validanswer'}[$i],"\n");
	    $answers[$i] = get_answer($term, $q,
				      $confline->{'validanswer'}[$i]);
	}
    }
    if ($#{$confline->{'line'}} == -1) {
	my ($i,$line);
	for($i=0; $i <= $#{$confline->{'question'}}; $i++) {
	    next if (!defined($confline->{'question'}[$i]) ||
		     $confline->{'question'}[$i] eq "");
	    $line .= " \$" . $i;
	}
	push @{$confline->{'line'}}, $line;
    }

    foreach my $line (@{$confline->{'line'}}) {
	my $finished = $line;
	debug("preline: $finished\n");
	debug("answers: ",Dumper(\@answers));
	$finished =~ s/\$(\d+)/$answers[$1]/g;
	if ($line =~ s/^eval\s+//) {
	    debug("eval: $finished\n");
	    $finished = eval $finished;
	    debug("eval results: $finished\n");
	}
	$finished = $token . " " . $finished;
	print "\nFinished Output: $finished\n";
	push @{$confline->{'results'}},$finished;
    }
}

#
# read all sets of config files in the various subdirectories.
#
sub read_config_files {
    my $readdir = shift;
    my $filetypes = shift;
    my $dh = new IO::Dir($readdir);
    die "no such directory $readdir, did you run make install?\n" if (!defined($dh));
    my $dir;
    while(defined($dir = $dh->read)) {
	next if ($dir =~ /^\./);
	next if ($dir =~ /CVS/);
	debug("dir entry: $dir\n");
	if (-d "$readdir/$dir") {
	    $filetypes->{$dir} = read_config_items("$readdir/$dir");
	}
    }
}

#
# read each configuration file in a directory
#
sub read_config_items {
    my $itemdir = shift;
    my $dh = new IO::Dir($itemdir);
    return if (!defined($dh));
    my $file;
    my @results;
    while(defined($file = $dh->read)) {
	next if ($file =~ /~$/);
	if (-f "$itemdir/$file") {
	    push @results, read_config_item("$itemdir/$file");
	}
    }
    return \@results;
}

#
# Parse one file
#
sub read_config_item {
    my $itemfile = shift;
    my $fh = new IO::File($itemfile);
    return if (!defined($fh));
    my (%results, $curtoken);
    debug("tokenitems:  ", Dumper(\%tokenitems));
    while($line = <$fh>) {
	next if ($line =~ /^\s*\#/);
	my ($token, $rest) = ($line =~ /^(\w+)\s+(.*)/);
	next if (!defined($token) || !defined($rest));
	debug("token: $token => $rest\n");
	if ($token eq 'steal') {
	    foreach my $stealfrom (keys(%{$results{$rest}})) {
		if (!defined($results{$curtoken}{$stealfrom})) {
		    @{$results{$curtoken}{$stealfrom}} = 
			@{$results{$rest}{$stealfrom}};
		}
	    }
	} elsif (defined($tokenitems{$token})) {
	    if (!defined($curtoken)) {
		die "error in configuration file $itemfile, no token set\n";
	    }
	    $rest =~ s/^\#//;
	    push @{$results{$curtoken}{$token}},$rest;
	} elsif (defined($arrayitems{$token})) {
	    if (!defined($curtoken)) {
		die "error in configuration file $itemfile, no token set\n";
	    }
	    my ($num, $newrest) = ($rest =~ /^(\d+)\s+(.*)/);
	    if (!defined($num) || !defined($newrest)) {
		warn "invalid config line: $line\n";
	    } else {
		$results{$curtoken}{$token}[$num] = $newrest;
	    }
	} elsif ($token =~ /^token\s*$/) {
	    $rest = lc($rest);
	    $curtoken = $rest;
	    $results{'thetokens'}{$curtoken} = 1;
	    $results{$curtoken}{'defined'} = 1;
	    $tokenmap{$curtoken} = $results{$curtoken};
	    debug("current token set to $token\n");
	} else {
	    push @{$results{$token}},$rest;
	}
    }
    return \%results;
}

sub debug {
    print @_ if ($opts{'d'});
}

sub output_files {
    my $filetypes = shift;
    my $term = shift;
    foreach my $ft (keys(%$filetypes)) {
	next if (!$didfile{$ft});
	my $outputf = $ft;
	if (-f $outputf && !$opts{'f'}) {
	    print "Error: $outputf already exists.  \n";
	    my $ans = get_answer($term,"'overwrite', 'skip', 'rename' or 'append'? ",valid_answers(qw(o overwrite r rename s skip a append)));
	    next if ($ans =~ /^(s|skip)$/i);
	    if ($ans =~ /^(a|append)/) {
		$outputf = ">$outputf";
	    } elsif ($ans =~ /^(r|rename)$/i) {
		# default to rename for error conditions
		$outputf = $term->readline("Save to what file name then (or 'skip')? ");
	    }
	}
	$didfile{$ft} = $outputf;
	open(O,">$outputf") || warn "couldn't write to $outputf\n";
	print O "#" x 75,"\n";
	print O "#\n# $ft\n";
	print O "#\n#   - created by the snmpconf configuration program\n#\n";
	foreach my $sect (@{$filetypes->{$ft}}) {
	    my $secthelp = 0;
	    foreach my $token (keys(%{$sect->{'thetokens'}})) {
		if ($#{$sect->{$token}{'results'}} >= 0) {
		    if ($secthelp++ == 0) {
			print O "#" x 75,"\n# SECTION: ",
			join("\n#          ", @{$sect->{title}}), "\n#\n";
			print O "#   ", join("\n#   ",@{$sect->{description}}),
			"\n";
		    }
		    print O "\n# $token: ",
		    join("\n#   ",@{$sect->{$token}{info}}), "\n\n";
		    foreach my $result (@{$sect->{$token}{'results'}}) {
			print O "$result\n";
		    }
		}
	    }
	    print O "\n\n\n";
	}
	if ($#{$unknown{$ft}} > -1) {
	    print O "#\n# Unknown directives read in from other files by snmpconf\n#\n";
	    foreach my $unknown (@{$unknown{$ft}}) {
		print O $unknown,"\n";
	    }
	}
	close(O);
    }
}

sub get_answer {
    my ($term, $question, $regexp, $defaultval) = @_;
    $question .= " (default = $defaultval)" if (defined($defaultval) && $defaultval ne "");
    $question .= ": ";
    my $ans = $term->readline($question);
    return $defaultval if ($ans eq "" && defined($defaultval) && 
			   $defaultval ne "");
    while (!(!defined($regexp) ||
	     $regexp eq "" ||
	     $ans =~ /$regexp/)) {
	print "invalid answer!  It must match this regular expression: $regexp\n";
	$ans = $term->readline($question);
    }
    return $defaultval if ($ans eq "" && defined($defaultval) && 
			   $defaultval ne "");
    return $ans;
}
    
sub valid_answers {
    return "^(" . join("|",@_) . ")\$";
}

sub read_config {
    my $file = shift;
    my $filetype = shift;
    return if (!defined($filetypes{$filetype}));
    open(I,$file);
    while(<I>) {
	next if (/^\s*\#/);
	next if (/^\s*$/);
	chomp;
	my ($token, $rest) = /^\s*(\w+)\s+(.*)/;
	$token = lc($token);
	next if (defined($alllines{$_})); # drop duplicate lines
	if (defined($tokenmap{$token})) {
	    push @{$tokenmap{$token}{'results'}},$_;
	} else {
	    push @{$unknown{$filetype}},$_;
	}
	$alllines{$_}++;
    }
}

sub display_menu {
    my %config;

    while ($#_ > -1 && $_[0] =~ /^-/) {
	my $key = shift;
	$config{$key} = shift;
    }

    my $count=1;
    print "\n" if (!defined($config{'-dense'}));
    if ($config{'-head'}) {
	print $config{'-head'};
	print "\n" if (!defined($config{'-dense'}));
    }
    my @answers = @_;
    my @list;
    if (defined($config{'-descriptions'}) && 
	ref($config{'-descriptions'}) eq "ARRAY") {
	@list = @{$config{'-descriptions'}}
    } else {
	@list = @_;
    }
    foreach my $i (@list) {
	printf "  %2d:  $i\n", $count++;
    }
    print "\n" if (!defined($config{'-dense'}));
    if (defined($config{'-otheranswers'})) {
	if (ref($config{'-otheranswers'}) eq 'ARRAY') {
	    print "Other options: ", join(",",@{$config{'-otheranswers'}}),"\n";
	    push @answers, @{$config{'-otheranswers'}};
	} else {
	    my $maxlen = 0;
	    push @answers,keys(%{$config{'-otheranswers'}});
	    foreach my $i (keys(%{$config{'-otheranswers'}})) {
		$maxlen = length($i) if (length($i) > $maxlen);
	    }
	    foreach my $i (keys(%{$config{'-otheranswers'}})) {
		printf("  %-" . $maxlen . "s: %s\n", $i, 
		       $config{'-otheranswers'}{$i});
	    }
	}
	print "\n" if (!defined($config{'-dense'}));
    }
    if ($config{'-tail'}) {
	print $config{'-tail'};
	print "\n" if (!defined($config{'-dense'}));
    }

    if (defined($config{'-question'})) {
	while(1) {
	    my $numexpr;
	    if ($config{'-multiple'}) {
		$numexpr = '[\d\s,]+|all|a|none|n';
	    } else {
		$numexpr = '\d+';
	    }
	    push @answers,"" if ($config{'-defaultvalue'});
	    $ans = get_answer($term, $config{'-question'},
			      valid_answers($numexpr,@answers),
			      $config{'-defaultvalue'});

	    if ($ans =~ /^$numexpr$/) {
		if ($config{'-multiple'}) {
		    my @list = split(/\s*,\s*/,$ans);
		    my @ret;
		    $count = 0;
		    foreach my $i (@_) {
			$count++;
			if ($ans eq "all" || $ans eq "a" 
			    || grep(/^$count$/,@list)) {
			    push @ret, $i;
			}
		    }
		    return @ret;
		} else {
		    if ($ans <= 0 || $ans > $#_+1) {
			warn "invalid selection: $ans [must be 1-" .
			    ($#_+1) . "]\n";
		    } else {
			return $ans if ($config{'-numeric'});
			$count = 0;
			foreach my $i (@_) {
			    $count++;
			    if ($ans eq $count) {
				return $i;
			    }
			}
		    }
		}
	    } else {
		return $ans;
	    }
	}
    }
}
