## -*- c -*-
##
## For documentation on the code generated by this configuration file,
## see the file agent/helpers/table_array.c.
##
######################################################################
## Do the .c file
######################################################################
@foreach $i table@
@open ${i}-persist.c@
@eval $hack = "Id"@
/*
 * Note: this file originally auto-generated by mib2c using
 *       $Id$
 *
 * $$hack:$
 *
 *
 * For help understanding NET-SNMP in general, please check the 
 *     documentation and FAQ at:
 *
 *     http://www.net-snmp.org/
 *
 *
 * For help understanding this code, the agent and how it processes
 *     requests, please check the following references.
 *
 *     http://www.net-snmp.org/tutorial/
 *
 *
 * You can also join the #net-snmp channel on irc.openprojects.net
 *     and ask for help there.
 *
 *
 * And if all else fails, send a detailed message to the developers
 *     describing the problem you are having to:
 *
 *    net-snmp-coders@lists.sourceforge.net
 *
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include "${i}.h"

/************************************************************
 * the *_should_save routine is call to determine if a row
 * should be stored persistently.
 *
 * return 1 if the row should be stored
 * return 0 if the row should not be stored
 */
int
${i}_should_save(${i}_context * context)
{
    @foreach $c column@
        @if "$c.syntax" eq "StorageType"@
            if (context->$c == SNMP_STORAGE_VOLATILE)
                return 0;
        @end@
     @end@
    
    return 1; /* save me */
}

/************************************************************
 * ${i}_col_save_value
 */
char * ${i}_col_save_value(
            ${i}_context *context,
            int col, char* buf)
{
    if( ( NULL == context ) || ( NULL == buf )) {
        snmp_log(LOG_ERR, "bad parameter in "
                 "${i}_col_save_value\n");
        return NULL;
    }

    /*
     * prefix with column number, so we don't ever depend on
     * order saved.
     */
    buf += sprintf(buf, "%d", col);

    /*
     * save data for the column
     */
    switch(col) {

        @foreach $c column@
            @eval $have_type = 0@
        case COLUMN_$c.uc:
            /** $c.syntax = $c.type */
            @if "$c.type" eq "ASN_OBJECT_ID"@
                @eval $have_type = 1@
            buf = read_config_store_data_prefix(':', $c.type, buf,
                                                 &context->$c,
                                                 context->${c}_len );
            @end@
            @if "$c.type" eq "ASN_OCTET_STR"@
                @eval $have_type = 1@
            buf = read_config_store_data_prefix(':', $c.type, buf,
                                                 &context->$c,
                                                 context->${c}_len );
            @end@
            @if $have_type == 0@
            buf = read_config_store_data_prefix(':', $c.type, buf,
                                                 &context->$c,
                                                 sizeof(context->$c) );
            @end@
        break;
    
        @end@
    default: /** We shouldn't get here */
        snmp_log(LOG_ERR, "unknown column in "
                 "${i}_col_save_value\n");
        return NULL;
    }

    return buf;
}

/************************************************************
 * ${i}_row_save
 */
int ${i}_row_save(
            ${i}_context *context)
{
    char filename[ PATH_MAX ];
    char *buf, *line;
    char *tmp;
    int i, size;

    if (${i}_should_save(context) == 0) {
        return SNMP_ERR_NOERROR;
    }

    /*
     * allocate space for each column. Comment out columns you don't
     * intend to save;
     */
    size = 
    @foreach $c column@
        @if ! $c.noaccess@
            @eval $have_type = 0@
            @if "$c.type" eq "ASN_OBJECT_ID"@
                @eval $have_type = 1@
            ( ( 12 * sizeof(context->$c) ) + 3 ) + /* $c.type $c */
            @end@
            @if "$c.type" eq "ASN_OCTET_STR"@
                @eval $have_type = 1@
            ( ( 2 * sizeof(context->$c) ) + 3 ) + /* $c.type $c */
            @end@
            @if $have_type == 0@
            ( 12 ) + /* $c.type $c */
            @end@
        @end@
    @end@
                ( ${i}_COL_MAX * 3 ); /* extra space per column */

    /*
     * build file name "<tablename><index>.row"
     *
     * (Must have some non-numeric ending, or it will wreak havoc with
     * the persistent store backup mechanism).
     */
    tmp = filename;
    tmp += sprintf(filename,"${i}");
    tmp = read_config_save_objid(tmp, context->index.oids,
                                 context->index.len);
    if(NULL == tmp) {
        snmp_log(LOG_ERR,"error saving row to persistent file\n");
        return SNMP_ERR_GENERR;
    }
    sprintf(tmp,".row");

    /*
     * allocate memory for the line
     */
    line = buf = calloc(1, size);
    if(NULL == buf) {
        snmp_log(LOG_ERR,"error allocating memory while saving row\n");
        return SNMP_ERR_GENERR;
    }
    
    /*
     * build the line
     */
    for(i = ${i}_COL_MIN; i <= ${i}_COL_MAX; ++i ) {

        tmp = buf;
        buf = ${i}_col_save_value(context, i, buf);
        if(buf == NULL)
            buf = tmp;
        else
            *buf++ = ' ';
        
    }
    *buf++ = '\n';

    /*
     * store the line
     */
    snmp_save_persistent( filename );
    read_config_store(filename, line);
    snmp_clean_persistent( filename );

    /*
     * free memory
     */
    free(line);
    
    return SNMP_ERR_NOERROR;
}

@end@
