#!/usr/bin/env perl

use Getopt::Long;
use Data::Dumper;
use File::Basename;
use Cwd qw(abs_path);
use strict;

########################################
# Globals and Command Line options

my %opts = ('groups' => 'default',
            'd' => 'fulltests',
	    'srcdir' => dirname("$0") . "/..",
            'builddir' => '..',
	    'failed-file' => 'failed_tests',
	   );

Getopt::Long::Configure(qw(no_ignore_case));
GetOptions(\%opts,
           "verbose",
           "help|?",
           "quiet",
           "groups|g=s",
           "r=s",
           "debug",
           "srcdir|D=s",
           "builddir=s",
	   "f",
	   "F",
	   "failed-file=s",
	  ) || ++$opts{'help'};

# Change srcdir and builddir to absolute paths
$opts{'srcdir'} = abs_path($opts{'srcdir'});
$opts{'builddir'} = abs_path($opts{'builddir'});

usage() if ($opts{'help'});

# Build the harness object
my %args = (
	    verbosity => ($opts{'v'} ? 1 : 0),
	    exec => \&decide_exec,
	    failures => ($opts{'q'} ? 0 : 1),
	    errors => ($opts{'q'} ? 0 : 1),
	   );

# list of support infrastructure components
my %support;
my %sources;

# if the -d option was specified, pass on the source root directory to all apps
if (exists($opts{'d'})) {
    $ENV{'NETSNMPSRCDIR'} = $opts{'d'};
} else {
    $ENV{'NETSNMPSRCDIR'} = '.';
}

# pass srcdir and builddir to all apps
$ENV{'srcdir'} = $opts{'srcdir'};
$ENV{'builddir'} = $opts{'builddir'};

########################################
# Protection measures
$ENV{'SNMPCONFPATH'} = "/dev/null";

# create the testing harness infrastructure

my $harness;
if (eval { require TAP::Harness; } ) {
    import TAP::Harness;
    $harness = TAP::Harness->new(\%args);
} else {
    require Test::Harness;
    import Test::Harness;
    if ($opts{'groups'} ne 'default') {
	print STDERR "
ERROR: I can not find the perl TAP::Harness module.  We support the
more common Test::Harness module but only for the default test group.

Either:
  1) run only the default tests (i.e., just \"make test\")
  2) install the TAP::Harness perl module

";
	exit 1;
    }
}


########################################
# gather the tests
my @tests;

DEBUG("Gathering and building tests:\n");
find_support();
if ($opts{'f'}) {
    DIE("The -f and -g options can not be both specified\n")
      if ($opts{'groups'} ne 'default');
    DIE("The -f and -r options can not be both specified\n") if ($opts{'r'});
    DIE("No $opts{'failed-file'} file was found to read failed state from\n")
      if (! -f $opts{'failed-file'});
    open(F, $opts{'failed-file'});
    while (<F>) {
	chomp;
	push @tests, build_test($_);
    }
} else {
    @tests = gather_tests($opts{'groups'}, $opts{'r'});
}

########################################
# rename them to remove parent dirs
@tests = rename_tests(@tests);

########################################
# run the tests

DEBUG("Running tests:\n"); 
DEBUG("-" x 78, "\n");

my $results;
if ($harness) {
    $results = $harness->runtests(@tests);
} else {
    # minimal backwards compat with Test::Harness
    run_older_perl_tests(@tests);
}

my @failed = $results->failed();
if (!$opts{'q'} && $#failed > -1) {
    print "\nWe failed these ", (1 + $#failed), " tests:\n";
    my @lines = @failed;
    map { if (exists($sources{$_})) { $_ = "$_ ( $sources{$_} )"} } @lines;
    print "  ", join("\n  ",@lines), "\n";
}

if (!$opts{'F'}) {
    open(F,">$opts{'failed-file'}");
    if ($#failed > -1) {
	print F "$opts{'srcdir'}/testing/$opts{'d'}/" .
	  join("\n$opts{'srcdir'}/testing/$opts{'d'}/",@failed) . "\n";
    }
    close(F);
}

exit($results->all_passed() ? 0 : 1);

######################################################################
# Infrastructure
#

########################################
# decides how we should execute a test
#
sub decide_exec {
    my ( $harness, $testfile ) = @_;

    # 1) if it's a known executable type, just run it.
    if ($testfile =~ /\.exe$/) {
	return [$testfile];
    }

    # 1) if it's a known executable built by libtool, call libtool to run it.
    if ($testfile =~ /\.exe\.lt$/) {
	return ["$opts{'builddir'}/libtool", "--mode=execute", $testfile];
    }

    # see if we have a registered runner script
    my ($dirname, $groupname, $basename, $app_extension, $file_extension) = 
      ($testfile =~ /([^\/]+)\/([^\/]+)\/([^\/]+)_([^_]+)\.*([^\.]*)$/);

    # 2) we have a BUILD_TYPE file in the same directory
    if (exists($support{'run'}{$app_extension}{$groupname})) {
	return [$support{'run'}{$app_extension}{$groupname}, $testfile];
    }

    # 3) return a generic build script
    if (exists($support{'run'}{$app_extension}{'generic'})) {
	return [$support{'run'}{$app_extension}{'generic'}, $testfile];
    }

    # 4) give up and let the test harness decide itself
    return undef;
}

sub gather_tests {
    my ( $groups, $regexp ) = @_;
    my @groups;

    # figure out the list of groups we need to search through
    if ($groups eq 'all') {
	# find every group we can
	# we exclude:
	#  - things not a directory
	#  - anything with "template" in the name
	@groups =
	  grep { !/(template|support)/ &&
		   -d $_ && s/$opts{'srcdir'}\/testing\/$opts{'d'}.// } glob("$opts{'srcdir'}/testing/$opts{'d'}/*");
    } else {
	# they specified a comma separated list
	@groups = split(/,\s*/, $groups);
    }
    DEBUG("Checking groups: ", join(", ", @groups), "\n");

    my @tests;
    foreach my $group (@groups) {
	my @files;

	DEBUG("checking group $group\n");

	if (! -d "$opts{'srcdir'}/testing/$opts{'d'}/$group") {
	    ERROR("group '$group' is not a directory under '$opts{'srcdir'}/testing/$opts{'d'}'; ignoring\n");
	    next;
	}

	# push on all files that start with T[NUM]*
	push_or_skip(\@tests, $regexp, glob("$opts{'srcdir'}/testing/$opts{'d'}/$group/T[0-9]*"));
    }

    return @tests;
}

sub push_or_skip {
    my ($array, $regexp, @files) = @_;
    foreach my $file (@files) {
	next if ($file =~ /.(bak|old|orig|rej)$/);
	next if ($file =~ /~$/);
	next if (defined($regexp) && $file !~ /$regexp/);
	DEBUG("  Adding file $file\n");
	push @$array, build_test($file);
    }
}

# rename all the tests to remove the top subdir to help readability
sub rename_tests {
    my (@tests) = @_;
    my @newtests;

    # yes, I could have used map.  But I didn't.
    foreach my $file (@tests) {
	my $title = "$file";
	my $foundheader = 0;
	$title = $sources{$file} if (exists($sources{$file}));
	
	open(SRC, $title);
	while (<SRC>) {
	    if (/(HEADER|TITLE)\s+['"]*(.*)/) {
		$title = $2;
		$title =~ s/\s*\*\/.*//;
		$title =~ s/['"]$//;
		$foundheader = 1;
		last;
	    }
	}
	close(SRC);

	if (! $foundheader) {
	    $title =~ s/^$opts{'srcdir'}\/testing\///;
	    $title =~ s/$opts{'d'}.//;
	}
	$sources{$title} = $sources{$file} || $file;
	push @newtests, [$file, $title];
    }
    return @newtests;
}

# called to possibly manipluate the list of tests to run by building some
sub build_tests {
    my (@tests) = @_;
    my @newtests;

    foreach my $test (@tests) {
	my $title;
	
	my $built = build_test($test);
	if (ref($built) eq 'ARRAY') {
	    push @newtests, @$built;
	} elsif ($built ne "") {
	    push @newtests, $built;
	}
    }
    return @newtests;
}

#
# Finds scripts that are used to build and run actual commands
#
sub find_builders {
    $support{'build'} = {};
    find_scripts('build', $support{'build'});
}

sub find_runners {
    $support{'run'} = {};
    find_scripts('run', $support{'run'});
}

sub find_support {
    find_builders();
    find_runners();
}

sub find_scripts {
    my ($buildname, $hashref) = @_;
    my $count;
    DEBUG("looking for $buildname scripts\n");
    foreach my $builder (glob("$opts{'srcdir'}/testing/$opts{'d'}/*/*_${buildname}")) {
	next if ($builder =~ /~$/);
	next if ($builder =~ /.(bak|orig|rej|old)$/);

	my ($group, $type) = ($builder =~ /([^\/]+)\/([^\/]*)_${buildname}/);
	# save this as a certain group builder
	$hashref->{$type}{$group} = $builder;

	# save this as a generic builder if there isn't a better
	# generic one, such as one that exists in the support
	# directory.
	if (!exists($hashref->{$type}{'generic'}) || $group eq 'support') {
	    $hashref->{$type}{'generic'} = $builder;
	}
	$count++;
    }
    DEBUG("  found $count\n");
}

# called to build a test from a registerd builder
sub build_test {
    my ($testfile) = @_;

    my ($dirname, $groupname, $basename, $app_extension, $file_extension) = 
      ($testfile =~ /([^\/]+)\/([^\/]+)\/([^\/]+)_([^_]+)\.([^\.]+)$/);

    # is this even a buildable type recipe?
    if (!$dirname || !$basename || !$app_extension || !$file_extension) {
	return $testfile;
    }

    DEBUG("found: $testfile => $dirname, $basename, $app_extension, $file_extension\n");

    # choices:
    # 1) we have a registered subroutine to build an extension from
    # XXX

    # 2) we have a BUILD_TYPE file in the same directory
    if (exists($support{'build'}{$app_extension}{$dirname})) {
	return
	  call_build_script($support{'build'}{$app_extension}{$dirname}, $testfile);
    }

    # 3) return a generic build script
    if (exists($support{'build'}{$app_extension}{'generic'})) {
	return
	  call_build_script($support{'build'}{$app_extension}{'generic'}, $testfile);
    }

    # 4) we assume it's fine as is
    return $testfile;
}

sub call_build_script {
    my ($scriptname, $filename) = @_;

    my $maybenewfile = $filename;
    $maybenewfile =~ s/.[^\.]+$/.exe/;   # add .exe suffix
    $maybenewfile =~ s/T([^\/]+)$/B$1/;  # change prefix to B for 'Built'
    $maybenewfile =~ s/^$opts{'srcdir'}\///;

    my $newpath = $maybenewfile;
    $newpath =~ s/\/[^\/]*$//;

    if (! -d $newpath) {
	DEBUG("making directory $newpath\n");
	system("$opts{'srcdir'}/mkinstalldirs $newpath");
    }

    my $lastline;
    DEBUG("BUILDING: $scriptname $filename $maybenewfile\n");
    open(B,"$scriptname $filename $maybenewfile|");
    while (<B>) {
	$lastline = $_;
    }
    chomp($lastline);

    DEBUG("  result: $lastline\n");
    return undef if ($lastline eq 'fail');
    return undef if ($lastline eq 'skip');
    return $filename if ($lastline eq '');
    $sources{$lastline} = $filename;        # remember where we came from
    return $lastline;
}

sub run_older_perl_tests {
    #
    # Older versions of perl used a different test suite called Test::Harness
    # It is much more limited than TAP::Harness;
    #
    # Here we massage our older tests into something that will work under
    # Test::Harness too.
    #
    my @tests = @_;

    # create the temporary files
    my @tempfiles;
    if (! -d "$opts{'d'}") {
	mkdir("$opts{'d'}");
    }
    if (! -d "$opts{'d'}/temptests") {
	mkdir("$opts{'d'}/temptests");
    }
    foreach my $test (@tests) {
	my $tempfile = "$opts{'d'}/$test->[1].t";
	$tempfile =~ s#$opts{'d'}/default/#$opts{'d'}/temptests/#;
	open(T, ">$tempfile") || die("$tempfile: $!");
	print T "# functionally perl\n\nsystem(\"$opts{'srcdir'}/testing/fulltests/support/run_olducd $opts{'srcdir'}/testing/$opts{'d'}/$test->[1]\");\n";
	close(T);
	chmod(0755, $tempfile);
	push @tempfiles, $tempfile;
    }

    $results = runtests(@tempfiles);

    unlink(@tempfiles) || die("$@ $!");
    exit;
}

# usage output
sub usage {
    print "$0 [OPTIONS]\n";

    print "\nOPTIONS:\n";
    print "  -v\t\t\tRuns in verbose mode; dumping all test output\n";
    print "    --verbose\n";
    print "  -q\t\t\tRuns in quieter mode; dumps less test output\n";
    print "    --quiet\n";
    print "  -g GROUP\t\tRuns the group of specified tests (default = 'default')\n";
    print "    --group GROUP\n";
    print "\t\t\t(use 'all' to run all tests)\n";
    print "  -r\t\t\tOnly run test files matching this regexp\n";
    print "  -f\t\t\tRun only the failed tests from the last run\n";
    print "  -F\t\t\tDon't create the failed_tests file\n";
    print "  --failed-file FILE\tThe location of the failed state file\n";
    print "  -D PATH\t\tSource directory\n";
    print "    --srcdir PATH\n";
    print "    (currently '$opts{'srcdir'}')\n";
    print "  -d PATH\t\tBuild directory to be tested\n";
    print "    --builddir PATH\n";
    print "    (currently '$opts{'builddir'}')\n";
    print "  -h\t\t\tThis help output\n";
    print "    --help\n";
    print "  --debug\t\tDebugging output\n\n";
    exit;
}

sub DEBUG {
    return if (!$opts{'debug'});
    print @_;
}

sub ERROR {
    print STDERR "Error:", @_;
}

sub DIE {
    ERROR(@_);
    exit 1;
}
