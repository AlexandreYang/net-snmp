/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.table_data.conf,v 1.3 2004/10/14 12:57:34 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "disman/schedCore.h"
#include "utilities/iquery.h"


netsnmp_table_data *schedTable;

/** Initializes the schedCore module */
void
init_schedCore(void)
{
    netsnmp_table_row *row;
    struct schedTable_entry *entry;

    /*
     * Create a table structure for the schedule table
     * This will typically be registered by the schedTable module
     */
    DEBUGMSGTL(("sched", "Initializing core module\n"));
    schedTable = netsnmp_create_table_data("schedTable");

#ifdef NO_TESTING
    /*
     * Insert an entry into this table for testing 
     */
    row = schedTable_createEntry(schedTable, "dts", 3, "test2", 5, NULL );
    entry = (struct schedTable_entry *)row->data;
    init_snmp("snmpd");       /* HACK - to load the MIB files */
    entry->schedVariable_len = MAX_OID_LEN;
    if (snmp_parse_oid("UCD-SNMP-MIB::versionDoDebugging.0", entry->schedVariable,
                                              &entry->schedVariable_len)) {
        entry->schedAdminStatus = 1;  /* Enable the entry */
        entry->schedRowStatus   = 1;
        entry->schedInterval    = 20;
        sched_nextTime( entry );
    } else {
        snmp_perror("versionDoDebugging.0");
    }
#endif
}


/*
 * Callback to invoke a scheduled action
 */
static void
_sched_callback( unsigned int reg, void *magic )
{
    struct schedTable_entry *entry = (struct schedTable_entry *)magic;
    int ret;
    netsnmp_variable_list assign;
    memset(&assign, 0, sizeof(netsnmp_variable_list));

    if ( !entry ) {
        DEBUGMSGTL(("sched", "callback: no entry\n"));
        return;
    }
    entry->schedLastRun = time(0);
    entry->schedTriggers++;

    DEBUGMSGTL(( "sched", "callback: "));
    DEBUGMSGOID(("sched", entry->schedVariable, entry->schedVariable_len));
    DEBUGMSG((   "sched", " = %d\n", entry->schedValue));
    snmp_set_var_objid(&assign, entry->schedVariable, entry->schedVariable_len);
    snmp_set_var_typed_value(&assign, ASN_INTEGER,
                                         (u_char *)&entry->schedValue,
                                         sizeof(entry->schedValue));

    ret = netsnmp_query_set( &assign, entry->schedSession );
    if ( ret != SNMP_ERR_NOERROR ) {
        entry->schedFailures++;
        entry->schedLastFailure = ret;
        time ( &entry->schedLastFailed );
    }

    sched_nextTime( entry );
}

/*
 * determine the time for the next scheduled action of a given entry
 */
void
sched_nextTime( struct schedTable_entry *entry )
{
    time_t now;
    time( &now );

    if ( !entry ) {
        DEBUGMSGTL(("sched", "nextTime: no entry\n"));
        return;
    }

    if ( entry->schedCallbackID )
        snmp_alarm_unregister( entry->schedCallbackID );

    if ( entry->schedAdminStatus != 1  /* enabled */ ||
         entry->schedRowStatus   != 1  /* active  */ ) {
        DEBUGMSGTL(("sched", "nextTime: not active\n"));
        return;
    }

    switch ( entry->schedType ) {
    case 1:     /* periodic */
        if ( !entry->schedInterval ) {
            DEBUGMSGTL(("sched", "nextTime: no interval\n"));
            return;
        }
        if ( entry->schedLastRun ) {
             entry->schedNextRun = entry->schedLastRun +
                                   entry->schedInterval;
        } else {
             entry->schedNextRun = now + entry->schedInterval;
        }
        DEBUGMSGTL(("sched", "nextTime: periodic %d\n", entry->schedNextRun));
        break;

    case 3:     /* one-shot */
        if ( entry->schedLastRun ) {
            DEBUGMSGTL(("sched", "nextTime: one-shot expired (%d)\n",
                                  entry->schedLastRun));
            return;
        }
        /* Fallthrough */
        DEBUGMSGTL(("sched", "nextTime: one-shot fallthrough\n"));
    case 2:     /* calendar */
        /*
         *  Check for complete specification
         */
        /*
         *  Calculate next run time:
         *  If the current Month, Day & Hour is set
         *    calculate the next specified minute
         *  If this fails (or the current Hour is not set)
         *    use the first specified minute,
         *    and calculate the next specified hour
         *  If this fails (or the current Day is not set)
         *    use the first specified minute and hour
         *    and calculate the next specified day (in this month)
         *  If this fails (or the current Month is not set)
         *    use the first specified minute and hour
         *    calculate the next specified month, and
         *    the first specified day (in that month)
         *
         *  IF currentMonth is set
         *    IF currentDay is set
         *      IF currentHour is set
         *        [ CHECK Fall TIMECHANGE ]
         *        FIND nextMinute
         *      IF NOT nextMinute
         *        USE firstMinute
         *        FIND nextHour
         *    IF NOT nextHour
         *      USE firstHour
         *      FIND nextDay(thisMonth)
         *
         *  WHILE NOT nextDay          
         *    FIND nextMonth
         *    FIND nextDay(nextMonth)
         *
         *  [ CHECK Spring TIMECHANGE ]
         */
        DEBUGMSGTL(("sched", "nextTime: calendar %d\n", entry->schedNextRun));
        return;
    default:
        DEBUGMSGTL(("sched", "nextTime: unknown type %d\n", entry->schedType));
        return;
    }
    entry->schedCallbackID = snmp_alarm_register(
                                entry->schedNextRun - now,
                                0, _sched_callback, entry );
    return;
}

void
sched_nextRowTime( netsnmp_table_row *row )
{
    sched_nextTime((struct schedTable_entry *) row->data );
}

/*
 * create a new row in the table 
 */
netsnmp_table_row *
schedTable_createEntry(netsnmp_table_data *table_data, char *schedOwner,
                       size_t schedOwner_len, char *schedName,
                       size_t schedName_len, netsnmp_pdu *pdu)
{
    struct schedTable_entry *entry;
    netsnmp_table_row *row;

    DEBUGMSGTL(("sched", "creating entry (%s/%s)\n", schedOwner, schedName));
    entry = SNMP_MALLOC_TYPEDEF(struct schedTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_create_table_data_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;
    /*
     * Set the indexing for this entry, both in the row
     *  data structure, and in the table_data helper.
     */
    memcpy(entry->schedOwner, schedOwner, schedOwner_len);
    entry->schedOwner_len = schedOwner_len;
    netsnmp_table_row_add_index(row, ASN_OCTET_STR,
                                entry->schedOwner, schedOwner_len);
    memcpy(entry->schedName, schedName, schedName_len);
    entry->schedName_len = schedName_len;
    netsnmp_table_row_add_index(row, ASN_OCTET_STR,
                                entry->schedName, schedName_len);
    /*
     * Set the (non-zero) default values in the row data structure.
     */
    entry->schedType         = 1;   /* periodic */
    entry->schedAdminStatus  = 2;   /* disabled */
    entry->schedStorageType  = 2;   /* volatile */
    entry->schedVariable_len = 2;   /* .0.0 */

    if (pdu)
        entry->schedSession = netsnmp_iquery_pdu_session( pdu );
    else
        entry->schedSession = netsnmp_iquery_user_session( schedOwner );

    netsnmp_table_data_add_row(table_data, row);
    return row;
}

/*
 * remove a row from the table 
 */
void
schedTable_removeEntry(netsnmp_table_data *table_data,
                       netsnmp_table_row *row)
{
    struct schedTable_entry *entry;

    DEBUGMSGTL(("sched", "removing entry (%x)\n", row));
    if (!row)
        return;                 /* Nothing to remove */
    entry = (struct schedTable_entry *)
        netsnmp_table_data_remove_and_delete_row(table_data, row);
    if (entry)
        SNMP_FREE(entry);       /* XXX - release any other internal resources */
}
