/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for ipCidrRouteTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ipCidrRouteTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "ipCidrRouteTable_interface.h"

oid             ipCidrRouteTable_oid[] = { IPCIDRROUTETABLE_OID };
int             ipCidrRouteTable_oid_size =
OID_LENGTH(ipCidrRouteTable_oid);

void            initialize_table_ipCidrRouteTable(void);


/**
 * Initializes the ipCidrRouteTable module
 */
void
init_ipCidrRouteTable(void)
{
    DEBUGTRACE;

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("ipCidrRouteTable"))
        initialize_table_ipCidrRouteTable();

}

/**
 * Initialize the table ipCidrRouteTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_ipCidrRouteTable(void)
{
    ipCidrRouteTable_registration_ptr user_context;
    u_long          flags;

    DEBUGTRACE;

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _ipCidrRouteTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
ipCidrRouteTable_pre_request(ipCidrRouteTable_registration_ptr
                             user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
ipCidrRouteTable_post_request(ipCidrRouteTable_registration_ptr
                              user_context)
{
    DEBUGTRACE;

    /*
     * TODO:
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table ipCidrRouteTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ipCidrRouteTable is subid 4 of ipForward.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.24.4, length: 9
 */

/*
 * ipCidrRouteTable_allocate_data
 *
 * Purpose: create new ipCidrRouteTable_data.
 */
ipCidrRouteTable_data *
ipCidrRouteTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    /** this might not be right for netsnmp_route_entry */
    ipCidrRouteTable_data *rtn = netsnmp_access_route_entry_create();

    DEBUGTRACE;

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "ipCidrRouteTable_data.\n");
    }

    return rtn;
}

/*
 * ipCidrRouteTable_allocate_data
 *
 * Purpose: release data data.
 */
void
ipCidrRouteTable_release_data(ipCidrRouteTable_data * data)
{
    DEBUGTRACE;

    /*
     * release memory for the context
     */
    netsnmp_access_route_entry_free(data);
}



/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values are
 *  native/rawformat, and the mapping function is called (or suggested) when
 *  necessary.
 */
int
ipCidrRouteTable_indexes_set_tbl_idx(ipCidrRouteTable_mib_index * tbl_idx,
                                     u_long ipCidrRouteDest,
                                     u_long ipCidrRouteMask,
                                     long ipCidrRouteTos,
                                     u_long ipCidrRouteNextHop)
{
    DEBUGTRACE;

    /*
     * ipCidrRouteDest(1)/IPADDR/ASN_IPADDRESS/u_long(u_long)//l/A/w/e/r/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->ipCidrRouteDest = ipCidrRouteDest;

    /*
     * ipCidrRouteMask(2)/IPADDR/ASN_IPADDRESS/u_long(u_long)//l/A/w/e/r/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->ipCidrRouteMask = ipCidrRouteMask;

    /*
     * ipCidrRouteTos(3)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->ipCidrRouteTos = ipCidrRouteTos;

    /*
     * ipCidrRouteNextHop(4)/IPADDR/ASN_IPADDRESS/u_long(u_long)//l/A/w/e/r/d/h 
     */
    /** no mapping */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->ipCidrRouteNextHop = ipCidrRouteNextHop;


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
ipCidrRouteTable_indexes_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                             u_long ipCidrRouteDest,
                             u_long ipCidrRouteMask, long ipCidrRouteTos,
                             u_long ipCidrRouteNextHop)
{
    if (MFD_SUCCESS !=
        ipCidrRouteTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                             ipCidrRouteDest,
                                             ipCidrRouteMask,
                                             ipCidrRouteTos,
                                             ipCidrRouteNextHop))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != ipCidrRouteTable_index_to_oid(&rowreq_ctx->oid_idx,
                                           &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteIfIndex
 * ipCidrRouteIfIndex is subid 5 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteIfIndex data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteIfIndex_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteIfIndex_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long *ipCidrRouteIfIndex_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteIfIndex_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteIfIndex_ptr ) from rowreq_ctx->data->
     */
    (*ipCidrRouteIfIndex_ptr) = rowreq_ctx->data->if_index;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteType
 * ipCidrRouteType is subid 6 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  other(1), reject(2), local(3), remote(4)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ipCidrRouteType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ipCidrRouteType_map(u_long * mib_ipCidrRouteType_ptr,
                    u_long raw_ipCidrRouteType)
{
    netsnmp_assert(NULL != mib_ipCidrRouteType_ptr);

    DEBUGTRACE;

    /* xxx-rks: delete or move to access_route_* */
    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ipCidrRouteType) {
    case INTERNAL_IPCIDRROUTETYPE_OTHER:
        *mib_ipCidrRouteType_ptr = IPCIDRROUTETYPE_OTHER;
        break;

    case INTERNAL_IPCIDRROUTETYPE_REJECT:
        *mib_ipCidrRouteType_ptr = IPCIDRROUTETYPE_REJECT;
        break;

    case INTERNAL_IPCIDRROUTETYPE_LOCAL:
        *mib_ipCidrRouteType_ptr = IPCIDRROUTETYPE_LOCAL;
        break;

    case INTERNAL_IPCIDRROUTETYPE_REMOTE:
        *mib_ipCidrRouteType_ptr = IPCIDRROUTETYPE_REMOTE;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ipCidrRouteType\n",
                 raw_ipCidrRouteType);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ipCidrRouteType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteType_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteType_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                    u_long * ipCidrRouteType_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteType_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteType_ptr ) from rowreq_ctx->data->
     */
    (* ipCidrRouteType_ptr ) = rowreq_ctx->data->rt_type;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteProto
 * ipCidrRouteProto is subid 7 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.4.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 12/32. Values:  other(1), local(2), netmgmt(3), icmp(4), egp(5), ggp(6), hello(7), rip(8), isIs(9), esIs(10), ciscoIgrp(11), bbnSpfIgp(12), ospf(13), bgp(14), idpr(15), ciscoEigrp(16)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ipCidrRouteProto.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ipCidrRouteProto_map(u_long * mib_ipCidrRouteProto_ptr,
                     u_long raw_ipCidrRouteProto)
{
    netsnmp_assert(NULL != mib_ipCidrRouteProto_ptr);

    DEBUGTRACE;

    /* xxx-rks: delete or move to access_route_* */
    /*
     * TODO:
     * value mapping
     */
    (* mib_ipCidrRouteProto_ptr) = (raw_ipCidrRouteProto & RTF_DYNAMIC)
        ? IPCIDRROUTEPROTO_ICMP : IPCIDRROUTEPROTO_LOCAL;

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ipCidrRouteProto data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteProto_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteProto_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                     u_long * ipCidrRouteProto_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteProto_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteProto_ptr ) from rowreq_ctx->data->
     */
    (* ipCidrRouteProto_ptr ) = rowreq_ctx->data->rt_proto;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteAge
 * ipCidrRouteAge is subid 8 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.4.1.8
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *   defval: 0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteAge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteAge_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteAge_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                   long *ipCidrRouteAge_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteAge_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteAge_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteInfo
 * ipCidrRouteInfo is subid 9 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * It's syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max )
 */
/**
 * Extract the current value of the ipCidrRouteInfo data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteInfo_ptr_ptr
 *        Pointer to storage for a oid variable
 * @param ipCidrRouteInfo_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ipCidrRouteInfo.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ipCidrRouteInfo_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ipCidrRouteInfo_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ipCidrRouteInfo_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                    oid ** ipCidrRouteInfo_ptr_ptr,
                    size_t * ipCidrRouteInfo_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ipCidrRouteInfo_ptr_ptr)
                   && (NULL != *ipCidrRouteInfo_ptr_ptr));
    netsnmp_assert(NULL != ipCidrRouteInfo_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteInfo_ptr_ptr ) and (* ipCidrRouteInfo_ptr_len_ptr ) from rowreq_ctx->data->
     */
    if((*ipCidrRouteInfo_ptr_len_ptr) < nullOidLen) {
        (*ipCidrRouteInfo_ptr_ptr) = malloc(nullOidLen);
        if(NULL == (*ipCidrRouteInfo_ptr_ptr))
            return MFD_ERROR;
    }
            
    (*ipCidrRouteInfo_ptr_len_ptr) = nullOidLen;
    memcpy((*ipCidrRouteInfo_ptr_ptr), nullOid, nullOidLen);

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteNextHopAS
 * ipCidrRouteNextHopAS is subid 10 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.10
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteNextHopAS data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteNextHopAS_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteNextHopAS_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *ipCidrRouteNextHopAS_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteNextHopAS_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteNextHopAS_ptr ) from rowreq_ctx->data->
     */
     (* ipCidrRouteNextHopAS_ptr ) = rowreq_ctx->data->rt_nexthop_as;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric1
 * ipCidrRouteMetric1 is subid 11 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.11
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteMetric1 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric1_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteMetric1_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long *ipCidrRouteMetric1_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteMetric1_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteMetric1_ptr ) from rowreq_ctx->data->
     */
    (* ipCidrRouteMetric1_ptr) = rowreq_ctx->data->rt_metric1;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric2
 * ipCidrRouteMetric2 is subid 12 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.12
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteMetric2 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric2_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteMetric2_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long *ipCidrRouteMetric2_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteMetric2_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteMetric2_ptr ) from rowreq_ctx->data->
     */
    (* ipCidrRouteMetric2_ptr) = rowreq_ctx->data->rt_metric1;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric3
 * ipCidrRouteMetric3 is subid 13 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteMetric3 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric3_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteMetric3_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long *ipCidrRouteMetric3_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteMetric3_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteMetric3_ptr ) from rowreq_ctx->data->
     */
    (* ipCidrRouteMetric3_ptr) = rowreq_ctx->data->rt_metric1;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric4
 * ipCidrRouteMetric4 is subid 14 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteMetric4 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric4_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteMetric4_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long *ipCidrRouteMetric4_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteMetric4_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteMetric4_ptr ) from rowreq_ctx->data->
     */
    (* ipCidrRouteMetric4_ptr) = rowreq_ctx->data->rt_metric1;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric5
 * ipCidrRouteMetric5 is subid 15 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ipCidrRouteMetric5 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric5_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteMetric5_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long *ipCidrRouteMetric5_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteMetric5_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ipCidrRouteMetric5_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteStatus
 * ipCidrRouteStatus is subid 16 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ipCidrRouteStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteStatus_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipCidrRouteStatus_get(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                      u_long * ipCidrRouteStatus_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipCidrRouteStatus_ptr);

    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ipCidrRouteStatus_ptr) = rowreq_ctx->ipCidrRouteStatus;

    return MFD_SUCCESS;
}



/** @} */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ipCidrRouteTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ipCidrRouteTable is subid 4 of ipForward.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.24.4, length: 9
 */
/**
 * create new data context, if specified index is valid.
 *
 * @param ipCidrRouteTable_reg
 *        Pointer to the user registration data
 * @param ipCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS   : success
 * @retval MFD_BAD_VALUE : index not valid
 */
int
ipCidrRouteTable_validate_index(ipCidrRouteTable_registration_ptr
                                ipCidrRouteTable_reg,
                                ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * Validate incoming index
     *
     * Check that the values specified in the incoming index are valid
     * values. All of the individual index component functions have been
     * called, so this is the place to make sure they are valid as
     * a whole when combined.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * TODO:
     * update this code or row creation won't work
     */
    if (1) {
        snmp_log(LOG_WARNING, "invalid index for a new row in the "
                 "ipCidrRouteTable table.\n");
        /*
         * TODO:
         * determine failure type.
         *
         * If the index could not ever be created, SNMP_ERR_NOCREATION.
         * If the index can not be created under the  present circumstances
         * (even though it could be created under other circumstances),
         * SNMP_ERR_INCONSISTENTNAME.
         */
        if (0) {
            return SNMP_ERR_NOCREATION;
        } else {
            return SNMP_ERR_INCONSISTENTNAME;
        }
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return rc;
}

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ipCidrRouteTable_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * commit new valies.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * @param ipCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ipCidrRouteTable_commit(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * commit data
     */

    return rc;
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteDest
 * ipCidrRouteDest is subid 1 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.4.1.1
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * check validity of ipCidrRouteDest index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ipCidrRouteTable_validate_index() function.
 */
int
ipCidrRouteDest_check_index(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for ipCidrRouteDest is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMask
 * ipCidrRouteMask is subid 2 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.4.1.2
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * check validity of ipCidrRouteMask index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ipCidrRouteTable_validate_index() function.
 */
int
ipCidrRouteMask_check_index(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for ipCidrRouteMask is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteTos
 * ipCidrRouteTos is subid 3 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.4.1.3
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * check validity of ipCidrRouteTos index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ipCidrRouteTable_validate_index() function.
 */
int
ipCidrRouteTos_check_index(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for ipCidrRouteTos is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteNextHop
 * ipCidrRouteNextHop is subid 4 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.4.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is IPADDR (based on perltype IPADDR)
 * The net-snmp type is ASN_IPADDRESS. The C type decl is u_long (u_long)
 */
/**
 * check validity of ipCidrRouteNextHop index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ipCidrRouteTable_validate_index() function.
 */
int
ipCidrRouteNextHop_check_index(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for ipCidrRouteNextHop is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteIfIndex
 * ipCidrRouteIfIndex is subid 5 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteIfIndex
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteIfIndex_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               long ipCidrRouteIfIndex)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteIfIndex_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteIfIndex data
     *  from 'rowreq_ctx->data->ipCidrRouteIfIndex to 'rowreq_ctx->undo->ipCidrRouteIfIndex'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteIfIndex
 *        A long containing the new value.
 */
int
ipCidrRouteIfIndex_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long ipCidrRouteIfIndex)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteIfIndex value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteIfIndex_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteIfIndex data
     *  from 'rowreq_ctx->undo->ipCidrRouteIfIndex to 'rowreq_ctx->data->ipCidrRouteIfIndex'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteType
 * ipCidrRouteType is subid 6 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  other(1), reject(2), local(3), remote(4)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteType
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), reject(2), local(3), remote(4)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteType_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                            u_long ipCidrRouteType)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteType_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteType data
     *  from 'rowreq_ctx->data->ipCidrRouteType to 'rowreq_ctx->undo->ipCidrRouteType'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteType
 *        A long containing the new value.
 */
int
ipCidrRouteType_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                    u_long ipCidrRouteType)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (ipCidrRouteType) {
    case IPCIDRROUTETYPE_OTHER:
        ipCidrRouteType = INTERNAL_IPCIDRROUTETYPE_OTHER;
        break;

    case IPCIDRROUTETYPE_REJECT:
        ipCidrRouteType = INTERNAL_IPCIDRROUTETYPE_REJECT;
        break;

    case IPCIDRROUTETYPE_LOCAL:
        ipCidrRouteType = INTERNAL_IPCIDRROUTETYPE_LOCAL;
        break;

    case IPCIDRROUTETYPE_REMOTE:
        ipCidrRouteType = INTERNAL_IPCIDRROUTETYPE_REMOTE;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for ipCidrRouteType\n",
                 ipCidrRouteType);
        return SNMP_ERR_GENERR;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set ipCidrRouteType value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteType_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteType data
     *  from 'rowreq_ctx->undo->ipCidrRouteType to 'rowreq_ctx->data->ipCidrRouteType'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteInfo
 * ipCidrRouteInfo is subid 9 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * It's syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max )
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteInfo_ptr
 *        A oid containing the new value.
 * @param ipCidrRouteInfo_ptr_len
 *        The size (in bytes) of the data pointed to by ipCidrRouteInfo_ptr
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OBJECT_ID
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, and object with the syntax DisplayString(0..40)
 * will have already been checked for a length between 0 and 40.
 * But if the description also specified that the value must
 * be all uppercase letters, you would enforce that requirement here.
 *
 */
int
ipCidrRouteInfo_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                            oid * ipCidrRouteInfo_ptr,
                            size_t ipCidrRouteInfo_ptr_len)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ipCidrRouteInfo_ptr);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteInfo_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteInfo and ipCidrRouteInfo_len data
     *  from 'rowreq_ctx->data->ipCidrRouteInfo to 'rowreq_ctx->undo->ipCidrRouteInfo'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteInfo_ptr
 *        A oid containing the new value.
 * @param ipCidrRouteInfo_ptr_len
 *        The size (in bytes) of the data pointed to by ipCidrRouteInfo_ptr
 */
int
ipCidrRouteInfo_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                    oid * ipCidrRouteInfo_ptr,
                    size_t ipCidrRouteInfo_ptr_len)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ipCidrRouteInfo_ptr);

    /*
     * TODO:
     * set ipCidrRouteInfo value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteInfo_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteInfo and ipCidrRouteInfo_len data
     *  from 'rowreq_ctx->undo->ipCidrRouteInfo to 'rowreq_ctx->data->ipCidrRouteInfo'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteNextHopAS
 * ipCidrRouteNextHopAS is subid 10 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.10
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteNextHopAS
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteNextHopAS_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                                 long ipCidrRouteNextHopAS)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteNextHopAS_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteNextHopAS data
     *  from 'rowreq_ctx->data->ipCidrRouteNextHopAS to 'rowreq_ctx->undo->ipCidrRouteNextHopAS'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteNextHopAS
 *        A long containing the new value.
 */
int
ipCidrRouteNextHopAS_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long ipCidrRouteNextHopAS)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteNextHopAS value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteNextHopAS_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteNextHopAS data
     *  from 'rowreq_ctx->undo->ipCidrRouteNextHopAS to 'rowreq_ctx->data->ipCidrRouteNextHopAS'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric1
 * ipCidrRouteMetric1 is subid 11 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.11
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric1
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteMetric1_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               long ipCidrRouteMetric1)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteMetric1_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric1 data
     *  from 'rowreq_ctx->data->ipCidrRouteMetric1 to 'rowreq_ctx->undo->ipCidrRouteMetric1'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteMetric1
 *        A long containing the new value.
 */
int
ipCidrRouteMetric1_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long ipCidrRouteMetric1)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteMetric1 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteMetric1_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric1 data
     *  from 'rowreq_ctx->undo->ipCidrRouteMetric1 to 'rowreq_ctx->data->ipCidrRouteMetric1'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric2
 * ipCidrRouteMetric2 is subid 12 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.12
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric2
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteMetric2_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               long ipCidrRouteMetric2)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteMetric2_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric2 data
     *  from 'rowreq_ctx->data->ipCidrRouteMetric2 to 'rowreq_ctx->undo->ipCidrRouteMetric2'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteMetric2
 *        A long containing the new value.
 */
int
ipCidrRouteMetric2_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long ipCidrRouteMetric2)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteMetric2 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteMetric2_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric2 data
     *  from 'rowreq_ctx->undo->ipCidrRouteMetric2 to 'rowreq_ctx->data->ipCidrRouteMetric2'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric3
 * ipCidrRouteMetric3 is subid 13 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric3
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteMetric3_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               long ipCidrRouteMetric3)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteMetric3_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric3 data
     *  from 'rowreq_ctx->data->ipCidrRouteMetric3 to 'rowreq_ctx->undo->ipCidrRouteMetric3'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteMetric3
 *        A long containing the new value.
 */
int
ipCidrRouteMetric3_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long ipCidrRouteMetric3)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteMetric3 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteMetric3_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric3 data
     *  from 'rowreq_ctx->undo->ipCidrRouteMetric3 to 'rowreq_ctx->data->ipCidrRouteMetric3'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric4
 * ipCidrRouteMetric4 is subid 14 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric4
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteMetric4_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               long ipCidrRouteMetric4)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteMetric4_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric4 data
     *  from 'rowreq_ctx->data->ipCidrRouteMetric4 to 'rowreq_ctx->undo->ipCidrRouteMetric4'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteMetric4
 *        A long containing the new value.
 */
int
ipCidrRouteMetric4_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long ipCidrRouteMetric4)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteMetric4 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteMetric4_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric4 data
     *  from 'rowreq_ctx->undo->ipCidrRouteMetric4 to 'rowreq_ctx->data->ipCidrRouteMetric4'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteMetric5
 * ipCidrRouteMetric5 is subid 15 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteMetric5
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteMetric5_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               long ipCidrRouteMetric5)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteMetric5_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric5 data
     *  from 'rowreq_ctx->data->ipCidrRouteMetric5 to 'rowreq_ctx->undo->ipCidrRouteMetric5'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteMetric5
 *        A long containing the new value.
 */
int
ipCidrRouteMetric5_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       long ipCidrRouteMetric5)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set ipCidrRouteMetric5 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteMetric5_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteMetric5 data
     *  from 'rowreq_ctx->undo->ipCidrRouteMetric5 to 'rowreq_ctx->data->ipCidrRouteMetric5'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::ipCidrRouteEntry.ipCidrRouteStatus
 * ipCidrRouteStatus is subid 16 of ipCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.4.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipCidrRouteStatus
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ipCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
ipCidrRouteStatus_check_value(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                              u_long ipCidrRouteStatus)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ipCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ipCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ipCidrRouteStatus_undo_setup(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteStatus data
     *  from 'rowreq_ctx->data->ipCidrRouteStatus to 'rowreq_ctx->undo->ipCidrRouteStatus'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ipCidrRouteStatus
 *        A long containing the new value.
 */
int
ipCidrRouteStatus_set(ipCidrRouteTable_rowreq_ctx * rowreq_ctx,
                      u_long ipCidrRouteStatus)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (ipCidrRouteStatus) {
    case ROWSTATUS_ACTIVE:
        ipCidrRouteStatus = INTERNAL_IPCIDRROUTESTATUS_ACTIVE;
        break;

    case ROWSTATUS_NOTINSERVICE:
        ipCidrRouteStatus = INTERNAL_IPCIDRROUTESTATUS_NOTINSERVICE;
        break;

    case ROWSTATUS_NOTREADY:
        ipCidrRouteStatus = INTERNAL_IPCIDRROUTESTATUS_NOTREADY;
        break;

    case ROWSTATUS_CREATEANDGO:
        ipCidrRouteStatus = INTERNAL_IPCIDRROUTESTATUS_CREATEANDGO;
        break;

    case ROWSTATUS_CREATEANDWAIT:
        ipCidrRouteStatus = INTERNAL_IPCIDRROUTESTATUS_CREATEANDWAIT;
        break;

    case ROWSTATUS_DESTROY:
        ipCidrRouteStatus = INTERNAL_IPCIDRROUTESTATUS_DESTROY;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for ipCidrRouteStatus\n",
                 ipCidrRouteStatus);
        return SNMP_ERR_GENERR;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set ipCidrRouteStatus value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ipCidrRouteStatus_undo(ipCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy ipCidrRouteStatus data
     *  from 'rowreq_ctx->undo->ipCidrRouteStatus to 'rowreq_ctx->data->ipCidrRouteStatus'
     */


    return MFD_SUCCESS;
}

/** @} */
/** @{ */
