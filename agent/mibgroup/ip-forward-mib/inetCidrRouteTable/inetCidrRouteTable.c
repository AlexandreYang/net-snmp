/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.17 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for inetCidrRouteTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "inetCidrRouteTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "inetCidrRouteTable_interface.h"

oid             inetCidrRouteTable_oid[] = { INETCIDRROUTETABLE_OID };
int             inetCidrRouteTable_oid_size =
OID_LENGTH(inetCidrRouteTable_oid);

void            initialize_table_inetCidrRouteTable(void);


/**
 * Initializes the inetCidrRouteTable module
 */
void
init_inetCidrRouteTable(void)
{
    DEBUGTRACE;

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("inetCidrRouteTable"))
        initialize_table_inetCidrRouteTable();

}

/**
 * Initialize the table inetCidrRouteTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_inetCidrRouteTable(void)
{
    inetCidrRouteTable_registration_ptr user_context;
    u_long          flags;

    DEBUGTRACE;

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _inetCidrRouteTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
inetCidrRouteTable_pre_request(inetCidrRouteTable_registration_ptr
                               user_context)
{
    DEBUGTRACE;

    /*
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
inetCidrRouteTable_post_request(inetCidrRouteTable_registration_ptr
                                user_context)
{
    DEBUGTRACE;

    /*
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table inetCidrRouteTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetCidrRouteTable is subid 7 of ipForward.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.24.7, length: 9
 */

/*
 * inetCidrRouteTable_allocate_data
 *
 * Purpose: create new inetCidrRouteTable_data.
 */
inetCidrRouteTable_data *
inetCidrRouteTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    /** this might not be right for netsnmp_route_entry */
    inetCidrRouteTable_data *rtn =
        netsnmp_access_route_entry_create();

    DEBUGTRACE;

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "inetCidrRouteTable_data.\n");
    }

    return rtn;
}

/*
 * inetCidrRouteTable_allocate_data
 *
 * Purpose: release data data.
 */
void
inetCidrRouteTable_release_data(inetCidrRouteTable_data * data)
{
    DEBUGTRACE;

    /*
     * release memory for the context
     */
    netsnmp_access_route_entry_free(data);
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDestType
 * inetCidrRouteDestType is subid 1 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.1
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDestType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-inetCidrRouteDestType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
inetCidrRouteDestType_map(u_long * mib_inetCidrRouteDestType_ptr,
                          u_long raw_inetCidrRouteDestType)
{
    netsnmp_assert(NULL != mib_inetCidrRouteDestType_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_inetCidrRouteDestType) {
    case INTERNAL_INETCIDRROUTEDESTTYPE_UNKNOWN:
        *mib_inetCidrRouteDestType_ptr = INETADDRESSTYPE_UNKNOWN;
        break;

    case INTERNAL_INETCIDRROUTEDESTTYPE_IPV4:
        *mib_inetCidrRouteDestType_ptr = INETADDRESSTYPE_IPV4;
        break;

    case INTERNAL_INETCIDRROUTEDESTTYPE_IPV6:
        *mib_inetCidrRouteDestType_ptr = INETADDRESSTYPE_IPV6;
        break;

    case INTERNAL_INETCIDRROUTEDESTTYPE_IPV4Z:
        *mib_inetCidrRouteDestType_ptr = INETADDRESSTYPE_IPV4Z;
        break;

    case INTERNAL_INETCIDRROUTEDESTTYPE_IPV6Z:
        *mib_inetCidrRouteDestType_ptr = INETADDRESSTYPE_IPV6Z;
        break;

    case INTERNAL_INETCIDRROUTEDESTTYPE_DNS:
        *mib_inetCidrRouteDestType_ptr = INETADDRESSTYPE_DNS;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't map value %d for inetCidrRouteDestType\n",
                 raw_inetCidrRouteDestType);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopType
 * inetCidrRouteNextHopType is subid 5 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.5
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHopType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-inetCidrRouteNextHopType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
inetCidrRouteNextHopType_map(u_long * mib_inetCidrRouteNextHopType_ptr,
                             u_long raw_inetCidrRouteNextHopType)
{
    netsnmp_assert(NULL != mib_inetCidrRouteNextHopType_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_inetCidrRouteNextHopType) {
    case INTERNAL_INETCIDRROUTENEXTHOPTYPE_UNKNOWN:
        *mib_inetCidrRouteNextHopType_ptr = INETADDRESSTYPE_UNKNOWN;
        break;

    case INTERNAL_INETCIDRROUTENEXTHOPTYPE_IPV4:
        *mib_inetCidrRouteNextHopType_ptr = INETADDRESSTYPE_IPV4;
        break;

    case INTERNAL_INETCIDRROUTENEXTHOPTYPE_IPV6:
        *mib_inetCidrRouteNextHopType_ptr = INETADDRESSTYPE_IPV6;
        break;

    case INTERNAL_INETCIDRROUTENEXTHOPTYPE_IPV4Z:
        *mib_inetCidrRouteNextHopType_ptr = INETADDRESSTYPE_IPV4Z;
        break;

    case INTERNAL_INETCIDRROUTENEXTHOPTYPE_IPV6Z:
        *mib_inetCidrRouteNextHopType_ptr = INETADDRESSTYPE_IPV6Z;
        break;

    case INTERNAL_INETCIDRROUTENEXTHOPTYPE_DNS:
        *mib_inetCidrRouteNextHopType_ptr = INETADDRESSTYPE_DNS;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't map value %d for inetCidrRouteNextHopType\n",
                 raw_inetCidrRouteNextHopType);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values are
 *  native/rawformat, and the mapping function is called (or suggested) when
 *  necessary.
 */
int
inetCidrRouteTable_indexes_set_tbl_idx(inetCidrRouteTable_mib_index *
                                       tbl_idx,
                                       u_long inetCidrRouteDestType,
                                       char *inetCidrRouteDest_ptr,
                                       size_t inetCidrRouteDest_ptr_len,
                                       u_long inetCidrRoutePfxLen,
                                       oid * inetCidrRoutePolicy_ptr,
                                       size_t inetCidrRoutePolicy_ptr_len,
                                       u_long inetCidrRouteNextHopType,
                                       char *inetCidrRouteNextHop_ptr,
                                       size_t inetCidrRouteNextHop_ptr_len)
{
    DEBUGTRACE;

    /*
     * inetCidrRouteDestType(1)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    tbl_idx->inetCidrRouteDestType = inetCidrRouteDestType;

    /*
     * inetCidrRouteDest(2)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    tbl_idx->inetCidrRouteDest_len = inetCidrRouteDest_ptr_len;
    memcpy(tbl_idx->inetCidrRouteDest, inetCidrRouteDest_ptr,
           tbl_idx->inetCidrRouteDest_len *
           sizeof(tbl_idx->inetCidrRouteDest[0]));

    /*
     * inetCidrRoutePfxLen(3)/InetAddressPrefixLength/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/r/d/h 
     */
    tbl_idx->inetCidrRoutePfxLen = inetCidrRoutePfxLen;

    /*
     * inetCidrRoutePolicy(4)/OBJECTID/ASN_OBJECT_ID/oid(oid)//L/a/w/e/r/d/h 
     */
    if ((sizeof(tbl_idx->inetCidrRoutePolicy_len) < inetCidrRoutePolicy_ptr_len)) {
        return MFD_ERROR;
    }
    if (0 != inetCidrRoutePolicy_ptr_len)
        tbl_idx->inetCidrRoutePolicy_len = inetCidrRoutePolicy_ptr_len;
    else {
        tbl_idx->inetCidrRoutePolicy_len = nullOidLen / sizeof(oid);
        inetCidrRoutePolicy_ptr = nullOid;
    }
    memcpy(tbl_idx->inetCidrRoutePolicy, inetCidrRoutePolicy_ptr,
           tbl_idx->inetCidrRoutePolicy_len *
           sizeof(tbl_idx->inetCidrRoutePolicy[0]));

    /*
     * inetCidrRouteNextHopType(5)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    tbl_idx->inetCidrRouteNextHopType = inetCidrRouteNextHopType;

    /*
     * inetCidrRouteNextHop(6)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    tbl_idx->inetCidrRouteNextHop_len = inetCidrRouteNextHop_ptr_len;
    memcpy(tbl_idx->inetCidrRouteNextHop, inetCidrRouteNextHop_ptr,
           tbl_idx->inetCidrRouteNextHop_len *
           sizeof(tbl_idx->inetCidrRouteNextHop[0]));


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
inetCidrRouteTable_indexes_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               u_long inetCidrRouteDestType,
                               char *inetCidrRouteDest_ptr,
                               size_t inetCidrRouteDest_ptr_len,
                               u_long inetCidrRoutePfxLen,
                               oid * inetCidrRoutePolicy_ptr,
                               size_t inetCidrRoutePolicy_ptr_len,
                               u_long inetCidrRouteNextHopType,
                               char *inetCidrRouteNextHop_ptr,
                               size_t inetCidrRouteNextHop_ptr_len)
{
    if (MFD_SUCCESS !=
        inetCidrRouteTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                               inetCidrRouteDestType,
                                               inetCidrRouteDest_ptr,
                                               inetCidrRouteDest_ptr_len,
                                               inetCidrRoutePfxLen,
                                               inetCidrRoutePolicy_ptr,
                                               inetCidrRoutePolicy_ptr_len,
                                               inetCidrRouteNextHopType,
                                               inetCidrRouteNextHop_ptr,
                                               inetCidrRouteNextHop_ptr_len))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != inetCidrRouteTable_index_to_oid(&rowreq_ctx->oid_idx,
                                             &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteIfIndex
 * inetCidrRouteIfIndex is subid 7 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: d
 *
 * Ranges:  1 - 2147483647;
 *
 * It's syntax is InterfaceIndex (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteIfIndex data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteIfIndex_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteIfIndex_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteIfIndex_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteIfIndex_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteIfIndex_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteIfIndex_ptr ) = rowreq_ctx->data->if_index;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteType
 * inetCidrRouteType is subid 8 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.8
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  other(1), reject(2), local(3), remote(4), blackhole(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-inetCidrRouteType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
inetCidrRouteType_map(u_long * mib_inetCidrRouteType_ptr,
                      u_long raw_inetCidrRouteType)
{
    netsnmp_assert(NULL != mib_inetCidrRouteType_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_inetCidrRouteType) {
    case INTERNAL_INETCIDRROUTETYPE_OTHER:
        *mib_inetCidrRouteType_ptr = INETCIDRROUTETYPE_OTHER;
        break;

    case INTERNAL_INETCIDRROUTETYPE_REJECT:
        *mib_inetCidrRouteType_ptr = INETCIDRROUTETYPE_REJECT;
        break;

    case INTERNAL_INETCIDRROUTETYPE_LOCAL:
        *mib_inetCidrRouteType_ptr = INETCIDRROUTETYPE_LOCAL;
        break;

    case INTERNAL_INETCIDRROUTETYPE_REMOTE:
        *mib_inetCidrRouteType_ptr = INETCIDRROUTETYPE_REMOTE;
        break;

    case INTERNAL_INETCIDRROUTETYPE_BLACKHOLE:
        *mib_inetCidrRouteType_ptr = INETCIDRROUTETYPE_BLACKHOLE;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for inetCidrRouteType\n",
                 raw_inetCidrRouteType);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the inetCidrRouteType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteType_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteType_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                      u_long * inetCidrRouteType_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteType_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteType_ptr ) from rowreq_ctx->data->
     */
    /*
     * value mapping
     */
    if (MFD_SUCCESS !=
        inetCidrRouteType_map(&(*inetCidrRouteType_ptr),
                              rowreq_ctx->data->rt_type)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteProto
 * inetCidrRouteProto is subid 9 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.7.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 13/32. Values:  other(1), local(2), netmgmt(3), icmp(4), egp(5), ggp(6), hello(7), rip(8), isIs(9), esIs(10), ciscoIgrp(11), bbnSpfIgp(12), ospf(13), bgp(14), idpr(15), ciscoEigrp(16), dvmrp(17)
 *
 * It's syntax is IANAipRouteProtocol (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-inetCidrRouteProto.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
inetCidrRouteProto_map(u_long * mib_inetCidrRouteProto_ptr,
                       u_long raw_inetCidrRouteProto)
{
    netsnmp_assert(NULL != mib_inetCidrRouteProto_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_inetCidrRouteProto) {
    case INTERNAL_INETCIDRROUTEPROTO_OTHER:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_OTHER;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_LOCAL:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_LOCAL;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_NETMGMT:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_NETMGMT;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_ICMP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_ICMP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_EGP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_EGP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_GGP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_GGP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_HELLO:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_HELLO;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_RIP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_RIP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_ISIS:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_ISIS;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_ESIS:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_ESIS;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_CISCOIGRP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_CISCOIGRP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_BBNSPFIGP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_BBNSPFIGP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_OSPF:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_OSPF;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_BGP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_BGP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_IDPR:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_IDPR;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_CISCOEIGRP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_CISCOEIGRP;
        break;

    case INTERNAL_INETCIDRROUTEPROTO_DVMRP:
        *mib_inetCidrRouteProto_ptr = IANAIPROUTEPROTOCOL_DVMRP;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for inetCidrRouteProto\n",
                 raw_inetCidrRouteProto);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the inetCidrRouteProto data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteProto_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteProto_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       u_long * inetCidrRouteProto_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteProto_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteProto_ptr ) from rowreq_ctx->data->
     */
    /*
     * value mapping
     */
    if (MFD_SUCCESS !=
        inetCidrRouteProto_map(&(*inetCidrRouteProto_ptr),
                               rowreq_ctx->data->rt_proto)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteAge
 * inetCidrRouteAge is subid 10 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.7.1.10
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteAge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteAge_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteAge_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                     u_long * inetCidrRouteAge_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteAge_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteAge_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteAge_ptr ) = rowreq_ctx->data->rt_age;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopAS
 * inetCidrRouteNextHopAS is subid 11 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.11
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 0
 *
 *
 * It's syntax is InetAutonomousSystemNumber (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteNextHopAS data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteNextHopAS_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteNextHopAS_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                           u_long * inetCidrRouteNextHopAS_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteNextHopAS_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteNextHopAS_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteNextHopAS_ptr ) = rowreq_ctx->data->rt_nexthop_as;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric1
 * inetCidrRouteMetric1 is subid 12 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.12
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric1 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric1_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric1_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric1_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric1_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteMetric1_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric1_ptr ) = rowreq_ctx->data->rt_metric1;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric2
 * inetCidrRouteMetric2 is subid 13 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric2 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric2_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric2_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric2_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric2_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteMetric2_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric2_ptr ) = rowreq_ctx->data->rt_metric2;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric3
 * inetCidrRouteMetric3 is subid 14 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric3 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric3_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric3_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric3_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric3_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteMetric3_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric3_ptr ) = rowreq_ctx->data->rt_metric3;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric4
 * inetCidrRouteMetric4 is subid 15 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric4 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric4_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric4_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric4_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric4_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteMetric4_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric4_ptr ) = rowreq_ctx->data->rt_metric4;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric5
 * inetCidrRouteMetric5 is subid 16 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric5 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric5_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric5_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric5_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric5_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * set (* inetCidrRouteMetric5_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric5_ptr ) = rowreq_ctx->data->rt_metric5;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteStatus
 * inetCidrRouteStatus is subid 17 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.17
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-inetCidrRouteStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
inetCidrRouteStatus_map(u_long * mib_inetCidrRouteStatus_ptr,
                        u_long raw_inetCidrRouteStatus)
{
    netsnmp_assert(NULL != mib_inetCidrRouteStatus_ptr);

    DEBUGTRACE;

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_inetCidrRouteStatus) {
    case INTERNAL_INETCIDRROUTESTATUS_ACTIVE:
        *mib_inetCidrRouteStatus_ptr = ROWSTATUS_ACTIVE;
        break;

    case INTERNAL_INETCIDRROUTESTATUS_NOTINSERVICE:
        *mib_inetCidrRouteStatus_ptr = ROWSTATUS_NOTINSERVICE;
        break;

    case INTERNAL_INETCIDRROUTESTATUS_NOTREADY:
        *mib_inetCidrRouteStatus_ptr = ROWSTATUS_NOTREADY;
        break;

    case INTERNAL_INETCIDRROUTESTATUS_CREATEANDGO:
        *mib_inetCidrRouteStatus_ptr = ROWSTATUS_CREATEANDGO;
        break;

    case INTERNAL_INETCIDRROUTESTATUS_CREATEANDWAIT:
        *mib_inetCidrRouteStatus_ptr = ROWSTATUS_CREATEANDWAIT;
        break;

    case INTERNAL_INETCIDRROUTESTATUS_DESTROY:
        *mib_inetCidrRouteStatus_ptr = ROWSTATUS_DESTROY;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't map value %d for inetCidrRouteStatus\n",
                 raw_inetCidrRouteStatus);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the inetCidrRouteStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteStatus_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteStatus_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                        u_long * inetCidrRouteStatus_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteStatus_ptr);

    /*
     * update, replace or delete, if needed.
     */
    (*inetCidrRouteStatus_ptr) = ROWSTATUS_ACTIVE;

    return MFD_SUCCESS;
}



/** @} */
/**********************************************************************
 **********************************************************************
 ***
 *** Table inetCidrRouteTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetCidrRouteTable is subid 7 of ipForward.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.24.7, length: 9
 */
/**
 * create new data context, if specified index is valid.
 *
 * @param inetCidrRouteTable_reg
 *        Pointer to the user registration data
 * @param inetCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS   : success
 * @retval MFD_BAD_VALUE : index not valid
 */
int
inetCidrRouteTable_validate_index(inetCidrRouteTable_registration_ptr
                                  inetCidrRouteTable_reg,
                                  inetCidrRouteTable_rowreq_ctx *
                                  rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * Validate incoming index
     *
     * Check that the values specified in the incoming index are valid
     * values. All of the individual index component functions have been
     * called, so this is the place to make sure they are valid as
     * a whole when combined.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * TODO:
     * update this code or row creation won't work
     */
    if (1) {
        snmp_log(LOG_WARNING, "invalid index for a new row in the "
                 "inetCidrRouteTable table.\n");
        /*
         * TODO:
         * determine failure type.
         *
         * If the index could not ever be created, SNMP_ERR_NOCREATION.
         * If the index can not be created under the  present circumstances
         * (even though it could be created under other circumstances),
         * SNMP_ERR_INCONSISTENTNAME.
         */
        if (0) {
            return SNMP_ERR_NOCREATION;
        } else {
            return SNMP_ERR_INCONSISTENTNAME;
        }
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return rc;
}

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
inetCidrRouteTable_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * commit new valies.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * @param inetCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetCidrRouteTable_commit(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGTRACE;

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * commit data
     */

    return rc;
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDestType
 * inetCidrRouteDestType is subid 1 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.1
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDestType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteDestType index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteDestType_check_index(inetCidrRouteTable_rowreq_ctx *
                                  rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteDestType is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDest
 * inetCidrRouteDest is subid 2 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.2
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDest IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteDest index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteDest_check_index(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteDest is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRoutePfxLen
 * inetCidrRoutePfxLen is subid 3 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.3
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is InetAddressPrefixLength (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRoutePfxLen IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRoutePfxLen index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRoutePfxLen_check_index(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRoutePfxLen is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRoutePolicy
 * inetCidrRoutePolicy is subid 4 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.4
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRoutePolicy IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRoutePolicy index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRoutePolicy_check_index(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRoutePolicy is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopType
 * inetCidrRouteNextHopType is subid 5 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.5
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHopType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteNextHopType index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteNextHopType_check_index(inetCidrRouteTable_rowreq_ctx *
                                     rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteNextHopType is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHop
 * inetCidrRouteNextHop is subid 6 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.6
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHop IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteNextHop index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteNextHop_check_index(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteNextHop is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteIfIndex
 * inetCidrRouteIfIndex is subid 7 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: d
 *
 * Ranges:  1 - 2147483647;
 *
 * It's syntax is InterfaceIndex (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteIfIndex
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 2147483647
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteIfIndex_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteIfIndex)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteIfIndex_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteIfIndex data
     *  from 'rowreq_ctx->data->rt_IfIndex to 'rowreq_ctx->undo->rt_IfIndex'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteIfIndex
 *        A long containing the new value.
 */
int
inetCidrRouteIfIndex_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteIfIndex)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteIfIndex value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteIfIndex_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteIfIndex data
     *  from 'rowreq_ctx->undo->rt_IfIndex to 'rowreq_ctx->data->rt_IfIndex'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteType
 * inetCidrRouteType is subid 8 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.8
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  other(1), reject(2), local(3), remote(4), blackhole(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteType
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), reject(2), local(3), remote(4), blackhole(5)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteType_check_value(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                              u_long inetCidrRouteType)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteType_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteType data
     *  from 'rowreq_ctx->data->rt_Type to 'rowreq_ctx->undo->rt_Type'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteType
 *        A long containing the new value.
 */
int
inetCidrRouteType_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                      u_long inetCidrRouteType)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (inetCidrRouteType) {
    case INETCIDRROUTETYPE_OTHER:
        inetCidrRouteType = INTERNAL_INETCIDRROUTETYPE_OTHER;
        break;

    case INETCIDRROUTETYPE_REJECT:
        inetCidrRouteType = INTERNAL_INETCIDRROUTETYPE_REJECT;
        break;

    case INETCIDRROUTETYPE_LOCAL:
        inetCidrRouteType = INTERNAL_INETCIDRROUTETYPE_LOCAL;
        break;

    case INETCIDRROUTETYPE_REMOTE:
        inetCidrRouteType = INTERNAL_INETCIDRROUTETYPE_REMOTE;
        break;

    case INETCIDRROUTETYPE_BLACKHOLE:
        inetCidrRouteType = INTERNAL_INETCIDRROUTETYPE_BLACKHOLE;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for inetCidrRouteType\n",
                 inetCidrRouteType);
        return SNMP_ERR_GENERR;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set inetCidrRouteType value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteType_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteType data
     *  from 'rowreq_ctx->undo->rt_Type to 'rowreq_ctx->data->rt_Type'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopAS
 * inetCidrRouteNextHopAS is subid 11 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.11
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: 0
 *
 *
 * It's syntax is InetAutonomousSystemNumber (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteNextHopAS
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteNextHopAS_check_value(inetCidrRouteTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long inetCidrRouteNextHopAS)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteNextHopAS_undo_setup(inetCidrRouteTable_rowreq_ctx *
                                  rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteNextHopAS data
     *  from 'rowreq_ctx->data->rt_NextHopAS to 'rowreq_ctx->undo->rt_NextHopAS'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteNextHopAS
 *        A u_long containing the new value.
 */
int
inetCidrRouteNextHopAS_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                           u_long inetCidrRouteNextHopAS)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteNextHopAS value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteNextHopAS_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteNextHopAS data
     *  from 'rowreq_ctx->undo->rt_NextHopAS to 'rowreq_ctx->data->rt_NextHopAS'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric1
 * inetCidrRouteMetric1 is subid 12 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.12
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric1
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteMetric1_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric1)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric1_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric1 data
     *  from 'rowreq_ctx->data->rt_Metric1 to 'rowreq_ctx->undo->rt_Metric1'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric1
 *        A long containing the new value.
 */
int
inetCidrRouteMetric1_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric1)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteMetric1 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric1_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric1 data
     *  from 'rowreq_ctx->undo->rt_Metric1 to 'rowreq_ctx->data->rt_Metric1'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric2
 * inetCidrRouteMetric2 is subid 13 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric2
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteMetric2_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric2)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric2_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric2 data
     *  from 'rowreq_ctx->data->rt_Metric2 to 'rowreq_ctx->undo->rt_Metric2'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric2
 *        A long containing the new value.
 */
int
inetCidrRouteMetric2_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric2)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteMetric2 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric2_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric2 data
     *  from 'rowreq_ctx->undo->rt_Metric2 to 'rowreq_ctx->data->rt_Metric2'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric3
 * inetCidrRouteMetric3 is subid 14 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric3
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteMetric3_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric3)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric3_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric3 data
     *  from 'rowreq_ctx->data->rt_Metric3 to 'rowreq_ctx->undo->rt_Metric3'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric3
 *        A long containing the new value.
 */
int
inetCidrRouteMetric3_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric3)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteMetric3 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric3_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric3 data
     *  from 'rowreq_ctx->undo->rt_Metric3 to 'rowreq_ctx->data->rt_Metric3'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric4
 * inetCidrRouteMetric4 is subid 15 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric4
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteMetric4_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric4)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric4_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric4 data
     *  from 'rowreq_ctx->data->rt_Metric4 to 'rowreq_ctx->undo->rt_Metric4'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric4
 *        A long containing the new value.
 */
int
inetCidrRouteMetric4_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric4)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteMetric4 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric4_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric4 data
     *  from 'rowreq_ctx->undo->rt_Metric4 to 'rowreq_ctx->data->rt_Metric4'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric5
 * inetCidrRouteMetric5 is subid 16 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric5
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteMetric5_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric5)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric5_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric5 data
     *  from 'rowreq_ctx->data->rt_Metric5 to 'rowreq_ctx->undo->rt_Metric5'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric5
 *        A long containing the new value.
 */
int
inetCidrRouteMetric5_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric5)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteMetric5 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric5_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteMetric5 data
     *  from 'rowreq_ctx->undo->rt_Metric5 to 'rowreq_ctx->data->rt_Metric5'
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteStatus
 * inetCidrRouteStatus is subid 17 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.17
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteStatus
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS : incoming value is legal
 * @retval MFD_ERROR   : incoming value is NOT legal
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here.
 *
 */
int
inetCidrRouteStatus_check_value(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                                u_long inetCidrRouteStatus)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteStatus_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGTRACE;

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteStatus data
     *  from 'rowreq_ctx->data->rt_Status to 'rowreq_ctx->undo->rt_Status'
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteStatus
 *        A long containing the new value.
 */
int
inetCidrRouteStatus_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                        u_long inetCidrRouteStatus)
{
    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    switch (inetCidrRouteStatus) {
    case ROWSTATUS_ACTIVE:
        inetCidrRouteStatus = INTERNAL_INETCIDRROUTESTATUS_ACTIVE;
        break;

    case ROWSTATUS_NOTINSERVICE:
        inetCidrRouteStatus = INTERNAL_INETCIDRROUTESTATUS_NOTINSERVICE;
        break;

    case ROWSTATUS_NOTREADY:
        inetCidrRouteStatus = INTERNAL_INETCIDRROUTESTATUS_NOTREADY;
        break;

    case ROWSTATUS_CREATEANDGO:
        inetCidrRouteStatus = INTERNAL_INETCIDRROUTESTATUS_CREATEANDGO;
        break;

    case ROWSTATUS_CREATEANDWAIT:
        inetCidrRouteStatus = INTERNAL_INETCIDRROUTESTATUS_CREATEANDWAIT;
        break;

    case ROWSTATUS_DESTROY:
        inetCidrRouteStatus = INTERNAL_INETCIDRROUTESTATUS_DESTROY;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for inetCidrRouteStatus\n",
                 inetCidrRouteStatus);
        return SNMP_ERR_GENERR;
    }
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * TODO:
     * set inetCidrRouteStatus value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteStatus_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * copy inetCidrRouteStatus data
     *  from 'rowreq_ctx->undo->rt_Status to 'rowreq_ctx->data->rt_Status'
     */


    return MFD_SUCCESS;
}

/** @} */
/** @{ */
