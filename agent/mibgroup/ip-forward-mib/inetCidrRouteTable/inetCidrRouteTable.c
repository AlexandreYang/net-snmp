/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.25 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for inetCidrRouteTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "inetCidrRouteTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "inetCidrRouteTable_interface.h"

oid             inetCidrRouteTable_oid[] = { INETCIDRROUTETABLE_OID };
int             inetCidrRouteTable_oid_size =
OID_LENGTH(inetCidrRouteTable_oid);

void            initialize_table_inetCidrRouteTable(void);


/**
 * Initializes the inetCidrRouteTable module
 */
void
init_inetCidrRouteTable(void)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:init_inetCidrRouteTable",
                "called\n"));

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("inetCidrRouteTable"))
        initialize_table_inetCidrRouteTable();

}

/**
 * Initialize the table inetCidrRouteTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_inetCidrRouteTable(void)
{
    inetCidrRouteTable_registration_ptr user_context;
    u_long          flags;

    DEBUGMSGTL(("verbose:inetCidrRouteTable:initialize_table_inetCidrRouteTable", "called\n"));

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _inetCidrRouteTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
inetCidrRouteTable_pre_request(inetCidrRouteTable_registration_ptr
                               user_context)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable_pre_request", "called\n"));

    /*
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
inetCidrRouteTable_post_request(inetCidrRouteTable_registration_ptr
                                user_context)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable_post_request", "called\n"));

    /*
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table inetCidrRouteTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetCidrRouteTable is subid 7 of ipForward.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.24.7, length: 9
 */

/*
 * inetCidrRouteTable_allocate_data
 *
 * Purpose: create new inetCidrRouteTable_data.
 */
inetCidrRouteTable_data *
inetCidrRouteTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    inetCidrRouteTable_data *rtn =
        netsnmp_access_route_entry_create();

    DEBUGMSGTL(("verbose:inetCidrRouteTable_allocate_data", "called\n"));

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "inetCidrRouteTable_data.\n");
    }

    return rtn;
}

/*
 * inetCidrRouteTable_release_data
 *
 * Purpose: release inetCidrRouteTable data.
 */
void
inetCidrRouteTable_release_data(inetCidrRouteTable_data * data)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable_release_data", "called\n"));

    /*
     * release memory for the context
     */
    netsnmp_access_route_entry_free(data);
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDestType
 * inetCidrRouteDestType is subid 1 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.1
 * Description:
The type of the inetCidrRouteDest address, as defined  
                in the InetAddress MIB. 

                Only those address types that may appear in an actual 
                routing table are allowed as values of this object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDestType IS NOT ACCESSIBLE
 *
 *
 */

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDest
 * inetCidrRouteDest is subid 2 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.2
 * Description:
The destination IP address of this route. 

                The type of this address is determined by the value of 
                the inetCidrRouteDestType object. 

                The values for the index objects inetCidrRouteDest and 
                inetCidrRoutePfxLen must be consistent.  When the value 
                of inetCidrRouteDest (excluding the zone index, if one 
                is present) is x, then the bitwise logical-AND 
                of x with the value of the mask formed from the 
                corresponding index object inetCidrRoutePfxLen MUST be 
                equal to x.  If not, then the index pair is not 
                consistent and an inconsistentName error must be 
                returned on SET or CREATE requests.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDest IS NOT ACCESSIBLE
 *
 *
 */
/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRoutePfxLen
 * inetCidrRoutePfxLen is subid 3 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.3
 * Description:
Indicates the number of leading one bits which form the  
                mask to be logical-ANDed with the destination address  
                before being compared to the value in the 
                inetCidrRouteDest field. 

                The values for the index objects inetCidrRouteDest and 
                inetCidrRoutePfxLen must be consistent.  When the value 
                of inetCidrRouteDest (excluding the zone index, if one 
                is present) is x, then the bitwise logical-AND 
                of x with the value of the mask formed from the 
                corresponding index object inetCidrRoutePfxLen MUST be 
                equal to x.  If not, then the index pair is not 
                consistent and an inconsistentName error must be 
                returned on SET or CREATE requests.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  0 - 2040;
 *
 * It's syntax is InetAddressPrefixLength (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRoutePfxLen IS NOT ACCESSIBLE
 *
 *
 */

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRoutePolicy
 * inetCidrRoutePolicy is subid 4 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.4
 * Description:
This object is an opaque object without any defined 
                semantics.  Its purpose is to serve as an additional 
                index which may delineate between multiple entries to 
                the same destination.  The value { 0 0 } shall be used 
                as the default value for this object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max 2040)
 *
 *
 *
 * NOTE: NODE inetCidrRoutePolicy IS NOT ACCESSIBLE
 *
 *
 */
/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopType
 * inetCidrRouteNextHopType is subid 5 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.5
 * Description:
The type of the inetCidrRouteNextHop address, as  
                defined in the InetAddress MIB. 

                Value should be set to unknown(0) for non-remote  
                routes. 

                Only those address types that may appear in an actual 
                routing table are allowed as values of this object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHopType IS NOT ACCESSIBLE
 *
 *
 */
/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHop
 * inetCidrRouteNextHop is subid 6 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.6
 * Description:
On remote routes, the address of the next system en              
                route.  For non-remote routes, a zero length string. 

                The type of this address is determined by the value of 
                the inetCidrRouteNextHopType object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHop IS NOT ACCESSIBLE
 *
 *
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
inetCidrRouteTable_indexes_set_tbl_idx(inetCidrRouteTable_mib_index *
                                       tbl_idx,
                                       u_long inetCidrRouteDestType_val,
                                       char *inetCidrRouteDest_val_ptr,
                                       size_t
                                       inetCidrRouteDest_val_ptr_len,
                                       u_long inetCidrRoutePfxLen_val,
                                       oid * inetCidrRoutePolicy_val_ptr,
                                       size_t
                                       inetCidrRoutePolicy_val_ptr_len,
                                       u_long inetCidrRouteNextHopType_val,
                                       char *inetCidrRouteNextHop_val_ptr,
                                       size_t
                                       inetCidrRouteNextHop_val_ptr_len)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * inetCidrRouteDestType(1)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->inetCidrRouteDestType = inetCidrRouteDestType_val;

    /*
     * inetCidrRouteDest(2)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    tbl_idx->inetCidrRouteDest_len = sizeof(tbl_idx->inetCidrRouteDest);
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    /*
     * make sure there is enough space for data
     */
    if (tbl_idx->inetCidrRouteDest_len < inetCidrRouteDest_val_ptr_len) {
        snmp_log(LOG_ERR, "not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->inetCidrRouteDest_len = inetCidrRouteDest_val_ptr_len;
    memcpy(tbl_idx->inetCidrRouteDest, inetCidrRouteDest_val_ptr,
           tbl_idx->inetCidrRouteDest_len *
           sizeof(tbl_idx->inetCidrRouteDest[0]));

    /*
     * inetCidrRoutePfxLen(3)/InetAddressPrefixLength/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/H 
     */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->inetCidrRoutePfxLen = inetCidrRoutePfxLen_val;

    /*
     * inetCidrRoutePolicy(4)/OBJECTID/ASN_OBJECT_ID/oid(oid)//L/a/w/e/r/d/h 
     */
    tbl_idx->inetCidrRoutePolicy_len =
        sizeof(tbl_idx->inetCidrRoutePolicy);
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    /*
     * make sure there is enough space for data
     */
    if (tbl_idx->inetCidrRoutePolicy_len <
            inetCidrRoutePolicy_val_ptr_len) {
        snmp_log(LOG_ERR, "not enough space for value\n");
        return MFD_ERROR;
    }
    if (0 != inetCidrRoutePolicy_val_ptr_len)
        tbl_idx->inetCidrRoutePolicy_len = inetCidrRoutePolicy_val_ptr_len;
    else {
        tbl_idx->inetCidrRoutePolicy_len = nullOidLen / sizeof(oid);
        inetCidrRoutePolicy_val_ptr = nullOid;
    }
    memcpy(tbl_idx->inetCidrRoutePolicy, inetCidrRoutePolicy_val_ptr,
           tbl_idx->inetCidrRoutePolicy_len *
           sizeof(tbl_idx->inetCidrRoutePolicy[0]));

    /*
     * inetCidrRouteNextHopType(5)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->inetCidrRouteNextHopType = inetCidrRouteNextHopType_val;

    /*
     * inetCidrRouteNextHop(6)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    tbl_idx->inetCidrRouteNextHop_len =
        sizeof(tbl_idx->inetCidrRouteNextHop);
    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    /*
     * make sure there is enough space for data
     */
    if ((NULL == tbl_idx->inetCidrRouteNextHop)
        || (tbl_idx->inetCidrRouteNextHop_len <
            inetCidrRouteNextHop_val_ptr_len)) {
        snmp_log(LOG_ERR, "not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->inetCidrRouteNextHop_len = inetCidrRouteNextHop_val_ptr_len;
    memcpy(tbl_idx->inetCidrRouteNextHop, inetCidrRouteNextHop_val_ptr,
           tbl_idx->inetCidrRouteNextHop_len *
           sizeof(tbl_idx->inetCidrRouteNextHop[0]));


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
inetCidrRouteTable_indexes_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                               u_long inetCidrRouteDestType_val,
                               char *inetCidrRouteDest_val_ptr,
                               size_t inetCidrRouteDest_val_ptr_len,
                               u_long inetCidrRoutePfxLen_val,
                               oid * inetCidrRoutePolicy_val_ptr,
                               size_t inetCidrRoutePolicy_val_ptr_len,
                               u_long inetCidrRouteNextHopType_val,
                               char *inetCidrRouteNextHop_val_ptr,
                               size_t inetCidrRouteNextHop_val_ptr_len)
{
    if (MFD_SUCCESS !=
        inetCidrRouteTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                               inetCidrRouteDestType_val,
                                               inetCidrRouteDest_val_ptr,
                                               inetCidrRouteDest_val_ptr_len,
                                               inetCidrRoutePfxLen_val,
                                               inetCidrRoutePolicy_val_ptr,
                                               inetCidrRoutePolicy_val_ptr_len,
                                               inetCidrRouteNextHopType_val,
                                               inetCidrRouteNextHop_val_ptr,
                                               inetCidrRouteNextHop_val_ptr_len))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != inetCidrRouteTable_index_to_oid(&rowreq_ctx->oid_idx,
                                             &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteIfIndex
 * inetCidrRouteIfIndex is subid 7 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.7
 * Description:
The ifIndex value which identifies the local interface 
                through which the next hop of this route should be  
                reached.  A value of 0 is valid and represents the 
                scenario where no interface is specified.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: d
 *
 * Ranges:  0 - 2147483647;
 *
 * It's syntax is InterfaceIndexOrZero (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteIfIndex data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteIfIndex_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteIfIndex_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteIfIndex_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteIfIndex_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteIfIndex_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteIfIndex_val_ptr ) = rowreq_ctx->data->if_index;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteType
 * inetCidrRouteType is subid 8 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.8
 * Description:
The type of route.  Note that local(3) refers to a  
                route for which the next hop is the final destination;  
                remote(4)refers to a route for which the next hop is  
                not the final destination. 

                Routes which do not result in traffic forwarding or 
                rejection should not be displayed even if the  
                implementation keeps them stored internally. 

                reject(2) refers to a route which, if matched, discards  
                the message as unreachable and returns a notification  
                (e.g. ICMP error) to the message sender.  This is used  
                in some protocols as a means of correctly aggregating  
                routes. 

                blackhole(5) refers to a route which, if matched,  
                discards the message silently.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  other(1), reject(2), local(3), remote(4), blackhole(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteType_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                      u_long * inetCidrRouteType_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteType_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteType_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteType_val_ptr ) =  rowreq_ctx->data->rt_type;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteProto
 * inetCidrRouteProto is subid 9 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.7.1.9
 * Description:
The routing mechanism via which this route was learned. 
                Inclusion of values for gateway routing protocols is  
                not intended to imply that hosts should support those 
                protocols.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 13/32. Values:  other(1), local(2), netmgmt(3), icmp(4), egp(5), ggp(6), hello(7), rip(8), isIs(9), esIs(10), ciscoIgrp(11), bbnSpfIgp(12), ospf(13), bgp(14), idpr(15), ciscoEigrp(16), dvmrp(17)
 *
 * It's syntax is IANAipRouteProtocol (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteProto data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteProto_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteProto_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                       u_long * inetCidrRouteProto_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteProto_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteProto_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteProto_val_ptr ) =
        rowreq_ctx->data->rt_proto;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteAge
 * inetCidrRouteAge is subid 10 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.24.7.1.10
 * Description:
The number of seconds since this route was last updated  
                or otherwise determined to be correct.  Note that no  
                semantics of 'too old' can be implied except through  
                knowledge of the routing protocol by which the route  
                was learned.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteAge data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteAge_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteAge_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                     u_long * inetCidrRouteAge_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteAge_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteAge_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteAge_val_ptr ) = rowreq_ctx->data->rt_age;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopAS
 * inetCidrRouteNextHopAS is subid 11 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.11
 * Description:
The Autonomous System Number of the Next Hop.  The  
                semantics of this object are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value. When this object is unknown or not relevant its  
                value should be set to zero.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   defval: 0
 *   hint: d
 *
 *
 * It's syntax is InetAutonomousSystemNumber (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteNextHopAS data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteNextHopAS_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteNextHopAS_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                           u_long * inetCidrRouteNextHopAS_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteNextHopAS_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteNextHopAS_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteNextHopAS_val_ptr ) = rowreq_ctx->data->rt_nexthop_as;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric1
 * inetCidrRouteMetric1 is subid 12 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.12
 * Description:
The primary routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric1 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric1_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric1_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric1_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric1_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteMetric1_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric1_val_ptr ) = rowreq_ctx->data->rt_metric1;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric2
 * inetCidrRouteMetric2 is subid 13 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.13
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric2 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric2_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric2_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric2_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric2_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteMetric2_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric2_val_ptr ) = rowreq_ctx->data->rt_metric2;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric3
 * inetCidrRouteMetric3 is subid 14 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.14
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric3 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric3_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric3_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric3_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric3_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteMetric3_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric3_val_ptr ) = rowreq_ctx->data->rt_metric3;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric4
 * inetCidrRouteMetric4 is subid 15 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.15
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric4 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric4_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric4_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric4_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric4_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteMetric4_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric4_val_ptr ) = rowreq_ctx->data->rt_metric4;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric5
 * inetCidrRouteMetric5 is subid 16 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.16
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the inetCidrRouteMetric5 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric5_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteMetric5_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long *inetCidrRouteMetric5_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteMetric5_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetCidrRouteMetric5_val_ptr ) from rowreq_ctx->data->
     */
    (* inetCidrRouteMetric5_val_ptr ) = rowreq_ctx->data->rt_metric5;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteStatus
 * inetCidrRouteStatus is subid 17 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.17
 * Description:
The row status variable, used according to row  
                installation and removal conventions. 

                A row entry cannot be modified when the status is 
                marked as active(1).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetCidrRouteStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetCidrRouteStatus_get(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                        u_long * inetCidrRouteStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetCidrRouteStatus_val_ptr);

    /** WARNING: this code might not work for netsnmp_route_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*inetCidrRouteStatus_val_ptr) = rowreq_ctx->inetCidrRouteStatus;

    return MFD_SUCCESS;
}



/** @} */
/**********************************************************************
 **********************************************************************
 ***
 *** Table inetCidrRouteTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetCidrRouteTable is subid 7 of ipForward.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.24.7, length: 9
 */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * verify specified index is valid.
 *
 * This check is independent of whether or not the values specified for
 * the columns of the new row are valid. Column values and row consistency
 * will be checked later. At this point, only the index values should be
 * checked.
 *
 * All of the individual index validation functions have been called, so this
 * is the place to make sure they are valid as a whole when combined. If
 * you only have one index, 
 * 
 *
 *
 * @param inetCidrRouteTable_reg
 *        Pointer to the user registration data
 * @param inetCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS            : success
 * @retval MFD_CANNOT_CREATE_NOW  : index not valid right now
 * @retval MFD_CANNOT_CREATE_EVER : index never valid
 */
int
inetCidrRouteTable_validate_index(inetCidrRouteTable_registration_ptr
                                  inetCidrRouteTable_reg,
                                  inetCidrRouteTable_rowreq_ctx *
                                  rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetCidrRouteTable_validate_index", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * Validate incoming index(es)
     */
    /*
     ***************************************************
     ***             START EXAMPLE CODE              ***
     ***---------------------------------------------***/
    /*
     * TODO:
     * update this code or row creation won't work
     */
    if (1) {
        snmp_log(LOG_WARNING, "invalid index for a new row in the "
                 "inetCidrRouteTable table.\n");
        /*
         * TODO:
         * determine failure type.
         *
         * If the index could not ever be created, return MFD_NOT_EVER
         * If the index can not be created under the present circumstances
         * (even though it could be created under other circumstances),
         * return MFD_NOT_NOW.
         */
        if (0) {
            return MFD_CANNOT_CREATE_EVER;
        } else {
            return MFD_CANNOT_CREATE_NOW;
        }
    }
    /*
     ***---------------------------------------------***
     ***              END  EXAMPLE CODE              ***
     ***************************************************/

    return rc;
}

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
inetCidrRouteTable_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetCidrRouteTable_undo_setup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetCidrRouteTable_undo_cleanup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetCidrRouteTable_undo_cleanup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * inetCidrRouteTable.h.
 *
 * @param inetCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetCidrRouteTable_commit(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:inetCidrRouteTable_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->set_flags;
    rowreq_ctx->set_flags = 0;

    /*
     * TODO:
     * commit data
     */
#if 1
#warning inetCidrRouteTable commit
#else
    if (save_flags & FLAG_INETCIDRROUTEIFINDEX) {
        save_flags &= ~FLAG_INETCIDRROUTEIFINDEX;       /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTEIFINDEX;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTETYPE) {
        save_flags &= ~FLAG_INETCIDRROUTETYPE;  /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTETYPE;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTENEXTHOPAS) {
        save_flags &= ~FLAG_INETCIDRROUTENEXTHOPAS;     /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTENEXTHOPAS;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTEMETRIC1) {
        save_flags &= ~FLAG_INETCIDRROUTEMETRIC1;       /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTEMETRIC1;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTEMETRIC2) {
        save_flags &= ~FLAG_INETCIDRROUTEMETRIC2;       /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTEMETRIC2;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTEMETRIC3) {
        save_flags &= ~FLAG_INETCIDRROUTEMETRIC3;       /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTEMETRIC3;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTEMETRIC4) {
        save_flags &= ~FLAG_INETCIDRROUTEMETRIC4;       /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTEMETRIC4;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTEMETRIC5) {
        save_flags &= ~FLAG_INETCIDRROUTEMETRIC5;       /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTEMETRIC5;
        }
    }

    if (save_flags & FLAG_INETCIDRROUTESTATUS) {
        save_flags &= ~FLAG_INETCIDRROUTESTATUS;        /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETCIDRROUTESTATUS;
        }
    }
#endif
    if (save_flags) {
        snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n",
                 save_flags);
        return MFD_ERROR;
    }

    return rc;
}

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * inetCidrRouteTable.h.
 *
 * @param inetCidrRouteTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetCidrRouteTable_undo_commit(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetCidrRouteTable_undo_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * undo commit data
     */

    return rc;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDestType
 * inetCidrRouteDestType is subid 1 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.1
 * Description:
The type of the inetCidrRouteDest address, as defined  
                in the InetAddress MIB. 

                Only those address types that may appear in an actual 
                routing table are allowed as values of this object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDestType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteDestType index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteDestType_check_index(inetCidrRouteTable_rowreq_ctx *
                                  rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteDestType is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteDest
 * inetCidrRouteDest is subid 2 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.2
 * Description:
The destination IP address of this route. 

                The type of this address is determined by the value of 
                the inetCidrRouteDestType object. 

                The values for the index objects inetCidrRouteDest and 
                inetCidrRoutePfxLen must be consistent.  When the value 
                of inetCidrRouteDest (excluding the zone index, if one 
                is present) is x, then the bitwise logical-AND 
                of x with the value of the mask formed from the 
                corresponding index object inetCidrRoutePfxLen MUST be 
                equal to x.  If not, then the index pair is not 
                consistent and an inconsistentName error must be 
                returned on SET or CREATE requests.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRouteDest IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteDest index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteDest_check_index(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteDest is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRoutePfxLen
 * inetCidrRoutePfxLen is subid 3 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.3
 * Description:
Indicates the number of leading one bits which form the  
                mask to be logical-ANDed with the destination address  
                before being compared to the value in the 
                inetCidrRouteDest field. 

                The values for the index objects inetCidrRouteDest and 
                inetCidrRoutePfxLen must be consistent.  When the value 
                of inetCidrRouteDest (excluding the zone index, if one 
                is present) is x, then the bitwise logical-AND 
                of x with the value of the mask formed from the 
                corresponding index object inetCidrRoutePfxLen MUST be 
                equal to x.  If not, then the index pair is not 
                consistent and an inconsistentName error must be 
                returned on SET or CREATE requests.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  0 - 2040;
 *
 * It's syntax is InetAddressPrefixLength (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRoutePfxLen IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRoutePfxLen index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRoutePfxLen_check_index(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRoutePfxLen is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRoutePolicy
 * inetCidrRoutePolicy is subid 4 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.4
 * Description:
This object is an opaque object without any defined 
                semantics.  Its purpose is to serve as an additional 
                index which may delineate between multiple entries to 
                the same destination.  The value { 0 0 } shall be used 
                as the default value for this object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max 2040)
 *
 *
 *
 * NOTE: NODE inetCidrRoutePolicy IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRoutePolicy index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRoutePolicy_check_index(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRoutePolicy is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopType
 * inetCidrRouteNextHopType is subid 5 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.5
 * Description:
The type of the inetCidrRouteNextHop address, as  
                defined in the InetAddress MIB. 

                Value should be set to unknown(0) for non-remote  
                routes. 

                Only those address types that may appear in an actual 
                routing table are allowed as values of this object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHopType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteNextHopType index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteNextHopType_check_index(inetCidrRouteTable_rowreq_ctx *
                                     rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteNextHopType is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHop
 * inetCidrRouteNextHop is subid 6 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.24.7.1.6
 * Description:
On remote routes, the address of the next system en              
                route.  For non-remote routes, a zero length string. 

                The type of this address is determined by the value of 
                the inetCidrRouteNextHopType object.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetCidrRouteNextHop IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetCidrRouteNextHop index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetCidrRouteTable_validate_index() function.
 */
int
inetCidrRouteNextHop_check_index(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetCidrRouteNextHop is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteIfIndex
 * inetCidrRouteIfIndex is subid 7 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.7
 * Description:
The ifIndex value which identifies the local interface 
                through which the next hop of this route should be  
                reached.  A value of 0 is valid and represents the 
                scenario where no interface is specified.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: d
 *
 * Ranges:  0 - 2147483647;
 *
 * It's syntax is InterfaceIndexOrZero (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteIfIndex_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 2147483647
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteIfIndex_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteIfIndex_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteIfIndex_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteIfIndex_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteIfIndex_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteIfIndex data
     * copy inetCidrRouteIfIndex data
     *  from rowreq_ctx->data->inetCidrRouteIfIndex to rowreq_ctx->undo->inetCidrRouteIfIndex
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteIfIndex_val
 *        A long containing the new value.
 */
int
inetCidrRouteIfIndex_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteIfIndex_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteIfIndex_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteIfIndex value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteIfIndex_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteIfIndex_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteIfIndex data
     * copy inetCidrRouteIfIndex data
     *  from rowreq_ctx->undo->inetCidrRouteIfIndex to rowreq_ctx->data->inetCidrRouteIfIndex
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteType
 * inetCidrRouteType is subid 8 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.8
 * Description:
The type of route.  Note that local(3) refers to a  
                route for which the next hop is the final destination;  
                remote(4)refers to a route for which the next hop is  
                not the final destination. 

                Routes which do not result in traffic forwarding or 
                rejection should not be displayed even if the  
                implementation keeps them stored internally. 

                reject(2) refers to a route which, if matched, discards  
                the message as unreachable and returns a notification  
                (e.g. ICMP error) to the message sender.  This is used  
                in some protocols as a means of correctly aggregating  
                routes. 

                blackhole(5) refers to a route which, if matched,  
                discards the message silently.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  other(1), reject(2), local(3), remote(4), blackhole(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteType_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), reject(2), local(3), remote(4), blackhole(5)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteType_check_value(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                              u_long inetCidrRouteType_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteType_check_value",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteType_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteType_undo_setup",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteType data
     * copy inetCidrRouteType data
     *  from rowreq_ctx->data->inetCidrRouteType to rowreq_ctx->undo->inetCidrRouteType
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteType_val
 *        A long containing the new value.
 */
int
inetCidrRouteType_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                      u_long inetCidrRouteType_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteType_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set inetCidrRouteType value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteType_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteType_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteType data
     * copy inetCidrRouteType data
     *  from rowreq_ctx->undo->inetCidrRouteType to rowreq_ctx->data->inetCidrRouteType
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteNextHopAS
 * inetCidrRouteNextHopAS is subid 11 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.11
 * Description:
The Autonomous System Number of the Next Hop.  The  
                semantics of this object are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value. When this object is unknown or not relevant its  
                value should be set to zero.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   1
 *   defval: 0
 *   hint: d
 *
 *
 * It's syntax is InetAutonomousSystemNumber (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteNextHopAS_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteNextHopAS_check_value(inetCidrRouteTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long inetCidrRouteNextHopAS_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteNextHopAS_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteNextHopAS_undo_setup(inetCidrRouteTable_rowreq_ctx *
                                  rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteNextHopAS_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteNextHopAS data
     * copy inetCidrRouteNextHopAS data
     *  from rowreq_ctx->data->inetCidrRouteNextHopAS to rowreq_ctx->undo->inetCidrRouteNextHopAS
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteNextHopAS_val
 *        A u_long containing the new value.
 */
int
inetCidrRouteNextHopAS_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                           u_long inetCidrRouteNextHopAS_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteNextHopAS_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteNextHopAS value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteNextHopAS_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteNextHopAS_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteNextHopAS data
     * copy inetCidrRouteNextHopAS data
     *  from rowreq_ctx->undo->inetCidrRouteNextHopAS to rowreq_ctx->data->inetCidrRouteNextHopAS
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric1
 * inetCidrRouteMetric1 is subid 12 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.12
 * Description:
The primary routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric1_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteMetric1_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric1_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric1_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric1_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric1_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric1 data
     * copy inetCidrRouteMetric1 data
     *  from rowreq_ctx->data->inetCidrRouteMetric1 to rowreq_ctx->undo->inetCidrRouteMetric1
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric1_val
 *        A long containing the new value.
 */
int
inetCidrRouteMetric1_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric1_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric1_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteMetric1 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric1_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric1_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric1 data
     * copy inetCidrRouteMetric1 data
     *  from rowreq_ctx->undo->inetCidrRouteMetric1 to rowreq_ctx->data->inetCidrRouteMetric1
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric2
 * inetCidrRouteMetric2 is subid 13 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.13
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric2_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteMetric2_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric2_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric2_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric2_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric2_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric2 data
     * copy inetCidrRouteMetric2 data
     *  from rowreq_ctx->data->inetCidrRouteMetric2 to rowreq_ctx->undo->inetCidrRouteMetric2
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric2_val
 *        A long containing the new value.
 */
int
inetCidrRouteMetric2_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric2_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric2_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteMetric2 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric2_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric2_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric2 data
     * copy inetCidrRouteMetric2 data
     *  from rowreq_ctx->undo->inetCidrRouteMetric2 to rowreq_ctx->data->inetCidrRouteMetric2
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric3
 * inetCidrRouteMetric3 is subid 14 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.14
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric3_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteMetric3_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric3_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric3_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric3_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric3_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric3 data
     * copy inetCidrRouteMetric3 data
     *  from rowreq_ctx->data->inetCidrRouteMetric3 to rowreq_ctx->undo->inetCidrRouteMetric3
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric3_val
 *        A long containing the new value.
 */
int
inetCidrRouteMetric3_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric3_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric3_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteMetric3 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric3_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric3_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric3 data
     * copy inetCidrRouteMetric3 data
     *  from rowreq_ctx->undo->inetCidrRouteMetric3 to rowreq_ctx->data->inetCidrRouteMetric3
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric4
 * inetCidrRouteMetric4 is subid 15 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.15
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric4_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteMetric4_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric4_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric4_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric4_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric4_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric4 data
     * copy inetCidrRouteMetric4 data
     *  from rowreq_ctx->data->inetCidrRouteMetric4 to rowreq_ctx->undo->inetCidrRouteMetric4
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric4_val
 *        A long containing the new value.
 */
int
inetCidrRouteMetric4_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric4_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric4_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteMetric4 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric4_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric4_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric4 data
     * copy inetCidrRouteMetric4 data
     *  from rowreq_ctx->undo->inetCidrRouteMetric4 to rowreq_ctx->data->inetCidrRouteMetric4
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteMetric5
 * inetCidrRouteMetric5 is subid 16 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.16
 * Description:
An alternate routing metric for this route.  The  
                semantics of this metric are determined by the routing- 
                protocol specified in the route's inetCidrRouteProto  
                value.  If this metric is not used, its value should be  
                set to -1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: -1
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteMetric5_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteMetric5_check_value(inetCidrRouteTable_rowreq_ctx *
                                 rowreq_ctx, long inetCidrRouteMetric5_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric5_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteMetric5_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric5_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric5 data
     * copy inetCidrRouteMetric5 data
     *  from rowreq_ctx->data->inetCidrRouteMetric5 to rowreq_ctx->undo->inetCidrRouteMetric5
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteMetric5_val
 *        A long containing the new value.
 */
int
inetCidrRouteMetric5_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                         long inetCidrRouteMetric5_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric5_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetCidrRouteMetric5 value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteMetric5_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteMetric5_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteMetric5 data
     * copy inetCidrRouteMetric5 data
     *  from rowreq_ctx->undo->inetCidrRouteMetric5 to rowreq_ctx->data->inetCidrRouteMetric5
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-FORWARD-MIB::inetCidrRouteEntry.inetCidrRouteStatus
 * inetCidrRouteStatus is subid 17 of inetCidrRouteEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.24.7.1.17
 * Description:
The row status variable, used according to row  
                installation and removal conventions. 

                A row entry cannot be modified when the status is 
                marked as active(1).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetCidrRouteStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetCidrRouteTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetCidrRouteStatus_check_value(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                                u_long inetCidrRouteStatus_val)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteStatus_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetCidrRouteTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetCidrRouteTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetCidrRouteStatus_undo_setup(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteStatus_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteStatus data
     * copy inetCidrRouteStatus data
     *  from rowreq_ctx->data->inetCidrRouteStatus to rowreq_ctx->undo->inetCidrRouteStatus
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetCidrRouteStatus_val
 *        A long containing the new value.
 */
int
inetCidrRouteStatus_set(inetCidrRouteTable_rowreq_ctx * rowreq_ctx,
                        u_long inetCidrRouteStatus_val)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteStatus_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     ***************************************************
     ***             START EXAMPLE CODE              ***
     ***---------------------------------------------***/
    switch (inetCidrRouteStatus_val) {
    case ROWSTATUS_ACTIVE:
        inetCidrRouteStatus_val = INTERNAL_INETCIDRROUTESTATUS_ACTIVE;
        break;

    case ROWSTATUS_NOTINSERVICE:
        inetCidrRouteStatus_val =
            INTERNAL_INETCIDRROUTESTATUS_NOTINSERVICE;
        break;

    case ROWSTATUS_NOTREADY:
        inetCidrRouteStatus_val = INTERNAL_INETCIDRROUTESTATUS_NOTREADY;
        break;

    case ROWSTATUS_CREATEANDGO:
        inetCidrRouteStatus_val = INTERNAL_INETCIDRROUTESTATUS_CREATEANDGO;
        break;

    case ROWSTATUS_CREATEANDWAIT:
        inetCidrRouteStatus_val =
            INTERNAL_INETCIDRROUTESTATUS_CREATEANDWAIT;
        break;

    case ROWSTATUS_DESTROY:
        inetCidrRouteStatus_val = INTERNAL_INETCIDRROUTESTATUS_DESTROY;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for inetCidrRouteStatus\n",
                 inetCidrRouteStatus_val);
        return SNMP_ERR_GENERR;
    }
    /*
     ***---------------------------------------------***
     ***              END  EXAMPLE CODE              ***
     ***************************************************/

    /*
     * TODO:
     * set inetCidrRouteStatus value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetCidrRouteStatus_undo(inetCidrRouteTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetCidrRouteTable:inetCidrRouteStatus_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetCidrRouteStatus data
     * copy inetCidrRouteStatus data
     *  from rowreq_ctx->undo->inetCidrRouteStatus to rowreq_ctx->data->inetCidrRouteStatus
     */


    return MFD_SUCCESS;
}

/** @} */
/** @{ */
