/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.26 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for ipSystemStatsTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ipSystemStatsTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "ipSystemStatsTable_interface.h"

oid             ipSystemStatsTable_oid[] = { IPSYSTEMSTATSTABLE_OID };
int             ipSystemStatsTable_oid_size =
OID_LENGTH(ipSystemStatsTable_oid);

void            initialize_table_ipSystemStatsTable(void);


/**
 * Initializes the ipSystemStatsTable module
 */
void
init_ipSystemStatsTable(void)
{
    DEBUGMSGTL(("verbose:ipSystemStatsTable:init_ipSystemStatsTable",
                "called\n"));

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("ipSystemStatsTable"))
        initialize_table_ipSystemStatsTable();

}

/**
 * Initialize the table ipSystemStatsTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_ipSystemStatsTable(void)
{
    ipSystemStatsTable_registration_ptr user_context;
    u_long          flags;

    DEBUGMSGTL(("verbose:ipSystemStatsTable:initialize_table_ipSystemStatsTable", "called\n"));

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    /*
     * a netsnmp_data_list is a simple way to store void pointers. A simple
     * string token is used to add, find or remove pointers.
     */
    user_context = netsnmp_create_data_list("EXAMPLE", NULL, NULL);

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _ipSystemStatsTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
ipSystemStatsTable_pre_request(ipSystemStatsTable_registration_ptr
                               user_context)
{
    DEBUGMSGTL(("verbose:ipSystemStatsTable_pre_request", "called\n"));

    /*
     * TODO:
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
ipSystemStatsTable_post_request(ipSystemStatsTable_registration_ptr
                                user_context)
{
    DEBUGMSGTL(("verbose:ipSystemStatsTable_post_request", "called\n"));

    /*
     * TODO:
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table ipSystemStatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ipSystemStatsTable is subid 1 of ipTrafficStats.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.31.1, length: 9
 */

/*
 * ipSystemStatsTable_allocate_data
 *
 * Purpose: create new ipSystemStatsTable_data.
 */
ipSystemStatsTable_data *
ipSystemStatsTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    ipSystemStatsTable_data *rtn =
        SNMP_MALLOC_TYPEDEF(ipSystemStatsTable_data);

    DEBUGMSGTL(("verbose:ipSystemStatsTable_allocate_data", "called\n"));

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "ipSystemStatsTable_data.\n");
    }

    return rtn;
}

/*
 * ipSystemStatsTable_release_data
 *
 * Purpose: release ipSystemStatsTable data.
 */
void
ipSystemStatsTable_release_data(ipSystemStatsTable_data * data)
{
    DEBUGMSGTL(("verbose:ipSystemStatsTable_release_data", "called\n"));

    /*
     * release memory for the context
     */
    free(data);
}



/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
ipSystemStatsTable_indexes_set_tbl_idx(ipSystemStatsTable_mib_index *
                                       tbl_idx,
                                       u_long ipSystemStatsIPVersion_val)
{
    DEBUGMSGTL(("verbose:ipSystemStatsTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * ipSystemStatsIPVersion(1)/InetVersion/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    /** WARNING: this code might not work for netsnmp_systemstats_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->ipSystemStatsIPVersion = ipSystemStatsIPVersion_val;


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
ipSystemStatsTable_indexes_set(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                               u_long ipSystemStatsIPVersion_val)
{
    if (MFD_SUCCESS !=
        ipSystemStatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                               ipSystemStatsIPVersion_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != ipSystemStatsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                             &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInReceives
 * ipSystemStatsInReceives is subid 3 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.3
 * Description:
The total number of input IP datagrams received, including
            those received in error.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInReceives data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInReceives_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInReceives_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsInReceives_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInReceives_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInReceives_val_ptr ) =
        rowreq_ctx->data->stats.HCInReceives.low;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInReceives
 * ipSystemStatsHCInReceives is subid 4 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.4
 * Description:
The total number of input IP datagrams received, including
            those received in error.  This object counts the same
            datagrams as ipSystemStatsInReceives but allows for larger




            values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInReceives data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInReceives_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInReceives_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              U64 * ipSystemStatsHCInReceives_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInReceives_val_ptr);

    (* ipSystemStatsHCInReceives_val_ptr ).low =
        rowreq_ctx->data->stats.HCInReceives.low;
    (* ipSystemStatsHCInReceives_val_ptr ).high =
        rowreq_ctx->data->stats.HCInReceives.high;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInOctets
 * ipSystemStatsInOctets is subid 5 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.5
 * Description:
The total number of octets received in input IP datagrams,
            including those received in error.  Octets from datagrams
            counted in ipSystemStatsInReceives MUST be counted here.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInOctets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                          u_long * ipSystemStatsInOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInOctets_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInOctets_val_ptr ) =
        rowreq_ctx->data->stats.HCInOctets.low;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInOctets
 * ipSystemStatsHCInOctets is subid 6 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.6
 * Description:
The total number of octets received in input IP datagrams,
            including those received in error.  This object counts the
            same octets as ipSystemStatsInOctets but allows for larger
            values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            U64 * ipSystemStatsHCInOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInOctets_val_ptr);

    (* ipSystemStatsHCInOctets_val_ptr ).low =
        rowreq_ctx->data->stats.HCInOctets.low;
    (* ipSystemStatsHCInOctets_val_ptr ).high =
        rowreq_ctx->data->stats.HCInOctets.high;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInHdrErrors
 * ipSystemStatsInHdrErrors is subid 7 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.7
 * Description:
The number of input IP datagrams discarded due to errors in
            their IP headers, including version number mismatch, other
            format errors, hop count exceeded, errors discovered in
            processing their IP options, etc.




            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInHdrErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInHdrErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInHdrErrors_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsInHdrErrors_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInHdrErrors_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInHdrErrors_val_ptr ) =
        rowreq_ctx->data->stats.InHdrErrors;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInNoRoutes
 * ipSystemStatsInNoRoutes is subid 8 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.8
 * Description:
The number of input IP datagrams discarded because no route
            could be found to transmit them to their destination.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInNoRoutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInNoRoutes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInNoRoutes_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsInNoRoutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInNoRoutes_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInNoRoutes_val_ptr ) =
        rowreq_ctx->data->stats.InNoRoutes;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInAddrErrors
 * ipSystemStatsInAddrErrors is subid 9 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.9
 * Description:
The number of input IP datagrams discarded because the IP
            address in their IP header's destination field was not a
            valid address to be received at this entity.  This count
            includes invalid addresses (e.g., ::0) and unsupported
            addresses (e.g., addresses with unallocated prefixes).  For
            entities which are not IP routers and therefore do not
            forward datagrams, this counter includes datagrams discarded
            because the destination address was not a local address.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInAddrErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInAddrErrors_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInAddrErrors_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              u_long * ipSystemStatsInAddrErrors_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInAddrErrors_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInAddrErrors_val_ptr ) =
        rowreq_ctx->data->stats.InAddrErrors;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInUnknownProtos
 * ipSystemStatsInUnknownProtos is subid 10 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.10
 * Description:
The number of locally-addressed IP datagrams received
            successfully but discarded because of an unknown or
            unsupported protocol.




            When tracking interface statistics the counter of the
            interface to which these datagrams were addressed is
            incremented.  This interface might not be the same as the
            input interface for some of the datagrams.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInUnknownProtos data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInUnknownProtos_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInUnknownProtos_get(ipSystemStatsTable_rowreq_ctx *
                                 rowreq_ctx,
                                 u_long *
                                 ipSystemStatsInUnknownProtos_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInUnknownProtos_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInUnknownProtos_val_ptr ) =
        rowreq_ctx->data->stats.InUnknownProtos;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInTruncatedPkts
 * ipSystemStatsInTruncatedPkts is subid 11 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.11
 * Description:
The number of input IP datagrams discarded because the
            datagram frame didn't carry enough data.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInTruncatedPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInTruncatedPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInTruncatedPkts_get(ipSystemStatsTable_rowreq_ctx *
                                 rowreq_ctx,
                                 u_long *
                                 ipSystemStatsInTruncatedPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInTruncatedPkts_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInTruncatedPkts_val_ptr ) =
        rowreq_ctx->data->stats.InTruncatedPkts;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInForwDatagrams
 * ipSystemStatsInForwDatagrams is subid 12 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.12
 * Description:
The number of input datagrams for which this entity was not
            their final IP destination and for which this entity
            attempted to find a route to forward them to that final
            destination.  In entities which do not act as IP routers,
            this counter will include only those datagrams which were
            Source-Routed via this entity, and the Source-Route
            processing was successful.


            When tracking interface statistics the counter of the
            incoming interface is incremented for each datagram.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInForwDatagrams data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInForwDatagrams_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                 rowreq_ctx,
                                 u_long *
                                 ipSystemStatsInForwDatagrams_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInForwDatagrams_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInForwDatagrams_val_ptr ) =
        rowreq_ctx->data->stats.HCInForwDatagrams.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInForwDatagrams
 * ipSystemStatsHCInForwDatagrams is subid 13 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.13
 * Description:
The number of input datagrams for which this entity was not
            their final IP destination and for which this entity
            attempted to find a route to forward them to that final
            destination.  This object counts the same packets as
            ipSystemStatsInForwDatagrams but allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInForwDatagrams data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInForwDatagrams_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                   rowreq_ctx,
                                   U64 *
                                   ipSystemStatsHCInForwDatagrams_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInForwDatagrams_val_ptr);

    (* ipSystemStatsHCInForwDatagrams_val_ptr ).low =
        rowreq_ctx->data->stats.HCInForwDatagrams.low;
    (* ipSystemStatsHCInForwDatagrams_val_ptr ).high =
        rowreq_ctx->data->stats.HCInForwDatagrams.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsReasmReqds
 * ipSystemStatsReasmReqds is subid 14 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.14
 * Description:
The number of IP fragments received which needed to be
            reassembled at this interface.


            When tracking interface statistics the counter of the
            interface to which these fragments were addressed is
            incremented.  This interface might not be the same as the
            input interface for some of the fragments.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsReasmReqds data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsReasmReqds_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsReasmReqds_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsReasmReqds_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsReasmReqds_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsReasmReqds_val_ptr ) = rowreq_ctx->data->stats.ReasmReqds;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsReasmOKs
 * ipSystemStatsReasmOKs is subid 15 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.15
 * Description:
The number of IP datagrams successfully reassembled.


            When tracking interface statistics the counter of the
            interface to which these datagrams were addressed is
            incremented.  This interface might not be the same as the
            input interface for some of the datagrams.


            Discontinuities in the value of this counter can occur at




            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsReasmOKs data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsReasmOKs_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsReasmOKs_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                          u_long * ipSystemStatsReasmOKs_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsReasmOKs_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsReasmOKs_val_ptr ) = rowreq_ctx->data->stats.ReasmOKs;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsReasmFails
 * ipSystemStatsReasmFails is subid 16 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.16
 * Description:
The number of failures detected by the IP re-assembly
            algorithm (for whatever reason: timed out, errors, etc.).
            Note that this is not necessarily a count of discarded IP
            fragments since some algorithms (notably the algorithm in
            RFC 815) can lose track of the number of fragments by
            combining them as they are received.


            When tracking interface statistics the counter of the
            interface to which these fragments were addressed is
            incremented.  This interface might not be the same as the
            input interface for some of the fragments.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsReasmFails data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsReasmFails_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsReasmFails_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsReasmFails_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsReasmFails_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsReasmFails_val_ptr ) = rowreq_ctx->data->stats.ReasmFails;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInDiscards
 * ipSystemStatsInDiscards is subid 17 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.17
 * Description:
The number of input IP datagrams for which no problems were
            encountered to prevent their continued processing, but which
            were discarded (e.g., for lack of buffer space).  Note that
            this counter does not include any datagrams discarded while
            awaiting re-assembly.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInDiscards data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInDiscards_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInDiscards_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsInDiscards_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInDiscards_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInDiscards_val_ptr ) = rowreq_ctx->data->stats.InDiscards;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInDelivers
 * ipSystemStatsInDelivers is subid 18 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.18
 * Description:
The total number of datagrams successfully delivered to IP
            user-protocols (including ICMP).


            When tracking interface statistics the counter of the
            interface to which these datagrams were addressed is
            incremented.  This interface might not be the same as the
            input interface for some of the datagrams.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInDelivers data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInDelivers_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInDelivers_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsInDelivers_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInDelivers_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInDelivers_val_ptr ) =
        rowreq_ctx->data->stats.HCInDelivers.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInDelivers
 * ipSystemStatsHCInDelivers is subid 19 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.19
 * Description:
The total number of datagrams successfully delivered to IP
            user-protocols (including ICMP).  This object counts the
            same packets as ipSystemStatsInDelivers but allows for
            larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInDelivers data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInDelivers_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInDelivers_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              U64 * ipSystemStatsHCInDelivers_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInDelivers_val_ptr);

    (* ipSystemStatsHCInDelivers_val_ptr ).low =
        rowreq_ctx->data->stats.HCInDelivers.low;
    (* ipSystemStatsHCInDelivers_val_ptr ).high =
        rowreq_ctx->data->stats.HCInDelivers.high;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutRequests
 * ipSystemStatsOutRequests is subid 20 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.20
 * Description:
The total number of IP datagrams which local IP user-
            protocols (including ICMP) supplied to IP in requests for
            transmission.  Note that this counter does not include any
            datagrams counted in ipSystemStatsOutForwDatagrams.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutRequests data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutRequests_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutRequests_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsOutRequests_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutRequests_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutRequests_val_ptr ) =
        rowreq_ctx->data->stats.HCOutRequests.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutRequests
 * ipSystemStatsHCOutRequests is subid 21 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.21
 * Description:
The total number of IP datagrams which local IP user-
            protocols (including ICMP) supplied to IP in requests for
            transmission.  This object counts the same packets as
            ipSystemStatsHCOutRequests but allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutRequests data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutRequests_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutRequests_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                               U64 * ipSystemStatsHCOutRequests_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutRequests_val_ptr);

    (* ipSystemStatsHCOutRequests_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutRequests.low;
    (* ipSystemStatsHCOutRequests_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutRequests.high;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutNoRoutes
 * ipSystemStatsOutNoRoutes is subid 22 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.22
 * Description:
The number of locally generated IP datagrams discarded
            because no route could be found to transmit them to their
            destination.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutNoRoutes data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutNoRoutes_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutNoRoutes_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsOutNoRoutes_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutNoRoutes_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutNoRoutes_val_ptr ) =
        rowreq_ctx->data->stats.OutNoRoutes;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutForwDatagrams
 * ipSystemStatsOutForwDatagrams is subid 23 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.23
 * Description:
The number of datagrams for which this entity was not their
            final IP destination and for which it was successful in
            finding a path to their final destination.  In entities
            which do not act as IP routers, this counter will include
            only those datagrams which were Source-Routed via this
            entity, and the Source-Route processing was successful.


            When tracking interface statistics the counter of the
            outgoing interface is incremented for a successfully
            forwarded datagram.


            Discontinuities in the value of this counter can occur at




            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutForwDatagrams data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutForwDatagrams_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                  rowreq_ctx,
                                  u_long *
                                  ipSystemStatsOutForwDatagrams_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutForwDatagrams_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutForwDatagrams_val_ptr ) =
        rowreq_ctx->data->stats.HCOutForwDatagrams.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutForwDatagrams
 * ipSystemStatsHCOutForwDatagrams is subid 24 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.24
 * Description:
The number of datagrams for which this entity was not their
            final IP destination and for which it was successful in
            finding a path to their final destination.  This object
            counts the same packets as ipSystemStatsOutForwDatagrams but
            allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutForwDatagrams data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutForwDatagrams_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutForwDatagrams_get(ipSystemStatsTable_rowreq_ctx *
                                    rowreq_ctx,
                                    U64 *
                                    ipSystemStatsHCOutForwDatagrams_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutForwDatagrams_val_ptr);

    (* ipSystemStatsHCOutForwDatagrams_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutForwDatagrams.low;
    (* ipSystemStatsHCOutForwDatagrams_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutForwDatagrams.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutDiscards
 * ipSystemStatsOutDiscards is subid 25 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.25
 * Description:
The number of output IP datagrams for which no problem was
            encountered to prevent their transmission to their
            destination, but which were discarded (e.g., for lack of
            buffer space).  Note that this counter would include
            datagrams counted in ipSystemStatsOutForwDatagrams if any
            such datagrams met this (discretionary) discard criterion.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutDiscards data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutDiscards_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutDiscards_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsOutDiscards_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutDiscards_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutDiscards_val_ptr ) =
        rowreq_ctx->data->stats.OutDiscards;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutFragReqds
 * ipSystemStatsOutFragReqds is subid 26 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.26
 * Description:
The number of IP datagrams that would require fragmentation
            in order to be transmitted.





            When tracking interface statistics the counter of the
            outgoing interface is incremented for a successfully
            fragmented datagram.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutFragReqds data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutFragReqds_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutFragReqds_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              u_long * ipSystemStatsOutFragReqds_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutFragReqds_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutFragReqds_val_ptr ) =
        rowreq_ctx->data->stats.OutFragReqds;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutFragOKs
 * ipSystemStatsOutFragOKs is subid 27 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.27
 * Description:
The number of IP datagrams that have been successfully
            fragmented.


            When tracking interface statistics the counter of the
            outgoing interface is incremented for a successfully
            fragmented datagram.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutFragOKs data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutFragOKs_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutFragOKs_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                            u_long * ipSystemStatsOutFragOKs_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutFragOKs_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutFragOKs_val_ptr ) = rowreq_ctx->data->stats.OutFragOKs;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutFragFails
 * ipSystemStatsOutFragFails is subid 28 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.28
 * Description:
The number of IP datagrams that have been discarded because
            they needed to be fragmented but could not be.  This
            includes IPv4 packets that have the DF bit set and IPv6
            packets that are being forwarded and exceed the outgoing
            link MTU.


            When tracking interface statistics the counter of the
            outgoing interface is incremented for an unsuccessfully
            fragmented datagram.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutFragFails data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutFragFails_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutFragFails_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              u_long * ipSystemStatsOutFragFails_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutFragFails_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutFragFails_val_ptr ) =
        rowreq_ctx->data->stats.OutFragFails;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutFragCreates
 * ipSystemStatsOutFragCreates is subid 29 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.29
 * Description:
The number of output datagram fragments that have been
            generated as a result of IP fragmentation.


            When tracking interface statistics the counter of the
            outgoing interface is incremented for a successfully
            fragmented datagram.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutFragCreates data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutFragCreates_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutFragCreates_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                                u_long *
                                ipSystemStatsOutFragCreates_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutFragCreates_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutFragCreates_val_ptr ) =
        rowreq_ctx->data->stats.OutFragCreates;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutTransmits
 * ipSystemStatsOutTransmits is subid 30 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.30
 * Description:
The total number of IP datagrams that this entity supplied
            to the lower layers for transmission.  This includes
            datagrams generated local and those forwarded by this
            entity.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutTransmits data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutTransmits_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutTransmits_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              u_long * ipSystemStatsOutTransmits_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutTransmits_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutTransmits_val_ptr ) =
        rowreq_ctx->data->stats.HCOutTransmits.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutTransmits
 * ipSystemStatsHCOutTransmits is subid 31 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.31
 * Description:
The total number of IP datagrams that this entity supplied
            to the lower layers for transmission.  This object counts
            the same datagrams as ipSystemStatsOutTransmits but allows
            for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutTransmits data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutTransmits_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutTransmits_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                                U64 * ipSystemStatsHCOutTransmits_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutTransmits_val_ptr);

    (* ipSystemStatsHCOutTransmits_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutTransmits.low;
    (* ipSystemStatsHCOutTransmits_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutTransmits.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutOctets
 * ipSystemStatsOutOctets is subid 32 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.32
 * Description:
The total number of octets in IP datagrams delivered to the
            lower layers for transmission.  Octets from datagrams
            counted in ipSystemStatsOutTransmits MUST be counted here.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutOctets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                           u_long * ipSystemStatsOutOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutOctets_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutOctets_val_ptr ) =
        rowreq_ctx->data->stats.HCOutOctets.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutOctets
 * ipSystemStatsHCOutOctets is subid 33 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.33
 * Description:
The total number of octets in IP datagrams delivered to the
            lower layers for transmission.  This objects counts the same
            octets as ipSystemStatsOutOctets but allows for larger
            values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             U64 * ipSystemStatsHCOutOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutOctets_val_ptr);

    (* ipSystemStatsHCOutOctets_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutOctets.low;
    (* ipSystemStatsHCOutOctets_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutOctets.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInMcastPkts
 * ipSystemStatsInMcastPkts is subid 34 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.34
 * Description:
The number of IP multicast datagrams received.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInMcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInMcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInMcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsInMcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInMcastPkts_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInMcastPkts_val_ptr ) =
        rowreq_ctx->data->stats.HCInMcastPkts.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInMcastPkts
 * ipSystemStatsHCInMcastPkts is subid 35 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.35
 * Description:
The number of IP multicast datagrams received.  This object
            counts the same datagrams as ipSystemStatsInMcastPkts but
            allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInMcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInMcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInMcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                               U64 * ipSystemStatsHCInMcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInMcastPkts_val_ptr);

    (* ipSystemStatsHCInMcastPkts_val_ptr ).low =
        rowreq_ctx->data->stats.HCInMcastPkts.low;
    (* ipSystemStatsHCInMcastPkts_val_ptr ).high =
        rowreq_ctx->data->stats.HCInMcastPkts.high;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInMcastOctets
 * ipSystemStatsInMcastOctets is subid 36 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.36
 * Description:
The total number of octets received in IP multicast
            datagrams.  Octets from datagrams counted in
            ipSystemStatsOutMcastPkts MUST be counted here.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInMcastOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInMcastOctets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInMcastOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                               u_long * ipSystemStatsInMcastOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInMcastOctets_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInMcastOctets_val_ptr ) =
        rowreq_ctx->data->stats.HCInMcastOctets.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInMcastOctets
 * ipSystemStatsHCInMcastOctets is subid 37 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.37
 * Description:
The total number of octets received in IP multicast
            datagrams.  This object counts the same octets as
            ipSystemStatsInMcastOctets but allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInMcastOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInMcastOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                 rowreq_ctx,
                                 U64 *
                                 ipSystemStatsHCInMcastOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInMcastOctets_val_ptr);

    (* ipSystemStatsHCInMcastOctets_val_ptr ).low =
        rowreq_ctx->data->stats.HCInMcastOctets.low;
    (* ipSystemStatsHCInMcastOctets_val_ptr ).high =
        rowreq_ctx->data->stats.HCInMcastOctets.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutMcastPkts
 * ipSystemStatsOutMcastPkts is subid 38 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.38
 * Description:
The number of IP multicast datagrams transmitted.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutMcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutMcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              u_long * ipSystemStatsOutMcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutMcastPkts_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutMcastPkts_val_ptr ) =
        rowreq_ctx->data->stats.HCOutMcastPkts.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutMcastPkts
 * ipSystemStatsHCOutMcastPkts is subid 39 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.39
 * Description:
The number of IP multicast datagrams transmitted.  This
            object counts the same datagrams as
            ipSystemStatsOutMcastPkts but allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutMcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutMcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutMcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                                U64 * ipSystemStatsHCOutMcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutMcastPkts_val_ptr);

    (* ipSystemStatsHCOutMcastPkts_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutMcastPkts.low;
    (* ipSystemStatsHCOutMcastPkts_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutMcastPkts.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutMcastOctets
 * ipSystemStatsOutMcastOctets is subid 40 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.40
 * Description:
The total number of octets transmitted in IP multicast
            datagrams.  Octets from datagrams counted in
            ipSystemStatsInMcastPkts MUST be counted here.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutMcastOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutMcastOctets_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                                u_long *
                                ipSystemStatsOutMcastOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutMcastOctets_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutMcastOctets_val_ptr ) =
        rowreq_ctx->data->stats.HCOutMcastOctets.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutMcastOctets
 * ipSystemStatsHCOutMcastOctets is subid 41 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.41
 * Description:
The total number of octets transmitted in IP multicast
            datagrams.  This object counts the same octets as
            ipSystemStatsOutMcastOctets but allows for larger values.


            Discontinuities in the value of this counter can occur at




            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutMcastOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutMcastOctets_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutMcastOctets_get(ipSystemStatsTable_rowreq_ctx *
                                  rowreq_ctx,
                                  U64 *
                                  ipSystemStatsHCOutMcastOctets_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutMcastOctets_val_ptr);

    (* ipSystemStatsHCOutMcastOctets_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutMcastOctets.low;
    (* ipSystemStatsHCOutMcastOctets_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutMcastOctets.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsInBcastPkts
 * ipSystemStatsInBcastPkts is subid 42 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.42
 * Description:
The number of IP broadcast datagrams received.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsInBcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsInBcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsInBcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsInBcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsInBcastPkts_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsInBcastPkts_val_ptr ) =
        rowreq_ctx->data->stats.HCInBcastPkts.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCInBcastPkts
 * ipSystemStatsHCInBcastPkts is subid 43 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.43
 * Description:
The number of IP broadcast datagrams received.  This object
            counts the same datagrams as ipSystemStatsInBcastPkts but
            allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCInBcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCInBcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCInBcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                               U64 * ipSystemStatsHCInBcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCInBcastPkts_val_ptr);

    (* ipSystemStatsHCInBcastPkts_val_ptr ).low =
        rowreq_ctx->data->stats.HCInBcastPkts.low;
    (* ipSystemStatsHCInBcastPkts_val_ptr ).high =
        rowreq_ctx->data->stats.HCInBcastPkts.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsOutBcastPkts
 * ipSystemStatsOutBcastPkts is subid 44 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.44
 * Description:
The number of IP broadcast datagrams transmitted.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsOutBcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsOutBcastPkts_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                              u_long * ipSystemStatsOutBcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsOutBcastPkts_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsOutBcastPkts_val_ptr ) =
        rowreq_ctx->data->stats.HCOutBcastPkts.low;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsHCOutBcastPkts
 * ipSystemStatsHCOutBcastPkts is subid 45 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.45
 * Description:
The number of IP broadcast datagrams transmitted.  This
            object counts the same datagrams as
            ipSystemStatsOutBcastPkts but allows for larger values.


            Discontinuities in the value of this counter can occur at
            re-initialization of the management system, and at other
            times as indicated by the value of
            ipSystemStatsDiscontinuityTime.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER64 (based on perltype COUNTER64)
 * The net-snmp type is ASN_COUNTER64. The C type decl is U64 (U64)
 */
/**
 * Extract the current value of the ipSystemStatsHCOutBcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsHCOutBcastPkts_val_ptr
 *        Pointer to storage for a U64 variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsHCOutBcastPkts_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                                U64 * ipSystemStatsHCOutBcastPkts_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsHCOutBcastPkts_val_ptr);

    (* ipSystemStatsHCOutBcastPkts_val_ptr ).low =
        rowreq_ctx->data->stats.HCOutBcastPkts.low;
    (* ipSystemStatsHCOutBcastPkts_val_ptr ).high =
        rowreq_ctx->data->stats.HCOutBcastPkts.high;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsDiscontinuityTime
 * ipSystemStatsDiscontinuityTime is subid 46 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.46
 * Description:
The value of sysUpTime on the most recent occasion at which
            any one or more of this entry's counters suffered a
            discontinuity.


            If no such discontinuities have occurred since the last re-
            initialization of the local management subsystem, then this
            object contains a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsDiscontinuityTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsDiscontinuityTime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsDiscontinuityTime_get(ipSystemStatsTable_rowreq_ctx *
                                   rowreq_ctx,
                                   u_long *
                                   ipSystemStatsDiscontinuityTime_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsDiscontinuityTime_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsDiscontinuityTime_val_ptr ) =
        rowreq_ctx->ipSystemStatsDiscontinuityTime;
    
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::ipSystemStatsEntry.ipSystemStatsRefreshRate
 * ipSystemStatsRefreshRate is subid 47 of ipSystemStatsEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.31.1.1.47
 * Description:
The minimum reasonable polling interval for this entry.
            This object provides an indication of the minimum amount of
            time required to update the counters in this entry.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is UNSIGNED32 (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ipSystemStatsRefreshRate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ipSystemStatsRefreshRate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ipSystemStatsRefreshRate_get(ipSystemStatsTable_rowreq_ctx * rowreq_ctx,
                             u_long * ipSystemStatsRefreshRate_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ipSystemStatsRefreshRate_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    (* ipSystemStatsRefreshRate_val_ptr ) =
        rowreq_ctx->ipSystemStatsRefreshRate;
    
    return MFD_SUCCESS;
}



/** @} */
/** @} */
/** @{ */
