/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.25 $ of : mfd-top.m2c,v $ 
 *
 * $Id$
 */
/** \mainpage MFD helper for inetNetToMediaTable
 *
 * \section intro Introduction
 * Introductory text.
 *
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "inetNetToMediaTable.h"

#include <net-snmp/agent/mib_modules.h>

#include "inetNetToMediaTable_interface.h"

oid             inetNetToMediaTable_oid[] = { INETNETTOMEDIATABLE_OID };
int             inetNetToMediaTable_oid_size =
OID_LENGTH(inetNetToMediaTable_oid);

void            initialize_table_inetNetToMediaTable(void);


/**
 * Initializes the inetNetToMediaTable module
 */
void
init_inetNetToMediaTable(void)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:init_inetNetToMediaTable",
                "called\n"));

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    if (should_init("inetNetToMediaTable"))
        initialize_table_inetNetToMediaTable();

}

/**
 * Initialize the table inetNetToMediaTable 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_inetNetToMediaTable(void)
{
    inetNetToMediaTable_registration_ptr user_context;
    u_long          flags;

    DEBUGMSGTL(("verbose:inetNetToMediaTable:initialize_table_inetNetToMediaTable", "called\n"));

    /*
     * if you'd like to pass in a pointer to some data for this
     * table, allocate or set it up here.
     */
    user_context = NULL;

    /*
     * No support for any flags yet, but in the future you would
     * set any flags here.
     */
    flags = 0;

    /*
     * call interface initialization code
     */
    _inetNetToMediaTable_initialize_interface(user_context, flags);
}

/**
 * pre-request callback
 *
 *
 * @retval MFD_SUCCESS              : success.
 * @retval MFD_ERROR                : other error
 */
int
inetNetToMediaTable_pre_request(inetNetToMediaTable_registration_ptr
                                user_context)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable_pre_request", "called\n"));

    /*
     * TODO:
     * pre-request setup
     */

    return MFD_SUCCESS;
}

/**
 * post-request callback
 *
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : other error (ignored)
 */
int
inetNetToMediaTable_post_request(inetNetToMediaTable_registration_ptr
                                 user_context)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable_post_request", "called\n"));

    /*
     * TODO:
     * post-request cleanup
     */

    return MFD_SUCCESS;
}


/**********************************************************************
 **********************************************************************
 ***
 *** Table inetNetToMediaTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetNetToMediaTable is subid 35 of ip.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.35, length: 8
 */

/*
 * inetNetToMediaTable_allocate_data
 *
 * Purpose: create new inetNetToMediaTable_data.
 */
inetNetToMediaTable_data *
inetNetToMediaTable_allocate_data(void)
{
    /*
     * allocate memory for the context
     */
    /** this might not be right for netsnmp_inetmedia_entry */
    inetNetToMediaTable_data *rtn = netsnmp_access_arp_entry_create();

    DEBUGMSGTL(("verbose:inetNetToMediaTable_allocate_data", "called\n"));

    if (NULL == rtn) {
        snmp_log(LOG_ERR, "unable to malloc memory for new "
                 "inetNetToMediaTable_data.\n");
    }

    return rtn;
}

/*
 * inetNetToMediaTable_release_data
 *
 * Purpose: release inetNetToMediaTable data.
 */
void
inetNetToMediaTable_release_data(inetNetToMediaTable_data * data)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable_release_data", "called\n"));

    /*
     * release memory for the context
     */
    netsnmp_access_arp_entry_free(data);
}


/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaIfIndex
 * inetNetToMediaIfIndex is subid 1 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.35.1.1
 * Description:
The index value which uniquely identifies the interface to
            which this entry is applicable.  The interface identified by
            a particular value of this index is the same interface as
            identified by the same value of the IF-MIB's ifIndex.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  1 - 2147483647;
 *
 * It's syntax is InterfaceIndex (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaIfIndex IS NOT ACCESSIBLE
 *
 *
 */

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddressType
 * inetNetToMediaNetAddressType is subid 2 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.35.1.2
 * Description:
The type of inetNetToMediaNetAddress.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddressType IS NOT ACCESSIBLE
 *
 *
 */

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddress
 * inetNetToMediaNetAddress is subid 3 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.35.1.3
 * Description:
The IP Address corresponding to the media-dependent
            `physical' address.  The address type of this object is
            specified in inetNetToMediaAddressType.


            Implementors need to be aware that if the size of
            inetNetToMediaNetAddress exceeds 115 octets then OIDS of
            instances of columns in this row will have more than 128
            sub-identifiers and cannot be accessed using SNMPv1, SNMPv2c
            or SNMPv3.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddress IS NOT ACCESSIBLE
 *
 *
 */

/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
inetNetToMediaTable_indexes_set_tbl_idx(inetNetToMediaTable_mib_index *
                                        tbl_idx,
                                        long inetNetToMediaIfIndex_val,
                                        u_long
                                        inetNetToMediaNetAddressType_val,
                                        char
                                        *inetNetToMediaNetAddress_val_ptr,
                                        size_t
                                        inetNetToMediaNetAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * inetNetToMediaIfIndex(1)/InterfaceIndex/ASN_INTEGER/long(long)//l/a/w/e/R/d/H 
     */
    /** WARNING: this code might not work for netsnmp_arp_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->inetNetToMediaIfIndex = inetNetToMediaIfIndex_val;

    /*
     * inetNetToMediaNetAddressType(2)/InetAddressType/ASN_INTEGER/long(u_long)//l/a/w/E/r/d/h 
     */
    /** WARNING: this code might not work for netsnmp_arp_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    tbl_idx->inetNetToMediaNetAddressType =
        inetNetToMediaNetAddressType_val;

    /*
     * inetNetToMediaNetAddress(3)/InetAddress/ASN_OCTET_STR/char(char)//L/a/w/e/R/d/h 
     */
    tbl_idx->inetNetToMediaNetAddress_len =
        sizeof(tbl_idx->inetNetToMediaNetAddress);
    /** WARNING: this code might not work for netsnmp_arp_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    /*
     * make sure there is enough space for data
     */
    if (tbl_idx->inetNetToMediaNetAddress_len <
        inetNetToMediaNetAddress_val_ptr_len) {
        snmp_log(LOG_ERR, "not enough space for value\n");
        return MFD_ERROR;
    }
    tbl_idx->inetNetToMediaNetAddress_len =
        inetNetToMediaNetAddress_val_ptr_len;
    memcpy(tbl_idx->inetNetToMediaNetAddress,
           inetNetToMediaNetAddress_val_ptr,
           tbl_idx->inetNetToMediaNetAddress_len *
           sizeof(tbl_idx->inetNetToMediaNetAddress[0]));


    /** xxx-rks: call validation routines? assume caller knows what they
     * are doing? */
    return MFD_SUCCESS;
}

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
inetNetToMediaTable_indexes_set(inetNetToMediaTable_rowreq_ctx *
                                rowreq_ctx, long inetNetToMediaIfIndex_val,
                                u_long inetNetToMediaNetAddressType_val,
                                char *inetNetToMediaNetAddress_val_ptr,
                                size_t
                                inetNetToMediaNetAddress_val_ptr_len)
{
    if (MFD_SUCCESS !=
        inetNetToMediaTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                                inetNetToMediaIfIndex_val,
                                                inetNetToMediaNetAddressType_val,
                                                inetNetToMediaNetAddress_val_ptr,
                                                inetNetToMediaNetAddress_val_ptr_len))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != inetNetToMediaTable_index_to_oid(&rowreq_ctx->oid_idx,
                                              &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}


/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaPhysAddress
 * inetNetToMediaPhysAddress is subid 4 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.35.1.4
 * Description:
The media-dependent `physical' address.


            As the entries in this table are typically not persistent
            when this object is written the entity SHOULD NOT save the
            change to non-volatile storage.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 * Ranges:  0 - 65535;
 *
 * It's syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Extract the current value of the inetNetToMediaPhysAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaPhysAddress_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param inetNetToMediaPhysAddress_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by inetNetToMediaPhysAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*inetNetToMediaPhysAddress_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update inetNetToMediaPhysAddress_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
inetNetToMediaPhysAddress_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                              char **inetNetToMediaPhysAddress_val_ptr_ptr,
                              size_t
                              *inetNetToMediaPhysAddress_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != inetNetToMediaPhysAddress_val_ptr_ptr)
                   && (NULL != *inetNetToMediaPhysAddress_val_ptr_ptr));
    netsnmp_assert(NULL != inetNetToMediaPhysAddress_val_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaPhysAddress_val_ptr_ptr ) and (* inetNetToMediaPhysAddress_val_ptr_len_ptr ) from rowreq_ctx->data->
     */
    (* inetNetToMediaPhysAddress_val_ptr_ptr ) = rowreq_ctx->data->arp_physaddress;
    (* inetNetToMediaPhysAddress_val_ptr_len_ptr ) = rowreq_ctx->data->arp_physaddress_len;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaLastUpdated
 * inetNetToMediaLastUpdated is subid 5 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.35.1.5
 * Description:
The value of sysUpTime at the time this entry was last
            updated.  If this entry was updated prior to the last re-
            initialization of the local network management subsystem,
            then this object contains a zero value.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TimeStamp (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaLastUpdated data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaLastUpdated_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaLastUpdated_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                              u_long * inetNetToMediaLastUpdated_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaLastUpdated_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaLastUpdated_val_ptr ) from rowreq_ctx->data->
     */
    return MFD_SKIP;            /* TODO: remove this once you've set data */
    /*
     * TODO:
     * value mapping
     */

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaType
 * inetNetToMediaType is subid 6 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.35.1.6
 * Description:
The type of mapping.


            Setting this object to the value invalid(2) has the effect
            of invalidating the corresponding entry in the
            inetNetToMediaTable.  That is, it effectively dis-
            associates the interface identified with said entry from the
            mapping identified with said entry.  It is an
            implementation- specific matter as to whether the agent
            removes an invalidated entry from the table.  Accordingly,
            management stations must be prepared to receive tabular
            information from agents that corresponds to entries not
            currently in use.  Proper interpretation of such entries
            requires examination of the relevant inetNetToMediaType
            object.


            The 'dynamic(3)' type indicates that the IP address to
            physical addresses mapping has been dynamically resolved
            using e.g. IPv4 ARP or the IPv6 Neighbor Discovery protocol.


            The 'static(4)' type indicates that the mapping has been
            statically configured.  Both of these refer to entries that
            provide mappings for other entities addresses.


            The 'local(5)' type indicates that the mapping is provided
            for an entity's own interface address.


            As the entries in this table are typically not persistent
            when this object is written the entity SHOULD NOT save the




            change to non-volatile storage.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: static
 *
 * Enum range: 5/8. Values:  other(1), invalid(2), dynamic(3), static(4), local(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaType_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                       u_long * inetNetToMediaType_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaType_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaType_ptr ) from rowreq_ctx->data->
     */
    (* inetNetToMediaType_ptr ) = rowreq_ctx->data->arp_type;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaState
 * inetNetToMediaState is subid 7 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.4.35.1.7
 * Description:
The Neighbor Unreachability Detection [4] state for the
            interface when the address mapping in this entry is used.
            If Neighbor Unreachability Detection is not in use (e.g. for
            IPv4), this object is always unknown(6).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6/8. Values:  reachable(1), stale(2), delay(3), probe(4), invalid(5), unknown(6), incomplete(7)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaState data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaState_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaState_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                        u_long * inetNetToMediaState_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaState_val_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* inetNetToMediaState_val_ptr ) from rowreq_ctx->data->
     */
    (* inetNetToMediaState_val_ptr ) = INETNETTOMEDIASTATE_UNKNOWN;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaRowStatus
 * inetNetToMediaRowStatus is subid 8 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.35.1.8
 * Description:
The status of this conceptual row.


            The RowStatus TC requires that this DESCRIPTION clause
            states under which circumstances other objects in this row
            can be modified.  The value of this object has no effect on
            whether other objects in this conceptual row can be
            modified.


            A conceptual row can not be made active until the
            inetNetToMediaPhysAddress object has been set.




            Note that if the inetNetToMediaType is set to 'invalid' the
            managed node may delete the entry independent of the state
            of this object.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the inetNetToMediaRowStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaRowStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
inetNetToMediaRowStatus_get(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                            u_long * inetNetToMediaRowStatus_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != inetNetToMediaRowStatus_val_ptr);

    /** WARNING: this code might not work for netsnmp_arp_entry */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
#if 1
#warning handle row status
#endif
    (*inetNetToMediaRowStatus_val_ptr) = ROWSTATUS_ACTIVE;

    return MFD_SUCCESS;
}



/** @} */
/**********************************************************************
 **********************************************************************
 ***
 *** Table inetNetToMediaTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * inetNetToMediaTable is subid 35 of ip.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.4.35, length: 8
 */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * verify specified index is valid.
 *
 * This check is independent of whether or not the values specified for
 * the columns of the new row are valid. Column values and row consistency
 * will be checked later. At this point, only the index values should be
 * checked.
 *
 * All of the individual index validation functions have been called, so this
 * is the place to make sure they are valid as a whole when combined. If
 * you only have one index, 
 * 
 *
 *
 * @param inetNetToMediaTable_reg
 *        Pointer to the user registration data
 * @param inetNetToMediaTable_rowreq_ctx
 *        Pointer to the users context.
 * @retval MFD_SUCCESS            : success
 * @retval MFD_CANNOT_CREATE_NOW  : index not valid right now
 * @retval MFD_CANNOT_CREATE_EVER : index never valid
 */
int
inetNetToMediaTable_validate_index(inetNetToMediaTable_registration_ptr
                                   inetNetToMediaTable_reg,
                                   inetNetToMediaTable_rowreq_ctx *
                                   rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetNetToMediaTable_validate_index", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * Validate incoming index(es)
     */
    /*
     ***************************************************
     ***             START EXAMPLE CODE              ***
     ***---------------------------------------------***/
    /*
     * TODO:
     * update this code or row creation won't work
     */
    if (1) {
        snmp_log(LOG_WARNING, "invalid index for a new row in the "
                 "inetNetToMediaTable table.\n");
        /*
         * TODO:
         * determine failure type.
         *
         * If the index could not ever be created, return MFD_NOT_EVER
         * If the index can not be created under the present circumstances
         * (even though it could be created under other circumstances),
         * return MFD_NOT_NOW.
         */
        if (0) {
            return MFD_CANNOT_CREATE_EVER;
        } else {
            return MFD_CANNOT_CREATE_NOW;
        }
    }
    /*
     ***---------------------------------------------***
     ***              END  EXAMPLE CODE              ***
     ***************************************************/

    return rc;
}

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
inetNetToMediaTable_undo_setup(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetNetToMediaTable_undo_setup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetNetToMediaTable_undo_cleanup(inetNetToMediaTable_rowreq_ctx *
                                 rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetNetToMediaTable_undo_cleanup", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);


    return rc;
}

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * inetNetToMediaTable.h.
 *
 * @param inetNetToMediaTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetNetToMediaTable_commit(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    int             rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:inetNetToMediaTable_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->set_flags;
    rowreq_ctx->set_flags = 0;

    /*
     * TODO:
     * commit data
     */
#if 1
#warning nettomedia commit
#else
    if (save_flags & FLAG_INETNETTOMEDIAPHYSADDRESS) {
        save_flags &= ~FLAG_INETNETTOMEDIAPHYSADDRESS;  /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETNETTOMEDIAPHYSADDRESS;
        }
    }

    if (save_flags & FLAG_INETNETTOMEDIATYPE) {
        save_flags &= ~FLAG_INETNETTOMEDIATYPE; /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETNETTOMEDIATYPE;
        }
    }

    if (save_flags & FLAG_INETNETTOMEDIAROWSTATUS) {
        save_flags &= ~FLAG_INETNETTOMEDIAROWSTATUS;    /* clear */
        rc = TODO_commit_colum(...);
        if (rc == TODO_success_code) {
            /*
             * set flag, in case we need to undo
             */
            rowreq_ctx->set_flags |= FLAG_INETNETTOMEDIAROWSTATUS;
        }
    }
#endif
    if (save_flags) {
        snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n",
                 save_flags);
        return MFD_ERROR;
    }

    return rc;
}

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * inetNetToMediaTable.h.
 *
 * @param inetNetToMediaTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
inetNetToMediaTable_undo_commit(inetNetToMediaTable_rowreq_ctx *
                                rowreq_ctx)
{
    int             rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:inetNetToMediaTable_undo_commit", "called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * undo commit data
     */

    return rc;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaIfIndex
 * inetNetToMediaIfIndex is subid 1 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.35.1.1
 * Description:
The index value which uniquely identifies the interface to
            which this entry is applicable.  The interface identified by
            a particular value of this index is the same interface as
            identified by the same value of the IF-MIB's ifIndex.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: d
 *
 * Ranges:  1 - 2147483647;
 *
 * It's syntax is InterfaceIndex (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaIfIndex IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetNetToMediaIfIndex index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetNetToMediaTable_validate_index() function.
 */
int
inetNetToMediaIfIndex_check_index(inetNetToMediaTable_rowreq_ctx *
                                  rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetNetToMediaIfIndex is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddressType
 * inetNetToMediaNetAddressType is subid 2 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.35.1.2
 * Description:
The type of inetNetToMediaNetAddress.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  1      hasdefval 0
 *   readable   0     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  unknown(0), ipv4(1), ipv6(2), ipv4z(3), ipv6z(4), dns(16)
 *
 * It's syntax is InetAddressType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddressType IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetNetToMediaNetAddressType index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetNetToMediaTable_validate_index() function.
 */
int
inetNetToMediaNetAddressType_check_index(inetNetToMediaTable_rowreq_ctx *
                                         rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetNetToMediaNetAddressType is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaNetAddress
 * inetNetToMediaNetAddress is subid 3 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is NoAccess.
 * OID: .1.3.6.1.2.1.4.35.1.3
 * Description:
The IP Address corresponding to the media-dependent
            `physical' address.  The address type of this object is
            specified in inetNetToMediaAddressType.


            Implementors need to be aware that if the size of
            inetNetToMediaNetAddress exceeds 115 octets then OIDS of
            instances of columns in this row will have more than 128
            sub-identifiers and cannot be accessed using SNMPv1, SNMPv2c
            or SNMPv3.
 *
 * Attributes:
 *   accessible 0     isscalar 0     enums  0      hasdefval 0
 *   readable   0     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is InetAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 *
 *
 *
 * NOTE: NODE inetNetToMediaNetAddress IS NOT ACCESSIBLE
 *
 *
 */
/**
 * check validity of inetNetToMediaNetAddress index portion
 *
 * @retval MFD_SUCCESS   : the incoming value is legal
 * @retval MFD_BAD_VALUE : the incoming value is NOT legal
 *
 * @note this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       inetNetToMediaTable_validate_index() function.
 */
int
inetNetToMediaNetAddress_check_index(inetNetToMediaTable_rowreq_ctx *
                                     rowreq_ctx)
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for inetNetToMediaNetAddress is legal
     */

    /*
     * if everything looks ok, return MFD_SUCCESS 
     */
    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaPhysAddress
 * inetNetToMediaPhysAddress is subid 4 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.35.1.4
 * Description:
The media-dependent `physical' address.


            As the entries in this table are typically not persistent
            when this object is written the entity SHOULD NOT save the
            change to non-volatile storage.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 * Ranges:  0 - 65535;
 *
 * It's syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 65535)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaPhysAddress_val_ptr
 *        A char containing the new value.
 * @param inetNetToMediaPhysAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by inetNetToMediaPhysAddress_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetNetToMediaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, and object with the syntax DisplayString(0..40)
 * will have already been checked for a length between 0 and 40.
 * But if the description also specified that the value must
 * be all uppercase letters, you would enforce that requirement here
 * by returning MFD_NOT_VALID_EVER for a set containing lowercase
 * letters. If the description also specified that the value can not
 * change by more than one letter at a time, an attempt to change
 * "ABBY" to "ANNIE" should return MFD_NOT_VALID_NOW.
 *
 */
int
inetNetToMediaPhysAddress_check_value(inetNetToMediaTable_rowreq_ctx *
                                      rowreq_ctx,
                                      char
                                      *inetNetToMediaPhysAddress_val_ptr,
                                      size_t
                                      inetNetToMediaPhysAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaPhysAddress_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != inetNetToMediaPhysAddress_val_ptr);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetNetToMediaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetNetToMediaPhysAddress_undo_setup(inetNetToMediaTable_rowreq_ctx *
                                     rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaPhysAddress_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetNetToMediaPhysAddress data
     * copy inetNetToMediaPhysAddress and inetNetToMediaPhysAddress_len data
     *  from rowreq_ctx->data->inetNetToMediaPhysAddress to rowreq_ctx->undo->inetNetToMediaPhysAddress
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetNetToMediaPhysAddress_val_ptr
 *        A char containing the new value.
 * @param inetNetToMediaPhysAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by inetNetToMediaPhysAddress_val_ptr
 */
int
inetNetToMediaPhysAddress_set(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                              char *inetNetToMediaPhysAddress_val_ptr,
                              size_t inetNetToMediaPhysAddress_val_ptr_len)
{

    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaPhysAddress_set", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != inetNetToMediaPhysAddress_val_ptr);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     * TODO:
     * set inetNetToMediaPhysAddress value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetNetToMediaPhysAddress_undo(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaPhysAddress_undo", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetNetToMediaPhysAddress data
     * copy inetNetToMediaPhysAddress and inetNetToMediaPhysAddress_len data
     *  from rowreq_ctx->undo->inetNetToMediaPhysAddress to rowreq_ctx->data->inetNetToMediaPhysAddress
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaType
 * inetNetToMediaType is subid 6 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.35.1.6
 * Description:
The type of mapping.


            Setting this object to the value invalid(2) has the effect
            of invalidating the corresponding entry in the
            inetNetToMediaTable.  That is, it effectively dis-
            associates the interface identified with said entry from the
            mapping identified with said entry.  It is an
            implementation- specific matter as to whether the agent
            removes an invalidated entry from the table.  Accordingly,
            management stations must be prepared to receive tabular
            information from agents that corresponds to entries not
            currently in use.  Proper interpretation of such entries
            requires examination of the relevant inetNetToMediaType
            object.


            The 'dynamic(3)' type indicates that the IP address to
            physical addresses mapping has been dynamically resolved
            using e.g. IPv4 ARP or the IPv6 Neighbor Discovery protocol.


            The 'static(4)' type indicates that the mapping has been
            statically configured.  Both of these refer to entries that
            provide mappings for other entities addresses.


            The 'local(5)' type indicates that the mapping is provided
            for an entity's own interface address.


            As the entries in this table are typically not persistent
            when this object is written the entity SHOULD NOT save the




            change to non-volatile storage.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: static
 *
 * Enum range: 5/8. Values:  other(1), invalid(2), dynamic(3), static(4), local(5)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaType_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetNetToMediaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), invalid(2), dynamic(3), static(4), local(5)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetNetToMediaType_check_value(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                               u_long inetNetToMediaType_val)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaType_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetNetToMediaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetNetToMediaType_undo_setup(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaType_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetNetToMediaType data
     * copy inetNetToMediaType data
     *  from rowreq_ctx->data->inetNetToMediaType to rowreq_ctx->undo->inetNetToMediaType
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetNetToMediaType_val
 *        A long containing the new value.
 */
int
inetNetToMediaType_set(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                       u_long inetNetToMediaType_val)
{

    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaType_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     ***************************************************
     ***             START EXAMPLE CODE              ***
     ***---------------------------------------------***/
    switch (inetNetToMediaType_val) {
    case INETNETTOMEDIATYPE_OTHER:
        inetNetToMediaType_val = INTERNAL_INETNETTOMEDIATYPE_OTHER;
        break;

    case INETNETTOMEDIATYPE_INVALID:
        inetNetToMediaType_val = INTERNAL_INETNETTOMEDIATYPE_INVALID;
        break;

    case INETNETTOMEDIATYPE_DYNAMIC:
        inetNetToMediaType_val = INTERNAL_INETNETTOMEDIATYPE_DYNAMIC;
        break;

    case INETNETTOMEDIATYPE_STATIC:
        inetNetToMediaType_val = INTERNAL_INETNETTOMEDIATYPE_STATIC;
        break;

    case INETNETTOMEDIATYPE_LOCAL:
        inetNetToMediaType_val = INTERNAL_INETNETTOMEDIATYPE_LOCAL;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for inetNetToMediaType\n",
                 inetNetToMediaType_val);
        return SNMP_ERR_GENERR;
    }
    /*
     ***---------------------------------------------***
     ***              END  EXAMPLE CODE              ***
     ***************************************************/

    /*
     * TODO:
     * set inetNetToMediaType value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetNetToMediaType_undo(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaType_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetNetToMediaType data
     * copy inetNetToMediaType data
     *  from rowreq_ctx->undo->inetNetToMediaType to rowreq_ctx->data->inetNetToMediaType
     */


    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IP-MIB::inetNetToMediaEntry.inetNetToMediaRowStatus
 * inetNetToMediaRowStatus is subid 8 of inetNetToMediaEntry.
 * It's status is Current, and it's access level is Create.
 * OID: .1.3.6.1.2.1.4.35.1.8
 * Description:
The status of this conceptual row.


            The RowStatus TC requires that this DESCRIPTION clause
            states under which circumstances other objects in this row
            can be modified.  The value of this object has no effect on
            whether other objects in this conceptual row can be
            modified.


            A conceptual row can not be made active until the
            inetNetToMediaPhysAddress object has been set.




            Note that if the inetNetToMediaType is set to 'invalid' the
            managed node may delete the entry independent of the state
            of this object.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * It's syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param inetNetToMediaRowStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * inetNetToMediaTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 * For example, an object with the syntax INTEGER(0..500) will
 * have already been checked for a value between 0 and 500. But
 * if the description also specifies that the value must be an
 * even number, you would enforce that requirement here. If and odd
 * numer is set, return MFD_NOT_VALID_EVER. If the description also
 * specified that changed must be made in single steps of 2, then a set
 * to change the value 10 to an even value other than 8 or 12 should
 * return MFD_NOT_VALID_NOW.
 *
 */
int
inetNetToMediaRowStatus_check_value(inetNetToMediaTable_rowreq_ctx *
                                    rowreq_ctx,
                                    u_long inetNetToMediaRowStatus_val)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaRowStatus_check_value", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that new value is legal
     */

    /*
     * if everything looks ok, return 0 
     */
    return MFD_SUCCESS;
}

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (inetNetToMediaTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * inetNetToMediaTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
inetNetToMediaRowStatus_undo_setup(inetNetToMediaTable_rowreq_ctx *
                                   rowreq_ctx)
{
    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaRowStatus_undo_setup", "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetNetToMediaRowStatus data
     * copy inetNetToMediaRowStatus data
     *  from rowreq_ctx->data->inetNetToMediaRowStatus to rowreq_ctx->undo->inetNetToMediaRowStatus
     */


    return MFD_SUCCESS;
}

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param inetNetToMediaRowStatus_val
 *        A long containing the new value.
 */
int
inetNetToMediaRowStatus_set(inetNetToMediaTable_rowreq_ctx * rowreq_ctx,
                            u_long inetNetToMediaRowStatus_val)
{

    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaRowStatus_set",
                "called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * reverse value mapping
     *
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them here.
     */
    /*
     ***************************************************
     ***             START EXAMPLE CODE              ***
     ***---------------------------------------------***/
    switch (inetNetToMediaRowStatus_val) {
    case ROWSTATUS_ACTIVE:
        inetNetToMediaRowStatus_val =
            INTERNAL_INETNETTOMEDIAROWSTATUS_ACTIVE;
        break;

    case ROWSTATUS_NOTINSERVICE:
        inetNetToMediaRowStatus_val =
            INTERNAL_INETNETTOMEDIAROWSTATUS_NOTINSERVICE;
        break;

    case ROWSTATUS_NOTREADY:
        inetNetToMediaRowStatus_val =
            INTERNAL_INETNETTOMEDIAROWSTATUS_NOTREADY;
        break;

    case ROWSTATUS_CREATEANDGO:
        inetNetToMediaRowStatus_val =
            INTERNAL_INETNETTOMEDIAROWSTATUS_CREATEANDGO;
        break;

    case ROWSTATUS_CREATEANDWAIT:
        inetNetToMediaRowStatus_val =
            INTERNAL_INETNETTOMEDIAROWSTATUS_CREATEANDWAIT;
        break;

    case ROWSTATUS_DESTROY:
        inetNetToMediaRowStatus_val =
            INTERNAL_INETNETTOMEDIAROWSTATUS_DESTROY;
        break;

    default:
        snmp_log(LOG_ERR,
                 "couldn't reverse map value %d for inetNetToMediaRowStatus\n",
                 inetNetToMediaRowStatus_val);
        return SNMP_ERR_GENERR;
    }
    /*
     ***---------------------------------------------***
     ***              END  EXAMPLE CODE              ***
     ***************************************************/

    /*
     * TODO:
     * set inetNetToMediaRowStatus value in rowreq_ctx->data->
     */

    return MFD_SUCCESS;
}

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
inetNetToMediaRowStatus_undo(inetNetToMediaTable_rowreq_ctx * rowreq_ctx)
{

    DEBUGMSGTL(("verbose:inetNetToMediaTable:inetNetToMediaRowStatus_undo",
                "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO: copy inetNetToMediaRowStatus data
     * copy inetNetToMediaRowStatus data
     *  from rowreq_ctx->undo->inetNetToMediaRowStatus to rowreq_ctx->data->inetNetToMediaRowStatus
     */


    return MFD_SUCCESS;
}

/**
 * check dependencies
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->set_flags will indicate which writeable columns were
 * set. The definitions for the FLAG_* bits can be found in
 * inetNetToMediaTable.h.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-inetNetToMediaTable if you don't have dependencies)
 */
int
inetNetToMediaTable_check_dependencies(inetNetToMediaTable_rowreq_ctx *
                                       rowreq_ctx)
{
    int             rc = SNMP_ERR_NOERROR;

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that all new value are legal.
     *
     * This is useful for for tables which have dependencies
     * between columns (or rows, or tables).
     *
     * For example, two columns allocating a percentage of something
     * should add up to 100%.
     */
    /*
     * check for valid RowStatus transition (old, new)
     */
#if 1
#warning rowstatus transition
#else
    rc = check_rowstatus_transition(rowreq_ctx->undo->
                                    inetNetToMediaRowStatus,
                                    rowreq_ctx->data->
                                    inetNetToMediaRowStatus);
#endif
    return rc;
}

/** @} */
/** @{ */
