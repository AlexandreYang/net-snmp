#!/usr/local/bin/perl -w

#
# Description: 
#
# This program, given an OID reference as an argument, creates some
# template mib module files to be used with the ucd-snmp agent.  It is
# far from perfect and will not generate working modules, but it
# significantly shortens development time by outlining the basic
# structure.
#
# Its up to you to verify what it does and change the default values
# it returns.
#
# You *must* correct the beginning of the var_XXX() function to
# correctly determine mib ownership of the incoming request.
#

use SNMP;
#use strict 'vars';
$SNMP::save_descriptions=1;
$SNMP::use_long_names=1;
$SNMP::use_enums=1;
SNMP::initMib();

$configfile="mib2c.conf";

sub usage {
    print "$0 [-h] [-c configfile] mibNode\n\n";
    print "  -c configfile\tSpecifies the configuration file to use\n\t\tthat dictates what the output of mib2c will look like.\n\n";
    print "  -f prefix\tSpecifies the output prefix to use.  All code\n\t\twill be put into prefix.c and prefix.h\n\n";
    print "  mibNode\tThe name of the top level mib node you want to\n\t\tgenerate code for.  By default, the code will be stored in\n\t\tmibNode.c and mibNode.h\n\n";
    print "  -h\t\tThis message.\n\n";
    1;
}	

while($#ARGV >= 0) {
    $_ = shift;
    $configfile = shift if (/-c/);
    usage && exit(1) if (/-h/);
    $outputName = shift if (/-f/);
    $oid = $_ if (/^[^-]/);
}
    
open(I,"$configfile");
while(<I>) {
    next if /^\s*#/;
    if (/type:\s*(.*)/) {
	$type = $1;
	chomp($type);
    } else {
	if (/\s*([^:]*):\s*(.*)/) {
	    $variableTypes{$type}{$1} = $2;
	    chomp($variableTypes{$type}{$1});
	    $lasttoken = $1;
	} else {
	    # continuation line
	    $_ =~ s/^\s*//;
	    $variableTypes{$type}{$lasttoken} .= "\n" . $_;
	    chomp($variableTypes{$type}{$lasttoken});
	}
    }
}
close(I);

#
# internal conversion tables
#
$varInits =
"  /* variables we may use later */
  static long long_ret;
  static unsigned char string[1500];
  static oid objid[30];
  static struct counter64 c64;";

%accessToUCD = qw(ReadOnly RONLY ReadWrite RWRITE 
		  WriteOnly RWRITE Create RWRITE);

@varLengths = (2,4,7,8,13);

if (!defined($oid)) {
    print STDERR "You didn\'t specify a mib oid to convert!\n";
    usage();
    exit(1);
}

$mib = $SNMP::MIB{$oid};
$_ = $commaoid = $fulloid = $mib->{'objectID'};
if (!defined ($fulloid)) {
    print STDERR "Couldn\'t find mib reference: $oid\n";
    exit(1);
}
s/[^.]//g;
$commaoid =~ s/\./,/g;
$commaoid =~ s/^,//g;

$outputName = $mib->{'label'} if (!defined($outputName));
$OUTPUTNAME = uc($outputName);
print "outputting to $outputName.c and $outputName.h ...\n";

#
# Collect mib information
#
$count = 0;
$depth = loadMib($mib,0,0)-1;
for($varlen = 0; $varlen <= $#varLengths; $varlen++) {
  last if ($depth <= $varLengths[$varlen]);
}
$varlen = $varLengths[$varlen];

#
# Output the results
#
open(DOTH,">$outputName.h");
open(DOTC,">$outputName.c");
print DOTH "
/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifndef _MIBGROUP_${OUTPUTNAME}_H
#define _MIBGROUP_${OUTPUTNAME}_H

/* we may use header_generic and checkmib from the util_funcs module */

config_require(util_funcs)

/* Magic number definitions: */
$defineStatements

/* function prototypes */

void   init_$outputName(void);
unsigned char *var_$outputName(struct variable *, oid *, int *, int, int *, WriteMethod **write_method);
$functionInfo

#endif /* _MIBGROUP_${OUTPUTNAME}_H */\n";

print DOTC "
/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include \"mibincl.h\"
#include \"$outputName.h\"

/* 
 * ${outputName}_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid ${outputName}_variables_oid[] = { $commaoid };

/* 
 * variable$varlen ${outputName}_variables:
 *   this variable defines function callbacks and type return information 
 *   for the $outputName mib section 
 */

struct variable$varlen ${outputName}_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
$structinfo
};
/*    (L = length of the oidsuffix) */

/*
 * init_$outputName():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_$outputName(void) {

  /* register ourselves with the agent to handle our mib tree */
  REGISTER_MIB(\"$outputName\", ${outputName}_variables, variable$varlen,\
               ${outputName}_variables_oid);

  /* place any other initialization junk you need here */
}

/*
 * var_$outputName():
 *   This function is called every time the agent gets a request for a
 *   varibable that might be found within your mib section registered
 *   above.  It is up to you to do the right thing and fill up the
 *   \"name\" variable with the oid to be returned to the caller.
 *   This is dependent on the value of the \"exact\" variable, which
 *   will indicate it is a get request or a getnext request.  For
 *   snmpsets, you should set the write_method to the value of a
 *   pointer to a function that can handle write requests for that
 *   information.  Please see other mib modules for examples of
 *   implementations.  Specifically, check out the examples in the
 *   example directory and in the mibII dirctory.
 */
unsigned char *
var_$outputName(vp, name, length, exact, var_len, write_method)
    struct variable *vp;
    oid     *name;
    int     *length;
    int     exact;
    int     *var_len;
    WriteMethod **write_method);
{

$varInits

  *write_method = 0;           /* assume it isnt writable for the time being */
  *var_len = sizeof(long_ret); /* assume an integer and change later if not */

  /* 
   * XXX: this following line is almost gaurunteed to be wrong for
   *   	  your mib, please fix this.  The header_generic will only
   *      work for simplistic static variables.  It will *not* work
   *      for tables. mib2c is not smart enough to write this for you. 
   */
  if (header_generic(vp,name,length,exact,var_len,write_method))
    return 0;

  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {\n\n
$caseStatements\n
    default:
      ERROR_MSG(\"\");
  }
  return 0;
}

$writeFuncs";

#
# Writable variable code
#
close(DOTH);
close(DOTC);
print "  depth: $depth\n";
print "  Number of Lines Created:\n";
system("wc -l $outputName.c $outputName.h");
print "Done.\n";

sub loadMib {
    my $mib = shift;
#    my $oid = shift;
    my $depth = shift;
    $depth = $depth + 1;
#    my $mib = $SNMP::MIB{$oid};
#    print "doing $mib->{label} : $mib->{objectID}\n";
    if (defined($mib->{'access'}) && 
	$mib->{'access'} =~ /ReadOnly|ReadWrite|WriteOnly|Create/) {
	my $cname = uc($mib->{'label'});
	$caseStatements .= "    case $cname:\n";
	$count = $count + 1;
	$subid = $mib->{'objectID'};
	$subid =~ s/$fulloid\.//;
	$subid =~ s/\./,/g;
	if (!defined($variableTypes{$mib->{'type'}})) {
	    $caseStatements .= "/* unknown type: $mib->{type}.  mib2c can not set up a default value for this mib value */\n";
	    $defineStatements .= "/* unknown type: $mib->{type}.  mib2c can not handle this mib value: */\n";
	    $count = $count + 1;
	    print STDERR "unknown type:  $mib->{type} for $mib->{label}\n";
	    $structinfo .= 
		sprintf("/* unknown type: $mib->{type}.  mib2c can not handle this mib value: */\n{ %-20s, %-14s, %-6.6s, %s, %d, { %s } },\n",
			$cname, "UNKNOWN_TYPE_$mib->{type}",
			$accessToUCD{$mib->{'access'}},
			"var_$outputName",
			$depth-1, $subid);
	} else {
	    if ($mib->{'access'} =~ /ReadWrite|WriteOnly|Create/) {
		createWriteFunction($mib->{'label'}, $mib->{'type'});
		$caseStatements .= "      *write_method = write_$mib->{label};\n";
	    }
	    $x = $variableTypes{$mib->{'type'}}{'defaultInit'};
	    $x =~ s/\n/\n        /g;
	    $x = "        " . $x;
	    $caseStatements .= $x . "\n";
	    $structinfo .= 
		sprintf("  { %-20s, %-14s, %-6.6s, %s, %d, { %s } },\n",
			$cname, $variableTypes{$mib->{'type'}}{'asnType'},
			$accessToUCD{$mib->{'access'}},
			"var_$outputName",
			$depth-1, $subid);
	}
	$caseStatements .= "\n";
	$defineStatements .= sprintf("#define   %-20s  $count\n", $cname);
    }
    my $children = $$mib{'children'}; 
    my $i;
    my $newdepth = $depth;
    foreach $i (@{$children}) {
	$newdepth = max(loadMib($i, $depth), $newdepth);
    }
    return $newdepth;
}

sub max {
    my $x = shift;
    my $y = shift;
    return ($x > $y) ? $x : $y;
}

sub createWriteFunction {
    my $name = shift;
    my $type = shift;

    $writeFuncs .= "int
write_$name(action, var_val, var_val_type, var_val_len, statP, name, name_len)
   int      action;
   u_char   *var_val;
   u_char   var_val_type;
   int      var_val_len;
   u_char   *statP;
   oid      *name;
   int      name_len;
{
  $variableTypes{$type}{writeInit}
  int size, bigsize=1000;

  if (var_val_type != $variableTypes{$type}{asnType}){
      fprintf(stderr, \"write to $name not $variableTypes{$type}{asnType}\\n\");
      return SNMP_ERR_WRONGTYPE;
  }
  if (var_val_len > sizeof($variableTypes{$type}{variable})){
      fprintf(stderr,\"write to $name: bad length\\n\");
      return SNMP_ERR_WRONGLENGTH;
  }
  if (action == COMMIT){
      size = sizeof($variableTypes{$type}{variable});
      $variableTypes{$type}{parser}(var_val, &bigsize, &var_val_type, $variableTypes{$type}{variablePtr}, size);
      /* Here, the variable has been stored in $variableTypes{$type}{variable} for
      you to use, and you have just been asked to do something with
      it... Your code goes here. */
  }
  return SNMP_ERR_NOERROR;
}\n\n";
    $functionInfo .= "int write_$name(int, u_char *,u_char, int, u_char *,oid*, int);\n";
}
