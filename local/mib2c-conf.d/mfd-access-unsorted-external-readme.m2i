########################################################################
## generic include for XXX. Don't use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
  unsorted-external summary
  -------------------------
    The unsorted-external data access code is for cases when you data is
    kept UNSORTED and EXTERNAL to the agent/sub-agent.

    This code was generated based on the following assumptions or settings:

    1) The raw data for this table is UNSORTED.
    @if $mfd_readme_verbose == 1@

       UNSORTED data is data that is not kept in the same order as the way
       SNMP expects the index(es) for the table to be kept. [It could very
       well be sorted in some other order, but for the purpose of SNMP, the
       order is incorrect.]  If you're not sure if your data is sorted
       in an SNMP compliant way, its likely not.

       Because the raw data is unsorted, to satisfy a particular request, the
       entire data set must be examined to find the apropriate index. This
       is done via a simple loop. The MFD handler will call your get_first
       function and the call the get_next function repeatedly, until it
       returns SNMPERR_NO_VARS.
    @end@

    2) The raw data for this table is EXTERNAL.
    @if $mfd_readme_verbose == 1@

       EXTERNAL data is data that is owned by some other process,
       device, file or mechanism.  The agent must use some interface to
       read or modify the data.  An external process may modify the data
       without the agent's knowledge. For example, the Net-SNMP agent
       implements the interface table (ifTable), which reports on
       network interfaces. The host operating system owns this data, and
       Net-SNMP must use system calls to report or manipulate the data.
       Examples of external data include data stored in kernel space, in
       files, in another non-memory shared process, and data stored in
       devices.
    @end@

    3) The raw data for this table is TRANSIENT.
    @if $mfd_readme_verbose == 1@

       TRANSIENT data is data that may be overwritten by another funtion
       or process. For example, many OS functions return data in a
       static buffer that will be reused the next time the function is
       called.  Because of this, we will assume that you will copy the
       raw data retrieved from these other sources to a generated
       structure for use within the Net-SNMP agent.  (Don't worry, we'll
       help you)
    @end@


  XXX: insert master loop description here, possible including a state
  transition diagram showing MFD master code on the left and user
  function calls on the right?


########################################################################
  Defining context for the loop
  -----------------------------
    TODO : typedef ${table}_loop_ctx
    WHERE: ${table}_data_access.h
    @if $mfd_readme_verbose == 1@

    Since the actual loop is in the MFD handler, a loop contex parameter
    is provided to help you keep track of where you are in between calls
    to functions that you wrote and the master MFD handler calls. The
    structure of this context is user defineable, and is defined in the
    file ${table}_data_access.h.

    The funtion call are actually passed a reference to the loop
    context, to allow the loop context to be allocated memory. Here are
    some simple examples for various data formats.

    EG, if your data is stored in a linked list, the obvious thing you
    want to know from one function call to the next is your current
    position in the linked list.  Thus the easiest context to use is a
    pointer within the linked list.  For an array, the current index to
    that array would be easiest.

      Linked list
      -----------
          typedef list_node ${table}_loop_ctx;

      Array
      -----
          typedef integer ${table}_loop_ctx;

      File
      ----
          typedef struct ${table}_loop_ctx_s {
               char *      file_name;
               FILE *      f;
               char        line[128];
          } ${table}_loop_ctx;

  @end@


########################################################################
  Initialization
  --------------
    TODO : Initialization
    FUNC : ${table}_init_data
    WHERE: ${table}_data_access.c
    @if $mfd_readme_verbose == 1@

    The ${table}_init_data function will be called during startup to
    allow for any initialization needed for the data access routines.

    XXX: registration location should be documented?

    @end@


########################################################################
  Preparing for the loop
  ----------------------
    TODO : initialize loop context
    FUNC : ${table}_init_loop_ctx
    WHERE: ${table}_data_access.c

    @if $mfd_readme_verbose == 1@
    Before the loop begins within the master MFD handler, your
    init_loop_ctx function will be called. The first parameter is the
    netsnmp_mfd_registration structure created during
    initialization. The table users context (reg->mfd_user_ctx) is a
    useful place to keep any useful information you may need to loop
    through the data set.

    The primary purpose of the init_loop_ctx call, however, is to initialize
    the loop context data (ref). Here are some simple examples, based on the
    earlier example loop contexts.

      Linked list
      -----------
          ref->itc = my_table_head_ptr;

      Array
      -----
          /* instead of actually allocation memory, just use the pointer */
          /* as an integer */
          (integer)(ref->itc) = 0;

      File
      ----
          ref->itc = SNMP_MALLOC_TYPEDEF(${table}_loop_ctx);
          /* error checking here */
          ref->itc->file_name = (char*) reg->mfd_user_ctx;
          ref->itc->f = fopen( ref->itc->file_name, "r+" );

  @end@


########################################################################
  The Loop
  --------
    TODO : return raw data
    FUNC : ${table}_get_first
    WHERE: ${table}_data_access.c

    @if $mfd_readme_verbose == 1@
    This function returns the first data item in the data set.

    XXX: define "data item"

      Linked list
      -----------
          ctx_ref->ctx->data = loop_ref->itc;

      Array
      -----
          /* assuming registration has array of pointers */
          ctx_ref->ctx->data = reg->mfd_user_ctx[(integer)(ref->itc)];

      File
      ----
          fgets(loop_ref->itc->line, sizeof(loop_ref->itc->line),
                loop_ref->itc->f);
          ctx_ref->ctx->data = loop_ref->itc->line;

    @end@

    TODO : return raw data
    FUNC : ${table}_get_next
    WHERE: ${table}_data_access.c

    @if $mfd_readme_verbose == 1@
    This function returns the next data item in the data set.

      Linked list
      -----------
          loop_ref->itc = loop_ref->itc->next;
          ctx_ref->ctx->data = loop_ref->itc;

      Array
      -----
          ++((integer)(ref->itc));
          /* assuming registration has array of pointers */
          ctx_ref->ctx->data = reg->mfd_user_ctx[(integer)(ref->itc)];

      File
      ----
          fgets(loop_ref->itc->line, sizeof(loop_ref->itc->line),
                loop_ref->itc->f);
          ctx_ref->ctx->data = loop_ref->itc->line;

    @end@


########################################################################
  Updating the Index
  ------------------
    TODO : update index for the raw data
    FUNC : ${table}_update_idx
    WHERE: ${table}_data_access.c

    @if $mfd_readme_verbose == 1@
    This function should update the table index (ctx_ref->ctx->tbl_idx)
    values for the given raw data (ctx_ref->ctx->data).

    @end@


########################################################################
  Saving a position in the loop
  -----------------------------
    TODO : Saving a position in the loop
    FUNC : ${table}_save_position
    WHERE: ${table}_data_access.c
    @if $mfd_readme_verbose == 1@

    During the loop, the save_position function will be called when the index
    for the index for the raw data is the best match for a particular request.
    All loop context data (loop_ref) should be duplicated and saved. If the
    current index ends up being the best match, the saved loop context
    (loop_save) will be passed to get_data.

    @end@


########################################################################
  Returning Data For an Index
  ---------------------------
    TODO : copy transient raw data to generated structure
    FUNC : ${table}_get_data
    WHERE: ${table}_data_access.c
    @if $mfd_readme_verbose == 1@

    After the loop has finished, and the best match for the requested index
    has been found, the get_data function will be called to get a new data
    context from the current data context.

    @end@


########################################################################
  Cleaning up after the loop
  --------------------------
    TODO : release any allocated memory
    FUNC : ${table}_cleanup_loop_ctx
    WHERE: ${table}_data_access.c

    @if $mfd_readme_verbose == 1@
    After the loop ends, the cleanup_loop_ctx function will be
    called. The first parameter is the netsnmp_mfd_registration
    structure created during initialization. If you stored any temporary
    and allocated data in the table's users context (reg->mfd_user_ctx),
    it should be freed at this point.

    The primary purpose of the init_loop_ctx call, is to release any memory
    allocated for the loop context data. Here are some simple examples, based
    on the earlier example loop contexts.

      Linked list
      -----------
          /* nothing to do */

      Array
      -----
          /* nothing to do */

      File
      ----
          free(ref->itc);

    @end@
##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
