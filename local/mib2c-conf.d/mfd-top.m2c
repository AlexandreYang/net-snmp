########################################################################
## generic include for XXX. Don't use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
@open ${name}.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *       version $Revision$ of $RCSfile$ 
 */
@include generic-header-top.m2i@

/* other required module components */
config_require(${name}_interface);
config_require(${name}_data_access);
config_require(${name}_data_get);
config_require(${name}_data_set);

/* OID and column number definitions for table $table */
#include "${name}_oids.h"

/* enum definions */
#include "${name}_enums.h"

/***********************************************************************
 * function declarations
 */
void init_$name(void);

/***********************************************************************
 * Table declarations
 */
@foreach $table table@
@    include m2c_setup_table.m2i@
@    include details-table.m2i@
/*
 * When you register your mib, you get to provide a generic
 * pointer that will be passed back to you for most of the
 * functions calls.
 */
@    if "$m2c_context_reg" eq ""@
    /** TODO: update typedef to correct pointer type.
     * (or add @eval $@m2c_context_reg = "TYPE"@ and regenerate code) */
@        eval $m2c_context_reg = "void *"@

@    end@
typedef $m2c_context_reg ${context}_reg;

@    if "$m2c_data_context" eq ""@
@        include generic-data-context.m2i@
@    end@
/*
 * Use a typedef to map existing data type to ${context}_data.
 */
typedef $m2c_data_context ${context}_data;

@    include generic-table-indexes.m2i@

/*
 * We're just going to use the same data structure for our
 * undo_context. If you want to do something more efficent,
 * define your typedef here.
 */
typedef ${context}_data ${context}_undo_data;

/*
 * When your functions are called, you will be passed a
 * ${context}_ctx pointer.
 */
typedef struct ${context}_ctx_s {
    ${context}_reg    *reg;  /** registration */
    ${context}_idx    *idx;  /** index */

    ${context}_data   *data; /** data */

    ${context}_undo_data * undo;

    /*
     * TODO: add any other useful data
     *       (e.g. flags for when a column has been set)
     */
    
} ${context}_ctx;

@end@

@include generic-header-bottom.m2i@
######################################################################
## Do the .c file
######################################################################
@open ${name}.c@
/*
 * Note: this file originally auto-generated by mbi2c using
 *       version $Revision$ of $RCSfile$ 
 */
@include generic-source-includes.m2i@

/* Initializes the $name module */
void
init_$name(void)
{ 
  /* here we initialize all the tables we're planning on supporting */
  @foreach $table table@
    if (should_init("$table"))
        initialize_table_$table();

  @end@
}

########################################################################
##
@foreach $table table@
@    include m2c_setup_table.m2i@
/*
 * Initialize the table $table 
 *    (Define its contents and how it's structured)
 */
void
initialize_table_$table(void)
{
    static oid ${table}_oid[] = { $table.uc_OID };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /** create the table registration information structures */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    if (!table_info) {
        snmp_log(LOG_ERR, "table_info malloc failed in "
                          "initialize_table_$table");
        return; /** Serious error. */
    }

    /** if your table is read only, it's easiest to change the
        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
    my_handler = netsnmp_create_handler_registration("$table",
                                             ${table}_handler,
                                             ${table}_oid,
                                             OID_LENGTH(${table}_oid),
@if $m2c_table_writable == 1@
                                             HANDLER_CAN_RWRITE
@else@
                                             HANDLER_CAN_RONLY
@end@
);
    if (!my_handler) {
        snmp_log(LOG_ERR, "handler registration failed in "
                          "initialize_table_$table");
        return; /** Serious error. */
    }

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info,
    @foreach $tabledx index@
                                  $tabledx.type, /** index: $tabledx */
    @end@
                             0);

    /** Define the minimum and maximum accessible columns.  This
        optimizes retrival. */
    table_info->min_column = $table.uc_MIN_COL;
    table_info->max_column = $table.uc_MAX_COL;


    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_$table",
                "Registering $table as a mibs-for-dummies table.\n"));		 
    netsnmp_register_table_mfd(my_handler, iinfo);
}

@end@
########################################################################
## Do support files
########################################################################
@run generic-table-oids.m2c@
@run mfd-interface.m2c@
@run mfd-data-access.m2c@
@run mfd-data-get.m2c@
@run mfd-data-set.m2c@
##@run mib2c.column_enums.conf@
##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
