########################################################################
## generic include for XXX. Don't use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
/*
 * ${context}_allocate_context
 *
 * Purpose: create new data context.
 *
 */
int
${context}_allocate_context( ${context}_reg *reg, 
                             ${context}_ctx **ctx_ptr_ptr )
{
@if $m2c_get_use_temp == 1@
@    eval $m2c_node_lh = "ctx_ptr"@
    ${context}_ctx *ctx_ptr;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != ctx_ptr_ptr );

    ctx_ptr = (*ctx_ptr_ptr);

@else@
@    eval $m2c_node_lh = "(* ctx_ptr_ptr)"@
@end@
    /*
     * allocate memory for the context
     */
$example_start
    $m2c_node_lh = SNMP_MALLOC_STRUCT(${context}_ctx);
    if(NULL == $m2c_node_lh) {
        snmp_log(LOG_ERR,
                 "unable to malloc memory for new row context for the "
                 "${table} table.\n");
        return SNMP_ERR_GENERR;
    }

    $m2c_node_lh->data = SNMP_MALLOC_STRUCT(${context}_data);
    if(NULL == $m2c_node_lh->data) {
        snmp_log(LOG_ERR,
                 "unable to malloc memory for new data context for the "
                 "${table} table.\n");
        free(ctx_ptr);
        return SNMP_ERR_GENERR;
    }
$example_end

@if $m2c_get_use_temp == 1@
    /*
     * set the pointer to the memory we allocated
     */
    (*ctx_ptr_ptr) = ctx_ptr;
@end@

    return SNMP_ERR_NOERROR;
}

/*
 * ${context}_create_context
 *
 * Purpose: create new data context, if specified index is valid.
 *
 */
int
${context}_create_context( ${context}_reg *reg, ${context}_idx *idx,
                        ${context}_ctx **ctx_ptr_ptr )
{
    int rc;
@if $m2c_get_use_temp == 1@
@    eval $m2c_node_lh = "ctx_ptr"@
    ${context}_ctx *ctx_ptr;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != ctx_ptr_ptr );

    ctx_ptr = (*ctx_ptr_ptr);

@else@
@    eval $m2c_node_lh = "(* ctx_ptr_ptr)"@
@end@
    /*
     * TODO: Validate incoming index
     * Check that the values specified in the incoming index are valid
     * values.
     */
$example_start
    /** TODO: no row creation for you till you update this code */
    if(1) {
        snmp_log(LOG_WARN,"invalid index for a new row in the "
                 "${table} table.\n");
        /*
         * TODO: determine failure type.
         * If the index could not ever be created, SNMP_ERR_NOCREATION.
         * If the index can not be created under the  present circumstances
         * (even though it could be created under other circumstances),
         * SNMP_ERR_INCONSISTENTNAME.
         */
        if(1) {
            return SNMP_ERR_NOCREATION;
        }
        else {
            return SNMP_ERR_INCONSISTENTNAME;
        }
    }
$example_end

    /*
     * allocate memory for the context
     */
    rc = ${context}_allocate_context( reg, ctx_ptr_ptr );
    if(SNMP_ERR_NOERROR != rc) {
        /** msg already logged */
        return SNMP_ERR_GENERR;
    }

    /*
     * Save index. If index has no owner, assume ownership
     */
    $m2c_node_lh->idx = idx;
    if(NULL == idx->owner)
        idx->owner = $m2c_node_lh;

@if $m2c_get_use_temp == 1@
    /*
     * set the pointer to the memory we allocated
     */
    (*ctx_ptr_ptr) = ctx_ptr;
@end@

    return SNMP_ERR_NOERROR;
}

/*
 * ${context}_create_undo
 *
 * Create an 
 */
int
${context}_create_undo(${context}_reg *reg, ${context}_ctx *ctx,
                    ${context}_undo_ctx **undo_ctx_ptr_ptr )
{
    int rc;
@if $m2c_get_use_temp == 1@
@    eval $m2c_node_ctx = "undo_ctx_ptr"@
    ${context}_undo_ctx *undo_ctx_ptr;

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != undo_ctx_ptr_ptr );

@else@
@    eval $m2c_node_ctx = "(* undo_ctx_ptr_ptr)"@
@end@
    /*
     * allocate context
     */
    rc = ${context}_allocate_context( reg, undo_ctx_ptr_ptr );
    if(SNMP_ERR_NOERROR != rc) {
        /** msg already logged */
        return SNMP_ERR_GENERR;
    }
@if $m2c_get_use_temp == 1@
    $m2c_node_ctx = (* undo_ctx_ptr_ptr);
@end@

    /*
     * copy the data
     */
@    foreach $node nonindex@
@        include m2c_setup_node.m2i@
@        eval $m2c_ctx_lh = "$m2c_node_ctx"@
@        eval $m2c_ctx_rh = "ctx"@
@        include generic-ctx-copy.m2i@
@    end@ # foreach nonindex
$example_end
@if $m2c_get_use_temp == 1@
    /*
     * set the pointer to the memory we allocated
     */
    (*undo_ctx_ptr_ptr) = undo_ctx_ptr;

@end@
    return SNMP_ERR_NOERROR;
}

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
