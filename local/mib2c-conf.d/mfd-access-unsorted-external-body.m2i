#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
$example_start
${table}_list * ${table}_head = NULL;
$example_end

/*
 * init_data is called during startup.
 * Allocate any resources you need for the data table.
 */
int
${table}_init_data(netsnmp_mfd_registration *reg)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@ifconf ${table}_init_data.m2i@
@   include ${table}_init_data.m2i@
@else@
$example_start
    /** alloc memory for our dummy list */
    if(NULL == ${table}_head)
        ${table}_head = SNMP_MALLOC_TYPEDEF(${table}_list);
$example_end
@end@

    return SNMPERR_SUCCESS;
}

@if $m2c_data_transient != 0@ # 
/*
 * return ${table}_data from a data context
 */
int
${table}_get_data( netsnmp_mfd_registration *reg, ${table}_ref_loop *loop_ref,
                           ${table}_ref_ctx *ctx_ref)
{
    ${table}_ctx *orig_ctx = ctx_ref->ctx;
    
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    /*
     * copy to a new context
     */
    ctx_ref->ctx = ${table}_allocate_ctx(reg);
    if(NULL == ctx_ref->ctx)
        return SNMPERR_GENERR;

    /* copy index */
    memcpy(&ctx_ref->ctx->tbl_idx, &loop_ref->itc->ctx.tbl_idx,
           sizeof(${table}_idx));

    ctx_ref->ctx->oid_idx.len = loop_ref->itc->ctx.oid_idx.len;
    ctx_ref->ctx->oid_idx.oids = ctx_ref->ctx->oid_tmp;
    memcpy(ctx_ref->ctx->oid_idx.oids,
           loop_ref->itc->ctx.oid_idx.oids,
           ctx_ref->ctx->oid_idx.len * sizeof(oid));

$example_start
@   foreach $node nonindex@
@      include m2c_setup_node.m2i@
    /** TODO: set ctx_ref->ctx->data->$node
@      if $m2c_data_transient == 1@ # short term
     **       from loop_ref->pos (${table}_list) */
@      else@
     **       from orig_ctx->data->$node */
@      end@
@   end@
$example_end

   return SNMPERR_SUCCESS;
}

@end@
/*
 * Update the index for the current iterator position.
 */
int
${table}_update_idx( netsnmp_mfd_registration *reg, ${table}_ref_loop *loop_ref,
                     ${table}_ref_ctx *ctx_ref)
{
    int rc;

    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

@ifconf ${table}_update_idx.m2i@
@   include ${table}_update_idx.m2i@
@else@
$example_start
    /*
     * check for end of data
     */
    if(NULL == loop_ref->itc->pos)
        return SNMPERR_NO_VARS;

    /*
     * mfd wrappers just need the index for now.
     * set the index structure to the values that correspond to this row.
     * reuse ctx.tbl_idx.
     */
    ctx_ref->ctx = &loop_ref->itc->ctx;

@foreach $node index@
@    include m2c_setup_node.m2i@
    /** TODO: set ctx_ref->tbl_idx->$node */
@end@
$example_end
@end@

    return rc;
}

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/*
 * 
 */
int
${table}_init_loop_ctx( netsnmp_mfd_registration *reg, ${table}_ref_loop *ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

$example_start
    /*
     * Set the my_loop_context variable to the first data point structure
     * of your choice (from which you can find the next one).  This could
     * be anything from the first node in a linked list, to an integer
     * pointer containing the beginning of an array variable.
     */
    /** TODO: set real loop context */
    ref->itc = SNMP_MALLOC_TYPEDEF(${table}_loop_ctx);
    if(NULL == ref->itc)
        return SNMPERR_GENERR;

    ref->itc->pos = ${table}_head;

    /*
     * temp storage for indexes
     */
    /** xxx-rks: do this w/out varbind clone/free? */
    ref->itc->idx_vars = snmp_clone_varbind(reg->table_info->indexes);
    if(NULL == ref->itc->idx_vars) {
        SNMP_FREE(ref->itc);
        return SNMPERR_GENERR;
    }

    ref->itc->ctx.oid_idx.oids = ref->itc->ctx.oid_tmp;
$example_end

    return SNMPERR_SUCCESS;
}

/*
 * returns the first data point within the $table table data.
 */
int
${table}_cleanup_loop_ctx( netsnmp_mfd_registration *reg, ${table}_ref_loop *ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));
    
$example_start
    if(!ref->itc)
        return SNMPERR_GENERR;

    if(ref->itc->ctx.oid_idx.oids != ref->itc->ctx.oid_tmp)
        free(ref->itc->ctx.oid_idx.oids);
 
    /*
     * free varbind
     */
    if(ref->itc->idx_vars)
        snmp_free_varbind( ref->itc->idx_vars );

    /*
     * free loop context
     */
    free(ref->itc);
$example_end

    return SNMPERR_SUCCESS;
}

/*
 *
 */
int
${table}_save_position(netsnmp_mfd_registration *reg,
                       ${table}_ref_loop *loop_ref,
                       ${table}_ref_loop *loop_save)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

$example_start
    /*
     * allocate new loop context
     */
    loop_save->itc = SNMP_MALLOC_TYPEDEF(${table}_loop_ctx);
    if(NULL == loop_save->itc) {
        snmp_log(LOG_ERR, "could not allocate memory\n");
        return SNMP_ERR_GENERR;
    }

    /*
     * save pos
     */
    loop_save->itc->pos = loop_ref->itc->pos;

    /*
     * copy tbl_idx
     */
    memcpy(&loop_save->itc->ctx.tbl_idx, &loop_ref->itc->ctx.tbl_idx,
           sizeof(${table}_idx));

    /*
     * copy oid_idx
     */
    loop_save->itc->ctx.oid_idx.len = loop_ref->itc->ctx.oid_idx.len;
    loop_save->itc->ctx.oid_idx.oids = loop_save->itc->ctx.oid_tmp;
    memcpy(loop_save->itc->ctx.oid_idx.oids, loop_ref->itc->ctx.oid_idx.oids,
           loop_save->itc->ctx.oid_idx.len * sizeof(oid));

@if $m2c_data_transient == 0@ # persistent
    /** non-TRANSIENT data: no need to copy */
@elsif $m2c_data_transient == 1@ # short term
    /** semi-TRANSIENT data: will copy data when index found */
@elsif $m2c_data_transient == 2@ # copy immediately
    /*
     * TRANSIENT data: data is external and you have no control over it.
     * So we need to copy the data.
     */
@   foreach $node nonindex@
@      include m2c_setup_node.m2i@
    /** TODO: set ctx_ref->ctx->data->$node
     **       from loop_ref->pos (${table}_list) */
@   end@
@end@
$example_end

    return SNMPERR_SUCCESS;
}

/*
 *
 */
int
${table}_get_first( netsnmp_mfd_registration *reg, ${table}_ref_loop *loop_ref,
                    ${table}_ref_ctx *ctx_ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    /*
     * use ctx in loop ref
     */
    ctx_ref->ctx = &loop_ref->itc->ctx;
    
$example_start
    return ${table}_update_idx(reg, loop_ref, ctx_ref);
$example_end
}

/*
 *
 */
int
${table}_get_next( netsnmp_mfd_registration *reg, ${table}_ref_loop *loop_ref,
                        ${table}_ref_ctx *ctx_ref)
{
    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

$example_start
    /*
     * check for end of data
     */
    if(NULL == loop_ref->itc->pos)
        return SNMPERR_NO_VARS;

    /*
     * advance iterator
     */
    loop_ref->itc->pos = loop_ref->itc->pos->next;

    return ${table}_update_idx(reg, loop_ref, ctx_ref);
$example_end
}

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
