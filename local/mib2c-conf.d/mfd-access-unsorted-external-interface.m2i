#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
@include mfd-access-unsorted-external-setup.m2i@
##

/**
 * @internal
 * wrapper around init_context
 */
static int
_${table}_loop_init_context( $mfd_aue_wrap_param_decl,
                        ${context}_ref_loop_ctx *ref)
{
   DEBUGTRACE;

   netsnmp_assert(NULL != $mfd_aue_wrap_param);
   
   return ${table}_loop_init_context($mfd_aue_wrap_param->user_ctx, ref);
}

/**
 * @internal
 * wrapper around clean up a loop reference
 */
static int
_${table}_loop_cleanup_context( $mfd_aue_wrap_param_decl,
                            ${context}_ref_loop_ctx *ref)
{
   DEBUGTRACE;

   return ${table}_loop_cleanup_context($mfd_aue_wrap_param->user_ctx, ref);
}

/**
 * @internal
 * wrapper around save position
 */
static int
_${table}_loop_save_position( $mfd_aue_wrap_param_decl, ${context}_ref_loop_ctx *ref,
                         ${context}_ref_loop_ctx *ref_copy, int reuse)
{
   DEBUGTRACE;

   return ${table}_loop_save_position($mfd_aue_wrap_param->user_ctx, ref,
                                 ref_copy, reuse);
}

/**
 * @internal
 * wrapper around user get_first to setup the index oid
 */
static int
_${table}_loop_get_first_wrapper($mfd_aue_wrap_param_decl,
                           ${context}_ref_loop_ctx * loop_ctx_ref,
                           ${context}_ref_rowreq_ctx * rowreq_ctx_ref)
{
    int rc;
    DEBUGTRACE;

    rc = ${table}_loop_get_first($mfd_aue_wrap_param->user_ctx, loop_ctx_ref,
                                 rowreq_ctx_ref);
    /*
     * convert index to OID
     */
    if(SNMPERR_SUCCESS == rc ) {
        netsnmp_assert((NULL != rowreq_ctx_ref) &&
                       (rowreq_ctx_ref->rowreq_ctx->oid_idx.oids == rowreq_ctx_ref->rowreq_ctx->oid_tmp));
        rowreq_ctx_ref->rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx_ref->rowreq_ctx->oid_tmp);
        rc = ${table}_index_to_oid(&rowreq_ctx_ref->rowreq_ctx->oid_idx,
                                   &rowreq_ctx_ref->rowreq_ctx->tbl_idx);
        netsnmp_assert(rowreq_ctx_ref->rowreq_ctx->oid_idx.len !=
                       sizeof(rowreq_ctx_ref->rowreq_ctx->oid_tmp));
    }

    return rc;
}

/**
 * @internal
 * wrapper around user get_next to setup the index oid
 */
static int
_${table}_loop_get_next_wrapper($mfd_aue_wrap_param_decl,
                          ${context}_ref_loop_ctx * loop_ctx_ref,
                          ${context}_ref_rowreq_ctx * rowreq_ctx_ref)
{
    int rc;
    DEBUGTRACE;

    rc = ${table}_loop_get_next($mfd_aue_wrap_param->user_ctx, loop_ctx_ref,
                                rowreq_ctx_ref);
    /*
     * convert index to OID
     */
    if(SNMPERR_SUCCESS == rc ) {
        netsnmp_assert((NULL != rowreq_ctx_ref) &&
                       (rowreq_ctx_ref->rowreq_ctx->oid_idx.oids == rowreq_ctx_ref->rowreq_ctx->oid_tmp));
        rowreq_ctx_ref->rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx_ref->rowreq_ctx->oid_tmp);
        rc = ${table}_index_to_oid(&rowreq_ctx_ref->rowreq_ctx->oid_idx,
                                   &rowreq_ctx_ref->rowreq_ctx->tbl_idx);
        netsnmp_assert(rowreq_ctx_ref->rowreq_ctx->oid_idx.len !=
                       sizeof(rowreq_ctx_ref->rowreq_ctx->oid_tmp));
    }

    return rc;
}

/**
 * @internal
 * get data wrapper to allocate context for the user
 */
static int
_${table}_loop_get_data_wrapper($mfd_aue_wrap_param_decl,
                           ${context}_ref_loop_ctx * loop_ctx_ref,
                           ${context}_ref_rowreq_ctx * rowreq_ctx_ref)
{
    ${context}_rowreq_ctx *orig_ctx = rowreq_ctx_ref->rowreq_ctx;
    int rc;

    DEBUGTRACE;

    return ${table}_loop_get_data($mfd_aue_wrap_param->user_ctx, loop_ctx_ref, rowreq_ctx_ref);
}

/**
 * @internal
 * initialize the iterator container with functions or wrappers
 */
netsnmp_container *
_${table}_container_init(${context}_interface_ctx *if_ctx)
{
    netsnmp_container *c;

    DEBUGTRACE;
    
    c = netsnmp_container_iterator_get(/** registration */
        if_ctx,
        /** compare */
        NULL,
        /** get_first */
        (Netsnmp_Iterator_Loop_Key*)_${table}_loop_get_first_wrapper,
        /** get_next */
        (Netsnmp_Iterator_Loop_Key*)_${table}_loop_get_next_wrapper,
        /** get_data */
        (Netsnmp_Iterator_Loop_Data*)_${table}_loop_get_data_wrapper,
        /** save_pos */
        (Netsnmp_Iterator_Ctx_Dup*)_${table}_loop_save_position,
        /** init_context */
        (Netsnmp_Iterator_Ctx*)_${table}_loop_init_context,
        /** cleanup_context */
        (Netsnmp_Iterator_Ctx*)_${table}_loop_cleanup_context,
        /** free_user_ctx */
        NULL,
        /** sorted */
        0);
    
    return c;
}

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
