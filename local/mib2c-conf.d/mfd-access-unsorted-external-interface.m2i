#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
/**
 * @internal
 * convert the index component stored in the context to an oid
 */
static int
_${table}_index2oid(netsnmp_mfd_registration *mfd_reg,
                   ${table}_ref_loop *loop_ref,
                   ${table}_ref_ctx *ctx_ref)
{
    /** xxx-rks: do this w/out varbind clone/free? */
    static netsnmp_variable_list *idx_vars = NULL;

    DEBUGMSGT(("${name}:trace",">%s\n",__FUNCTION__));

    if(NULL == idx_vars) {
        idx_vars = snmp_clone_varbind(mfd_reg->table_info->indexes);
        if(NULL == idx_vars)
            return SNMPERR_GENERR;
    }
    else {
        /*
         * free memory from last time
         */
        snmp_reset_var_buffers( idx_vars );
    }


@    eval $mfd_temp = "idx_vars"@
@    foreach $node index@
@        include m2c_setup_node.m2i@
        /* $m2c_node_summary */
@        if $m2c_node_needlength == 1@
    snmp_set_var_value($mfd_temp, (u_char*)&ctx_ref->ctx->tbl_idx.$node,
                       ctx_ref->ctx->tbl_idx.${node}_len);
@        else@
    snmp_set_var_value($mfd_temp, (u_char*)&ctx_ref->ctx->tbl_idx.$node,
                       sizeof(ctx_ref->ctx->tbl_idx.$node));
@        end@

@        eval $mfd_temp = "${mfd_temp}->next_variable"@
@    end@ # for each column

    return build_oid_noalloc(ctx_ref->ctx->oid_tmp, MAX_OID_LEN,
                      &ctx_ref->ctx->oid_idx.len,
                      NULL, 0, idx_vars);
}

/**
 * @internal
 * wrapper around user get_first to setup the index oid
 */
static int
_${table}_get_first_wrapper($mfd_aue_param_decl,
                           ${table}_ref_loop * loop_ref,
                           ${table}_ref_ctx * ctx_ref)
{
    int rc;
    DEBUGMSGT(("${name}:trace", ">%s\n", __FUNCTION__));

    rc = ${table}_get_first(mrc, loop_ref, ctx_ref);

    /*
     * convert index to OID
     */
    if(SNMPERR_SUCCESS == rc )
        rc = _${table}_index2oid(mrc->mfd_reg, loop_ref, ctx_ref);

    return rc;
}

/**
 * @internal
 * wrapper around user get_next to setup the index oid
 */
static int
_${table}_get_next_wrapper($mfd_aue_param_decl,
                          ${table}_ref_loop * loop_ref,
                          ${table}_ref_ctx * ctx_ref)
{
    int rc;
    DEBUGMSGT(("${name}:trace", ">%s\n", __FUNCTION__));

    rc = ${table}_get_next(mrc, loop_ref, ctx_ref);

    /*
     * convert index to OID
     */
    if(SNMPERR_SUCCESS == rc )
        rc = _${table}_index2oid(mrc->mfd_reg, loop_ref, ctx_ref);

    return rc;
}

/**
 * @internal
 * get data wrapper to allocate context for the user
 */
static int
_${table}_get_data_wrapper($mfd_aue_param_decl,
                           ${table}_ref_loop * loop_ref,
                           ${table}_ref_ctx * ctx_ref)
{
    ${table}_ctx *orig_ctx = ctx_ref->ctx;
    int rc;

    DEBUGMSGT(("${name}:trace", ">%s\n", __FUNCTION__));

    /*
     * create a new context
     */
    netsnmp_assert(NULL == ctx_ref->ctx);
    ctx_ref->ctx = _${table}_allocate_ctx(mrc->mfd_reg);
    if(NULL == ctx_ref->ctx)
        return SNMPERR_GENERR;

    return ${table}_get_data(mrc, loop_ref, ctx_ref);
}

/**
 * @internal
 * initialize the iterator container with functions or wrappers
 */
netsnmp_container *
${table}_container_init(netsnmp_mfd_registration *reg)
{
    netsnmp_container *c;

    DEBUGMSGT(("${name}:trace",">%s",__FUNCTION__));
    
    c = netsnmp_container_iterator_get(/** registration */
        reg,
        /** compare */
        NULL,
        /** get_first */
        (Netsnmp_Iterator_Loop_Key*)_${table}_get_first_wrapper,
        /** get_next */
        (Netsnmp_Iterator_Loop_Key*)_${table}_get_next_wrapper,
        /** get_data */
        (Netsnmp_Iterator_Loop_Data*)_${table}_get_data_wrapper,
        /** save_pos */
        (Netsnmp_Iterator_Ctx_Dup*)${table}_save_position,
        /** init_loop_ctx */
        (Netsnmp_Iterator_Ctx*)${table}_init_loop_ctx,
        /** cleanup_loop_ctx */
        (Netsnmp_Iterator_Ctx*)${table}_cleanup_loop_ctx,
        /** free_user_ctx */
        NULL,
        /** sorted */
        0);
    
    ${table}_init_data(reg);
    
    return c;
}

##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
