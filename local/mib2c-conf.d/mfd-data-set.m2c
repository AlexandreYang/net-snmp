#############################################################  -*- c -*-
## generic include for XXX. Do not use directly.
##
## $Id$
########################################################################
@if $m2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
##
@open ${name}_data_set.h@
/*
 * Note: this file originally auto-generated by mib2c using
 *       version $Revision$ of $RCSfile$ 
 */
@eval $m2c_save = "$name"@
@eval $name = "${name}_DATA_SET"
@include generic-header-top.m2i@
@eval $name = "$m2c_save"@

/* *********************************************************************
 * function declarations
 */

/* *********************************************************************
 * Table declarations
 */
@foreach $table table@
@    include m2c_setup_table.m2i@
@    include details-table.m2i@
@    foreach $node externalindex@
@        include m2c_setup_node.m2i@
    int ${table}_${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx );
@    end@ # foreach externalindex
@    foreach $node internalindex@
@        include m2c_setup_node.m2i@
int ${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx );
@    end@ # foreach internalindex
int ${context}_validate_index( ${context}_registration_ptr ${context}_reg,
                               ${context}_rowreq_ctx *rowreq_ctx );

@    foreach $node nonindex@
@        include m2c_setup_node.m2i@
int ${node}_check_value( ${context}_rowreq_ctx *rowreq_ctx, $m2c_node_param_val);
int ${node}_undo_setup( ${context}_rowreq_ctx *rowreq_ctx );
int ${node}_set( ${context}_rowreq_ctx *rowreq_ctx, $m2c_node_param_val );
int ${node}_undo( ${context}_rowreq_ctx *rowreq_ctx );

@    end@ # foreach nonindex

@end@
int ${context}_check_dependencies(${context}_rowreq_ctx *ctx);

@eval $m2c_save = "$name"@
@eval $name = "${name}_DATA_SET"
@include generic-header-bottom.m2i@
@eval $name = "$m2c_save"@
######################################################################
##
@open ${name}_data_set.c@
/*
 * Note: this file originally auto-generated by mib2c using
 *       version $Revision$ of $RCSfile$ 
 */
@include generic-source-includes.m2i@

@foreach $table table@
@    include m2c_setup_table.m2i@
@    if $m2c_table_settable == 0@
@        break@ # skip to next table
@    end@
@    include details-table.m2i@
########################################################################
##
########################################################################
##@    if "$m2c_data_allocate" eq "yes" && "$m2c_data_context" ne "generated"@
@        include parent-set.m2i@
##@    end@
########################################################################
##
########################################################################
##@    if $m2c_table_external_indexes != 0@
@    foreach $node externalindex@
@        include m2c_setup_node.m2i@
@        print | |   +-> Processing index $node@
@        include details-node.m2i@
/**
 * check validity of ${node} external index portion
 *
 * NOTE: this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ${context}_validate_index() function.
 *
 * @return MFD_SUCCESS   : the incoming value is legal
 *         MFD_BAD_VALUE : the incoming value is NOT legal
 */
int
${table}_${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx )
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for the external index $node is legal
     */

    /* if everything looks ok, return MFD_SUCCESS */
      return MFD_SUCCESS;
}

@    end@ # foreach externalindex
##@    end@ # external indexes
########################################################################
@    foreach $node internalindex@
@        include m2c_setup_node.m2i@
@        print | |   +-> Processing index $node@
@        include details-node.m2i@
/**
 * check validity of ${node} index portion
 *
 * NOTE: this is not the place to do any checks for the sanity
 *       of multiple indexes. Those types of checks should be done in the
 *       ${context}_validate_index() function.
 *
 * @return MFD_SUCCESS   : the incoming value is legal
 *         MFD_BAD_VALUE : the incoming value is NOT legal
 */
int
${node}_check_index( ${context}_rowreq_ctx *rowreq_ctx )
{
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * check that index value in the table context (rowreq_ctx)
     * for $node is legal
     */

    /* if everything looks ok, return MFD_SUCCESS */
      return MFD_SUCCESS;
}

@    end@ # foreach internalindex
########################################################################
##
########################################################################
@    foreach $node nonindex@
@        include m2c_setup_node.m2i@
@        if $node.settable == 0@
@            break@ # skip to next column
@        end@
@        print | |   +-> Processing nonindex $node@
@        include details-node.m2i@
@        include node-set.m2i@
@    end@ # foreach column
########################################################################
@    if $m2c_table_dependencies == 1@
@        include parent-dependencies.m2i@
@    end@
########################################################################
@end@ # foreach table
##
########################################################################
##
########################################################################
@if $m2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
