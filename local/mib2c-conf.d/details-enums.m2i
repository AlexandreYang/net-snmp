########################################################################
## generic include for enums. Don't use directly.
##
## $Id$
########################################################################
@if $mib2c_mark_boundary == 1@
/** START code generated by $RCSfile$ $Revision$ */
@end@
########################################################################
@ifconf $node.syntax.m2i@
@   include $node.syntax.m2i@
@else@
/*
 * constants for enums for the MIB node $node
 */
@    if $node.syntax ne $node.perltype@
@        eval $mib2c_de_pfx = "${mib2c_const_pfx}$node.syntax"@
@    else@
@        eval $mib2c_de_pfx = "${mib2c_const_pfx}$node"@
@    end@
@    if $mib2c_const_lc == 0@
@        eval $mib2c_de_pfx = uc($mib2c_de_pfx)@
@    end@
@    if $node.syntax ne $node.perltype@
#ifndef ${mib2c_de_pfx}_ENUMS
#define ${mib2c_de_pfx}_ENUMS
@    end@
@    foreach $e $v enum@
@        eval $mib2c_ename = "${mib2c_de_pfx}_${e}"@
@        if $mib2c_const_lc == 0@
@            eval $mib2c_ename = uc($mib2c_ename)@
@        end@
@        if "$node.perltype" eq "BITS"@
$mib2c_const_dcl $mib2c_ename $mib2c_const_del (1 << (31-$v)) $mib2c_const_sfx
@        else@
$mib2c_const_dcl $mib2c_ename $mib2c_const_del $v $mib2c_const_sfx
@        end@
@    end@ # for each
@    if $node.syntax ne $node.perltype@
#endif /* $node.syntax_ENUMS */
@    end@
@    if "$node.perltype" eq "BITS"@

@        foreach $e $v enum@
@            eval $mib2c_ename = "${mib2c_const_pfx}$node.uc_$e.uc"@
@            if $mib2c_const_lc == 0@
@                eval $mib2c_ename = uc($mib2c_ename)@
@            end@
/*
 * TODO: IS_SET_$mib2c_ename
 * This macro can be used if there is a simple, direct way to determine
 * if this bit defined for the MIB object ${node} from
 * data in your ${table}_ctx.
 * Return 1 if the bit should be set, or 0 if it should not be set.
 */
#define IS_SET_$mib2c_ename(${node}_ctx_ptr) \
        (${node}_ctx_ptr != NULL)

@        end@ # for each
@    end@ # ne BITS
@    if $node.syntax ne $node.perltype@
    /*
     * TODO: value mapping
     * If the values for your data type don't exactly match the
     * possible values defined by the mib, you should map them
     * here. For example, a boolean flag (1/0) is usually represented
     * as a TruthValue in a MIB, which maps to the values (1/2).
     */
@        if $node.enums@
@            foreach $e $v enum@
@                eval $mib2c_ename = "${mib2c_const_pfx}${node}_${e}"@
@                if $mib2c_const_lc == 0@
@                    eval $mib2c_ename = uc($mib2c_ename);@
@                end@
$mib2c_const_dcl INTERNAL_$mib2c_ename $mib2c_const_del $v $mib2c_const_sfx
@             end@
@         end@
@    end@
@end@ # ! syntax include
########################################################################
@if $mib2c_mark_boundary == 1@
/** END code generated by $RCSfile$ $Revision$ */
@end@
