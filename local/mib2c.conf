# 
# Define types of data by mib type, and translate into needed C code.
#
# source variable typing information:
include: mib2c.vartypes.conf
#
# Begin code template section
############################################################################
# variable statemnts used in a couple of places below
############################################################################
type:	code-varInits
code:	  /* variables we may use later */
code:	  static long long_ret;
code:	  static unsigned char string[SPRINT_MAX_LEN];
code:	  static oid objid[MAX_OID_LEN];
code:	  static struct counter64 c64;
############################################################################
# The .h file
############################################################################
type:	code-dot-c-init
code:	/* This file was generated by mib2c and is intended for use as a mib module
code:	  for the ucd-snmp snmpd agent. */
code:
code:	#ifndef _MIBGROUP_${OUTPUTNAME}_H
code:	#define _MIBGROUP_${OUTPUTNAME}_H
code:	
code:	/* we may use header_generic and header_simple_table from the util_funcs module */
code:	
code:	config_require(util_funcs)
code:	
code:	/* function prototypes */
code:	
code:	void   init_$outputName(void);
code:	unsigned char *var_$outputName(struct variable *, oid *, int *, int, int *, WriteMethod **write_method);
code:	$functionInfo
code:	
code:	#endif /* _MIBGROUP_${OUTPUTNAME}_H */
############################################################################
# The .c file, top
############################################################################
type:	code-main-part
code:	/* This file was generated by mib2c and is intended for use as a mib module
code:	   for the ucd-snmp snmpd agent. */
code:	
code:	/* This should always be included first before anything else */
code:	#include <config.h>
code:	
code:	/* minimal include directives */
code:	#include \"mibincl.h\"
code:	#include \"util_funcs.h\"
code:	#include \"$outputName.h\"
code:	
code:	/* 
code:	 * ${outputName}_variables_oid:
code:	 *   this is the top level oid that we want to register under.  This
code:	 *   is essentially a prefix, with the suffix appearing in the
code:	 *   variable below.
code:	 */
code:	
code:	oid ${outputName}_variables_oid[] = { $commaoid };
code:	
code:	/* 
code:	 * variable$varlen ${outputName}_variables:
code:	 *   this variable defines function callbacks and type return information 
code:	 *   for the $outputName mib section 
code:	 */
code:	
code:	struct variable$varlen ${outputName}_variables[] = {
code:	/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
code:	$structinfo
code:	};
code:	/*    (L = length of the oidsuffix) */
code:	
code:	/*
code:	 * init_$outputName():
code:	 *   Initialization routine.  This is called when the agent starts up.
code:	 *   At a minimum, registration of your variables should take place here.
code:	 */
code:	void init_$outputName(void) {
code:	
code:	  /* register ourselves with the agent to handle our mib tree */
code:	  REGISTER_MIB(\"$outputName\", ${outputName}_variables, variable$varlen,\
code:	               ${outputName}_variables_oid);
code:	
code:	  /* place any other initialization junk you need here */
code:	}
code:	
code:	/*
code:	 * var_$outputName():
code:	 *   This function is called every time the agent gets a request for
code:	 *   a scalar variable that might be found within your mib section
code:	 *   registered above.  It is up to you to do the right thing and
code:	 *   return the correct value.
code:	 *     You should also correct the value of \"var_len\" if necessary.
code:	 *
code:	 *   Please see the documentation for more information about writing
code:	 *   module extensions, and check out the examples in the examples
code:	 *   and mibII directories.
code:	 */
code:	unsigned char *
code:	var_$outputName(struct variable *vp, 
code:	                oid     *name, 
code:	                int     *length, 
code:	                int     exact, 
code:	                int     *var_len, 
code:	                WriteMethod **write_method)
code:	{
code:	
code:	$variableTypes{'code-varInits'}{'code'}
code:	
code:	  if (header_generic(vp,name,length,exact,var_len,write_method)
code:	                                  == MATCH_FAILED )
code:	    return NULL;
code:	
code:	  /* 
code:	   * this is where we do the value assignments for the mib results.
code:	   */
code:	  switch(vp->magic) {\n\n
code:	$caseStatements{$outputName}\n
code:	    default:
code:	      ERROR_MSG(\"\");
code:	  }
code:	  return NULL;
code:	}
############################################################################
# var_ function for tables, which is handled specially
#   $vtable is set to the table name
############################################################################
type:		code-var_table
code:	/*
code:	 * var_$vtable():
code:	 *   Handle this table separately from the scalar value case.
code:	 *   The workings of this are basically the same as for var_$outputName above.
code:	 */
code:	unsigned char *
code:	var_$vtable(struct variable *vp,
code:	    	    oid     *name,
code:	    	    int     *length,
code:	    	    int     exact,
code:	    	    int     *var_len,
code:	    	    WriteMethod **write_method)
code:	{
code:	
code:	$variableTypes{'code-varInits'}{'code'}
code:	
code:	  /* 
code:	   * This assumes that the table is a \'simple\' table.
code:	   *	See the implementation documentation for the meaning of this.
code:	   *	You will need to provide the correct value for the TABLE_SIZE parameter
code:	   *
code:	   * If this table does not meet the requirements for a simple table,
code:	   *	you will need to provide the replacement code yourself.
code:	   *	Mib2c is not smart enough to write this for you.
code:	   *    Again, see the implementation documentation for what is required.
code:	   */
code:	  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
code:	                                                == MATCH_FAILED )
code:	    return NULL;
code:	
code:	  /* 
code:	   * this is where we do the value assignments for the mib results.
code:	   */
code:	  switch(vp->magic) {\n\n
code:	$caseStatements{$vtable}\n
code:	    default:
code:	      ERROR_MSG(\"\");
code:	  }
code:	  return NULL;
code:	}
############################################################################
# write function defitition
############################################################################
type:	code-write-func
code:	int
code:	write_$name(int      action,
code:	            u_char   *var_val,
code:	            u_char   var_val_type,
code:	            int      var_val_len,
code:	            u_char   *statP,
code:	            oid      *name,
code:	            int      name_len)
code:	{
code:	  $variableTypes{$type}{writeInit}
code:	  int size, bigsize=SNMP_MAX_LEN;
code:	
code:	  switch ( action ) {
code:	        case RESERVE1:
code:	          if (var_val_type != $variableTypes{$type}{asnType}){
code:	              fprintf(stderr, \"write to $name not $variableTypes{$type}{asnType}\\n\");
code:	              return SNMP_ERR_WRONGTYPE;
code:	          }
code:	          if (var_val_len > sizeof($variableTypes{$type}{variable})){
code:	              fprintf(stderr,\"write to $name: bad length\\n\");
code:	              return SNMP_ERR_WRONGLENGTH;
code:	          }
code:	          break;
code:	
code:	        case RESERVE2:
code:	          size = *var_val_len;
code:	          $variableTypes{$type}{variable} = $variableTypes{$type}{cast} var_val;
code:	
code:	          break;
code:	
code:	        case FREE:
code:	             /* Release any resources that have been allocated */
code:	          break;
code:	
code:	        case ACTION:
code:	             /* The variable has been stored in $variableTypes{$type}{variable} for
code:	             you to use, and you have just been asked to do something with
code:	             it.  Note that anything done here must be reversable in the UNDO case */
code:	          break;
code:	
code:	        case UNDO:
code:	             /* Back out any changes made in the ACTION case */
code:	          break;
code:	
code:	        case COMMIT:
code:	             /* Things are working well, so it's now safe to make the change
code:	             permanently.  Make sure that anything done here can't fail! */
code:	          break;
code:	  }
code:	  return SNMP_ERR_NOERROR;
code:	}
