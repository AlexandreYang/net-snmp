<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>MFD : ifTable data GET</title>
  </head>

  <body>
    <h1>MFD : ifTable data GET</h1>
    <p>
      Once the correct table context has been found, the individual node
      get routines will be called. These are generated in the file
      <var>ifTable_data_get.c</var>. 
    <p>
      Because we used the <var>data context</var> that is generated by
      default, we populated the data in the data structure during
      the data access phase and our MIB only has simple data types, 
      the code which was generated for the get routines does not need
      much modification.
    </p>
    <!-- ========================================================= -->
    <h2>Implementing the get routines</h2>
    <p>
      There is, however, a case where the data format specified by the
      MIB does not match the data format we got from our datastore. The
      <var>ifType</var> enumerations need to be mapped from the
      Linux specific ARPHDR values. Here again, we haven't tried to
      provide a complete implementation, but enought to give you the
      an overview.
    </p>
    <h3>ifType mapping</h3>
    <p>
      The PhysAddr ioctl call provides us with an ARPHRD type for
      an interface. This type must be mapped to one of the valid
      IANAifType enumerated values. The file <var>ifTable_enums.h</var>
      contains macro definitions for all the allow values. It also
      contains a list of the same macros prefixed with 'INTERNAL_'. For
      the case where there is a one to one mapping between a MIB type
      and the implementation's type, this provides a way to map
      without having to update the code.
    </p><p>
      Unfortunately, the ifType isn't one of those cases. Only a
      small subset of the possible values are available in our
      implementation, and often there are several ARPHDR types that
      map to a single IANAifType. The first step is to whittle down
      the internal list to the ones with a direct mapping that we are
      going to support.
    </p>
    <table><tr><td></td><td bgcolor=CCCCCC><pre>
    /*
     * TODO:
     * value mapping (see notes at top of file)
     */<font color=blue>
#define INTERNAL_IFTYPE_ETHERNETCSMACD  ARPHRD_ETHER
#define INTERNAL_IFTYPE_FDDI  ARPHRD_FDDI
#define INTERNAL_IFTYPE_PPP  ARPHRD_PPP
#define INTERNAL_IFTYPE_SOFTWARELOOPBACK  ARPHRD_LOOPBACK
#define INTERNAL_IFTYPE_SLIP  ARPHRD_SLIP
#define INTERNAL_IFTYPE_ARCNET  ARPHRD_ARCNET
#ifdef ARPHRD_ATM
#define INTERNAL_IFTYPE_ATM  ARPHRD_ATM
#endif
#define INTERNAL_IFTYPE_LOCALTALK  ARPHRD_LOCALTLK
#ifdef ARPHRD_HIPPI
#define INTERNAL_IFTYPE_HIPPI  ARPHRD_HIPPI
#endif
#define INTERNAL_IFTYPE_TUNNEL  ARPHRD_TUNNEL</font>
            </pre></td></tr></table>
    <p>
      Then we update the implementation to remove all the extras,
      and use a default of 'other' for any unknown types.
    </p>
    <table><tr><td></td><td bgcolor=CCCCCC><pre>
int
ifType_map(u_long * mib_ifType_ptr, u_long raw_ifType)
{
    netsnmp_assert(NULL != mib_ifType_ptr);

    DEBUGMSGTL(("verbose:ifType_map","called"));

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifType) {

    case INTERNAL_IFTYPE_ETHERNETCSMACD:
        *mib_ifType_ptr = IANAifType_ETHERNETCSMACD;
        break;

    case INTERNAL_IFTYPE_FDDI:
        *mib_ifType_ptr = IANAifType_FDDI;
        break;

    case INTERNAL_IFTYPE_PPP:
        *mib_ifType_ptr = IANAifType_PPP;
        break;

    case INTERNAL_IFTYPE_SOFTWARELOOPBACK:
        *mib_ifType_ptr = IANAifType_SOFTWARELOOPBACK;
        break;
<font color=blue>
        case ARPHRD_CSLIP:
        case ARPHRD_SLIP6:
        case ARPHRD_CSLIP6:</font>
    case INTERNAL_IFTYPE_SLIP:
        *mib_ifType_ptr = IANAifType_SLIP;
        break;

    case INTERNAL_IFTYPE_ARCNET:
        *mib_ifType_ptr = IANAifType_ARCNET;
        break;

    case INTERNAL_IFTYPE_ATM:
        *mib_ifType_ptr = IANAifType_ATM;
        break;

    case INTERNAL_IFTYPE_LOCALTALK:
        *mib_ifType_ptr = IANAifType_LOCALTALK;
        break;

    case INTERNAL_IFTYPE_HIPPI:
        *mib_ifType_ptr = IANAifType_HIPPI;
        break;
<font color=blue>
#ifdef ARPHRD_IPGRE
        case ARPHRD_IPGRE:
#endif
        case ARPHRD_TUNNEL6:
        case ARPHRD_SIT:</font>
    case INTERNAL_IFTYPE_TUNNEL:
        *mib_ifType_ptr = IANAifType_TUNNEL;
        break;
<font color=blue>
    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ifType, assuming other\n",
                 raw_ifType);
        *mib_ifType_ptr = IANAifType_OTHER;
        break;</font>
    }

    return MFD_SUCCESS;
}
            </pre></td></tr></table>
    <p></p>
    <h2>Unimplemented columns</h2>
    <p>
      As mentioned before, we are leaving some colums unimplemented.
      There are several reasons a column might be left unimplemnted.
      The data may not be available, or a particular column might not
      make sense for an implementation. You should consult the MIB
      specification to see if a particular value should be returned
      to represent this case. For example, the ifPhysAddress object
      states: <i>For interfaces which do not have such
        an address (e.g., a serial line), this object should contain
        an octet string of zero length.</i>
    <p><p>
      If there is no such special value, and the object in question
      is not required by the compliance/conformance specifications for
      the MIB, simply return <var>MFD_SKIP</var> from the object's
      get routine, and the agent will move on to the next object.
    </p>
    <h3>Skipping ifMtu</h3>
    <p>
      For this tutorial, we've chosen to skip a few objects. For
      simplicity, we'll just show one here:
    </p>
    <table><tr><td></td><td bgcolor=CCCCCC><pre>
int
ifMtu_get(ifTable_rowreq_ctx * rowreq_ctx, long *ifMtu_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifMtu_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifMtu_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */<font color=blue>
    //(*ifMtu_ptr) = rowreq_ctx->data.ifMtu;

    return MFD_SKIP;</font>
}
            </pre></td></tr></table>
    <!-- ========================================================= -->
    <p></p>
    <font size=+1>
      <a href="testing.html">Next: Testing</a> |
      <a href="data_access.html">Back: Data access</a> |
      <a href="../index.html">Up: IF-MIB Tutorials</a>
    </font>
      <!-- ========================================================= -->
      <!-- ========================================================= -->
    <hr>
    rstory at freesnmp dot com<br>
Version $Revision$
<!-- Created: Fri Oct 24 10:41:49 EDT 2003 -->
<!-- hhmts start -->
Last modified: Thu Apr 22 22:29:39 EDT 2004
<!-- hhmts end -->
<!--#include virtual="/sfbutton.html" -->
  </body>
</html>
