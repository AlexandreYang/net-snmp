/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.13 $ of : mfd-data-get.m2c,v $ 
 *
 * $Id$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ifTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ifTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ifTable is subid 2 of interfaces.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.2.2, length: 8
 */




/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifDescr
 * ifDescr is subid 2 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.2
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 255;
 *
 * It's syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the ifDescr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifDescr_ptr_ptr
 *        Pointer to storage for a char variable
 * @param ifDescr_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ifDescr.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ifDescr_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ifDescr_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ifDescr_get(ifTable_rowreq_ctx * rowreq_ctx, char **ifDescr_ptr_ptr,
            size_t * ifDescr_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ifDescr_ptr_ptr)
                   && (NULL != *ifDescr_ptr_ptr));
    netsnmp_assert(NULL != ifDescr_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifDescr_ptr_ptr ) and (* ifDescr_ptr_len_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    if ((NULL == (*ifDescr_ptr_ptr))
        || ((*ifDescr_ptr_len_ptr) < rowreq_ctx->data.ifDescr_len)) {
        (*ifDescr_ptr_ptr) =
            malloc(rowreq_ctx->data.ifDescr_len *
                   sizeof((*ifDescr_ptr_ptr)[0]));
        if (NULL == (*ifDescr_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*ifDescr_ptr_len_ptr) = rowreq_ctx->data.ifDescr_len;
    memcpy((*ifDescr_ptr_ptr), rowreq_ctx->data.ifDescr,
           (*ifDescr_ptr_len_ptr) * sizeof((*ifDescr_ptr_ptr)[0]));

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifType
 * ifType is subid 3 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.3
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 146/256. Values:  other(1), regular1822(2), hdh1822(3), ddnX25(4), rfc877x25(5), ethernetCsmacd(6), iso88023Csmacd(7), iso88024TokenBus(8), iso88025TokenRing(9), iso88026Man(10), starLan(11), proteon10Mbit(12), proteon80Mbit(13), hyperchannel(14), fddi(15), lapb(16), sdlc(17), ds1(18), e1(19), basicISDN(20), primaryISDN(21), propPointToPointSerial(22), ppp(23), softwareLoopback(24), eon(25), ethernet3Mbit(26), nsip(27), slip(28), ultra(29), ds3(30), sip(31), frameRelay(32), rs232(33), para(34), arcnet(35), arcnetPlus(36), atm(37), miox25(38), sonet(39), x25ple(40), iso88022llc(41), localTalk(42), smdsDxi(43), frameRelayService(44), v35(45), hssi(46), hippi(47), modem(48), aal5(49), sonetPath(50), sonetVT(51), smdsIcip(52), propVirtual(53), propMultiplexor(54), ieee80212(55), fibreChannel(56), hippiInterface(57), frameRelayInterconnect(58), aflane8023(59), aflane8025(60), cctEmul(61), fastEther(62), isdn(63), v11(64), v36(65), g703at64k(66), g703at2mb(67), qllc(68), fastEtherFX(69), channel(70), ieee80211(71), ibm370parChan(72), escon(73), dlsw(74), isdns(75), isdnu(76), lapd(77), ipSwitch(78), rsrb(79), atmLogical(80), ds0(81), ds0Bundle(82), bsc(83), async(84), cnr(85), iso88025Dtr(86), eplrs(87), arap(88), propCnls(89), hostPad(90), termPad(91), frameRelayMPI(92), x213(93), adsl(94), radsl(95), sdsl(96), vdsl(97), iso88025CRFPInt(98), myrinet(99), voiceEM(100), voiceFXO(101), voiceFXS(102), voiceEncap(103), voiceOverIp(104), atmDxi(105), atmFuni(106), atmIma(107), pppMultilinkBundle(108), ipOverCdlc(109), ipOverClaw(110), stackToStack(111), virtualIpAddress(112), mpc(113), ipOverAtm(114), iso88025Fiber(115), tdlc(116), gigabitEthernet(117), hdlc(118), lapf(119), v37(120), x25mlp(121), x25huntGroup(122), trasnpHdlc(123), interleave(124), fast(125), ip(126), docsCableMaclayer(127), docsCableDownstream(128), docsCableUpstream(129), a12MppSwitch(130), tunnel(131), coffee(132), ces(133), atmSubInterface(134), l2vlan(135), l3ipvlan(136), l3ipxvlan(137), digitalPowerline(138), mediaMailOverIp(139), dtm(140), dcn(141), ipForward(142), msdsl(143), ieee1394(144), if-gsn(145), dvbRccMacLayer(146), dvbRccDownstream(147), dvbRccUpstream(148), atmVirtual(149), mplsTunnel(150), srp(151), voiceOverAtm(152), voiceOverFrameRelay(153), idsl(154), compositeLink(155), ss7SigLink(156), propWirelessP2P(157), frForward(158), rfc1483(159), usb(160), ieee8023adLag(161), bgppolicyaccounting(162), frf16MfrBundle(163), h323Gatekeeper(164), h323Proxy(165), mpls(166), mfSigLink(167), hdsl2(168), shdsl(169), ds1FDL(170), pos(171), dvbAsiIn(172), dvbAsiOut(173), plc(174), nfas(175), tr008(176), gr303RDT(177), gr303IDT(178), isup(179), propDocsWirelessMaclayer(180), propDocsWirelessDownstream(181), propDocsWirelessUpstream(182), hiperlan2(183), propBWAp2Mp(184), sonetOverheadChannel(185), digitalWrapperOverheadChannel(186), aal2(187), radioMAC(188), atmRadio(189), imt(190), mvl(191), reachDSL(192), frDlciEndPt(193), atmVciEndPt(194), opticalChannel(195), opticalTransport(196), propAtm(197), voiceOverCable(198), infiniband(199), teLink(200), q2931(201), virtualTg(202), sipTg(203), sipSig(204), docsCableUpstreamChannel(205), econet(206), pon155(207), pon622(208), bridge(209), linegroup(210), voiceEMFGD(211), voiceFGDEANA(212), voiceDID(213), mpegTransport(214), sixToFour(215), gtp(216), pdnEtherLoop1(217), pdnEtherLoop2(218), opticalChannelGroup(219), homepna(220), gfp(221)
 *
 * It's syntax is IANAifType (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifType.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifType_map(u_long * mib_ifType_ptr, u_long raw_ifType)
{
    netsnmp_assert(NULL != mib_ifType_ptr);

    DEBUGMSGTL(("verbose:ifType_map", "called\n"));

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifType) {

    case INTERNAL_IFTYPE_ETHERNETCSMACD:
        *mib_ifType_ptr = IANAifType_ETHERNETCSMACD;
        break;

    case INTERNAL_IFTYPE_FDDI:
        *mib_ifType_ptr = IANAifType_FDDI;
        break;

    case INTERNAL_IFTYPE_PPP:
        *mib_ifType_ptr = IANAifType_PPP;
        break;

    case INTERNAL_IFTYPE_SOFTWARELOOPBACK:
        *mib_ifType_ptr = IANAifType_SOFTWARELOOPBACK;
        break;

        case ARPHRD_CSLIP:
        case ARPHRD_SLIP6:
        case ARPHRD_CSLIP6:
    case INTERNAL_IFTYPE_SLIP:
        *mib_ifType_ptr = IANAifType_SLIP;
        break;

    case INTERNAL_IFTYPE_ARCNET:
        *mib_ifType_ptr = IANAifType_ARCNET;
        break;

    case INTERNAL_IFTYPE_ATM:
        *mib_ifType_ptr = IANAifType_ATM;
        break;

    case INTERNAL_IFTYPE_LOCALTALK:
        *mib_ifType_ptr = IANAifType_LOCALTALK;
        break;

    case INTERNAL_IFTYPE_HIPPI:
        *mib_ifType_ptr = IANAifType_HIPPI;
        break;

#ifdef ARPHRD_IPGRE
        case ARPHRD_IPGRE:
#endif
        case ARPHRD_TUNNEL6:
        case ARPHRD_SIT:
    case INTERNAL_IFTYPE_TUNNEL:
        *mib_ifType_ptr = IANAifType_TUNNEL;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ifType, assuming other\n",
                 raw_ifType);
        *mib_ifType_ptr = IANAifType_OTHER;
        break;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ifType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifType_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifType_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifType_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifType_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifType_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifType_ptr) = rowreq_ctx->data.ifType;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifMtu
 * ifMtu is subid 4 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ifMtu data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifMtu_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifMtu_get(ifTable_rowreq_ctx * rowreq_ctx, long *ifMtu_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifMtu_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifMtu_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifMtu_ptr) = rowreq_ctx->data.ifMtu;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifSpeed
 * ifSpeed is subid 5 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifSpeed data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifSpeed_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifSpeed_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifSpeed_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifSpeed_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifSpeed_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifSpeed_ptr) = rowreq_ctx->data.ifSpeed;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifPhysAddress
 * ifPhysAddress is subid 6 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   1
 *   settable   0
 *   hint: 1x:
 *
 *
 * It's syntax is PhysAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the ifPhysAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifPhysAddress_ptr_ptr
 *        Pointer to storage for a char variable
 * @param ifPhysAddress_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ifPhysAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ifPhysAddress_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ifPhysAddress_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ifPhysAddress_get(ifTable_rowreq_ctx * rowreq_ctx,
                  char **ifPhysAddress_ptr_ptr,
                  size_t * ifPhysAddress_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ifPhysAddress_ptr_ptr)
                   && (NULL != *ifPhysAddress_ptr_ptr));
    netsnmp_assert(NULL != ifPhysAddress_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifPhysAddress_ptr_ptr ) and (* ifPhysAddress_ptr_len_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    if ((NULL == (*ifPhysAddress_ptr_ptr))
        || ((*ifPhysAddress_ptr_len_ptr) <
            rowreq_ctx->data.ifPhysAddress_len)) {
        (*ifPhysAddress_ptr_ptr) =
            malloc(rowreq_ctx->data.ifPhysAddress_len *
                   sizeof((*ifPhysAddress_ptr_ptr)[0]));
        if (NULL == (*ifPhysAddress_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*ifPhysAddress_ptr_len_ptr) = rowreq_ctx->data.ifPhysAddress_len;
    memcpy((*ifPhysAddress_ptr_ptr), rowreq_ctx->data.ifPhysAddress,
           (*ifPhysAddress_ptr_len_ptr) *
           sizeof((*ifPhysAddress_ptr_ptr)[0]));

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifAdminStatus
 * ifAdminStatus is subid 7 of ifEntry.
 * It's status is Current, and it's access level is ReadWrite.
 * OID: .1.3.6.1.2.1.2.2.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  up(1), down(2), testing(3)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifAdminStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifAdminStatus_map(u_long * mib_ifAdminStatus_ptr, u_long raw_ifAdminStatus)
{
    netsnmp_assert(NULL != mib_ifAdminStatus_ptr);

    DEBUGMSGTL(("verbose:ifAdminStatus_map", "called\n"));

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifAdminStatus) {
    case INTERNAL_IFADMINSTATUS_UP:
        *mib_ifAdminStatus_ptr = ifAdminStatus_UP;
        break;

    case INTERNAL_IFADMINSTATUS_DOWN:
        *mib_ifAdminStatus_ptr = ifAdminStatus_DOWN;
        break;

    case INTERNAL_IFADMINSTATUS_TESTING:
        *mib_ifAdminStatus_ptr = ifAdminStatus_TESTING;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ifAdminStatus\n",
                 raw_ifAdminStatus);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ifAdminStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifAdminStatus_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifAdminStatus_get(ifTable_rowreq_ctx * rowreq_ctx,
                  u_long * ifAdminStatus_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifAdminStatus_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifAdminStatus_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifAdminStatus_ptr) = rowreq_ctx->data.ifAdminStatus;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOperStatus
 * ifOperStatus is subid 8 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.8
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 5/8. Values:  up(1), down(2), testing(3), unknown(4), dormant(5), notPresent(6), lowerLayerDown(7)
 *
 * It's syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * map a value from it's original native format the the MIB format.
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_ERROR           : Any other error
 *
 * @note parameters follow the memset convention (dest, src).
 *
 * @note generation and use of this function can be turned off by re-running
 * mib2c after adding the following line to the file
 * default-node-ifOperStatus.m2d :
 *   @eval $m2c_node_skip_mapping = 1@
 *
 * @remark
 *  If the values for your data type don't exactly match the
 *  possible values defined by the mib, you should map them here.
 *  Otherwise, just do a direct copy.
 */
int
ifOperStatus_map(u_long * mib_ifOperStatus_ptr, u_long raw_ifOperStatus)
{
    netsnmp_assert(NULL != mib_ifOperStatus_ptr);

    DEBUGMSGTL(("verbose:ifOperStatus_map", "called\n"));

    /*
     * TODO:
     * value mapping
     */
    /** TODO: update INTERNAL_* macros defined in the header */
    switch (raw_ifOperStatus) {
    case INTERNAL_IFOPERSTATUS_UP:
        *mib_ifOperStatus_ptr = ifOperStatus_UP;
        break;

    case INTERNAL_IFOPERSTATUS_DOWN:
        *mib_ifOperStatus_ptr = ifOperStatus_DOWN;
        break;

    case INTERNAL_IFOPERSTATUS_TESTING:
        *mib_ifOperStatus_ptr = ifOperStatus_TESTING;
        break;

    case INTERNAL_IFOPERSTATUS_UNKNOWN:
        *mib_ifOperStatus_ptr = ifOperStatus_UNKNOWN;
        break;

    case INTERNAL_IFOPERSTATUS_DORMANT:
        *mib_ifOperStatus_ptr = ifOperStatus_DORMANT;
        break;

    case INTERNAL_IFOPERSTATUS_NOTPRESENT:
        *mib_ifOperStatus_ptr = ifOperStatus_NOTPRESENT;
        break;

    case INTERNAL_IFOPERSTATUS_LOWERLAYERDOWN:
        *mib_ifOperStatus_ptr = ifOperStatus_LOWERLAYERDOWN;
        break;

    default:
        snmp_log(LOG_ERR, "couldn't map value %d for ifOperStatus\n",
                 raw_ifOperStatus);
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}

/**
 * Extract the current value of the ifOperStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOperStatus_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOperStatus_get(ifTable_rowreq_ctx * rowreq_ctx,
                 u_long * ifOperStatus_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOperStatus_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOperStatus_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifOperStatus_ptr) = rowreq_ctx->data.ifOperStatus;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifLastChange
 * ifLastChange is subid 9 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is TICKS (based on perltype TICKS)
 * The net-snmp type is ASN_TIMETICKS. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifLastChange data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifLastChange_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifLastChange_get(ifTable_rowreq_ctx * rowreq_ctx,
                 u_long * ifLastChange_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifLastChange_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifLastChange_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifLastChange_ptr) = rowreq_ctx->data.ifLastChange;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifInOctets
 * ifInOctets is subid 10 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.10
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInOctets_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInOctets_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifInOctets_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInOctets_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInOctets_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifInOctets_ptr) = rowreq_ctx->data.ifInOctets;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifInUcastPkts
 * ifInUcastPkts is subid 11 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.11
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInUcastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInUcastPkts_get(ifTable_rowreq_ctx * rowreq_ctx,
                  u_long * ifInUcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInUcastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInUcastPkts_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifInUcastPkts_ptr) = rowreq_ctx->data.ifInUcastPkts;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifInNUcastPkts
 * ifInNUcastPkts is subid 12 of ifEntry.
 * It's status is Deprecated, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.12
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInNUcastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInNUcastPkts_get(ifTable_rowreq_ctx * rowreq_ctx,
                   u_long * ifInNUcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInNUcastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInNUcastPkts_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifInNUcastPkts_ptr) = rowreq_ctx->data.ifInNUcastPkts;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifInDiscards
 * ifInDiscards is subid 13 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInDiscards data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInDiscards_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInDiscards_get(ifTable_rowreq_ctx * rowreq_ctx,
                 u_long * ifInDiscards_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInDiscards_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInDiscards_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifInDiscards_ptr) = rowreq_ctx->data.ifInDiscards;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifInErrors
 * ifInErrors is subid 14 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInErrors_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInErrors_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifInErrors_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInErrors_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInErrors_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifInErrors_ptr) = rowreq_ctx->data.ifInErrors;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifInUnknownProtos
 * ifInUnknownProtos is subid 15 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifInUnknownProtos data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifInUnknownProtos_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifInUnknownProtos_get(ifTable_rowreq_ctx * rowreq_ctx,
                      u_long * ifInUnknownProtos_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifInUnknownProtos_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifInUnknownProtos_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifInUnknownProtos_ptr) = rowreq_ctx->data.ifInUnknownProtos;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOutOctets
 * ifOutOctets is subid 16 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutOctets data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutOctets_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutOctets_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifOutOctets_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutOctets_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutOctets_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifOutOctets_ptr) = rowreq_ctx->data.ifOutOctets;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOutUcastPkts
 * ifOutUcastPkts is subid 17 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.17
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutUcastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutUcastPkts_get(ifTable_rowreq_ctx * rowreq_ctx,
                   u_long * ifOutUcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutUcastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutUcastPkts_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifOutUcastPkts_ptr) = rowreq_ctx->data.ifOutUcastPkts;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOutNUcastPkts
 * ifOutNUcastPkts is subid 18 of ifEntry.
 * It's status is Deprecated, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.18
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutNUcastPkts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutNUcastPkts_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutNUcastPkts_get(ifTable_rowreq_ctx * rowreq_ctx,
                    u_long * ifOutNUcastPkts_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutNUcastPkts_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutNUcastPkts_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifOutNUcastPkts_ptr) = rowreq_ctx->data.ifOutNUcastPkts;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOutDiscards
 * ifOutDiscards is subid 19 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.19
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutDiscards data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutDiscards_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutDiscards_get(ifTable_rowreq_ctx * rowreq_ctx,
                  u_long * ifOutDiscards_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutDiscards_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutDiscards_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifOutDiscards_ptr) = rowreq_ctx->data.ifOutDiscards;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOutErrors
 * ifOutErrors is subid 20 of ifEntry.
 * It's status is Current, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.20
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutErrors data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutErrors_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutErrors_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifOutErrors_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutErrors_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutErrors_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    (*ifOutErrors_ptr) = rowreq_ctx->data.ifOutErrors;

    return MFD_SUCCESS;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifOutQLen
 * ifOutQLen is subid 21 of ifEntry.
 * It's status is Deprecated, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.21
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is GAUGE (based on perltype GAUGE)
 * The net-snmp type is ASN_GAUGE. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ifOutQLen data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifOutQLen_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ifOutQLen_get(ifTable_rowreq_ctx * rowreq_ctx, u_long * ifOutQLen_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != ifOutQLen_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:
     * set (* ifOutQLen_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    //(*ifOutQLen_ptr) = rowreq_ctx->data.ifOutQLen;

    return MFD_SKIP;
}

/*---------------------------------------------------------------------
 * IF-MIB::ifEntry.ifSpecific
 * ifSpecific is subid 22 of ifEntry.
 * It's status is Deprecated, and it's access level is ReadOnly.
 * OID: .1.3.6.1.2.1.2.2.1.22
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * It's syntax is OBJECTID (based on perltype OBJECTID)
 * The net-snmp type is ASN_OBJECT_ID. The C type decl is oid (oid)
 * This data type requires a length.  (Max 255)
 */
/**
 * Extract the current value of the ifSpecific data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ifSpecific_ptr_ptr
 *        Pointer to storage for a oid variable
 * @param ifSpecific_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ifSpecific.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ifSpecific_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ifSpecific_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ifSpecific_get(ifTable_rowreq_ctx * rowreq_ctx, oid ** ifSpecific_ptr_ptr,
               size_t * ifSpecific_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != ifSpecific_ptr_ptr)
                   && (NULL != *ifSpecific_ptr_ptr));
    netsnmp_assert(NULL != ifSpecific_ptr_len_ptr);

    netsnmp_assert(NULL != rowreq_ctx);

    return MFD_SKIP;
    /*
     * TODO:
     * set (* ifSpecific_ptr_ptr ) and (* ifSpecific_ptr_len_ptr ) from rowreq_ctx->data.
     */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    if ((NULL == (*ifSpecific_ptr_ptr))
        || ((*ifSpecific_ptr_len_ptr) < rowreq_ctx->data.ifSpecific_len)) {
        (*ifSpecific_ptr_ptr) =
            malloc(rowreq_ctx->data.ifSpecific_len *
                   sizeof((*ifSpecific_ptr_ptr)[0]));
        if (NULL == (*ifSpecific_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*ifSpecific_ptr_len_ptr) = rowreq_ctx->data.ifSpecific_len;
    memcpy((*ifSpecific_ptr_ptr), rowreq_ctx->data.ifSpecific,
           (*ifSpecific_ptr_len_ptr) * sizeof((*ifSpecific_ptr_ptr)[0]));

    return MFD_SUCCESS;
}



/** @} */
