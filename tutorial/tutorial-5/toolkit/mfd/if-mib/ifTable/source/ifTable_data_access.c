/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 1.8 $ of : mfd-data-access.m2c,v $ 
 *
 * $Id$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "ifTable.h"
#include "ifTable_data_access.h"

#include <unistd.h>
#include <net/if.h>
#include <sys/ioctl.h>

/** @defgroup data_access data_access: Routines to access data
 *
 * These routines are used to locate the data used to satisfy
 * requests.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ifTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * ifTable is subid 2 of interfaces.
 * It's status is Current.
 * OID: .1.3.6.1.2.1.2.2, length: 8
 */

/**
 * initialization for ifTable data access
 *
 * This function is called during startup to allow you to
 * allocate any resources you need for the data table.
 *
 * @param ifTable_reg
 *        Pointer to ifTable_registration
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : unrecoverable error.
 */
static const char     *scan_line_2_2 =
    "%lu %lu %lu %lu %*lu %*lu %*lu %*lu %lu %lu %lu %lu %*lu %lu";
static const char     *scan_line_2_0 =
    "%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";
static const char     *scan_line_to_use = NULL;
static char     scan_expected;
int
ifTable_init_data(ifTable_registration_ptr ifTable_reg)
{
    FILE *devin;
    char  line[MAX_LINE_SIZE];

    DEBUGMSGTL(("verbose:ifTable_init_data", "called\n"));

    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    if (!(devin = fopen("/proc/net/dev", "r"))) {
        snmp_log(LOG_ERR, "snmpd: cannot open /proc/net/dev\n");
        return MFD_ERROR;
    }
    /*
     * Read the first two lines of the file, containing the header
     * This indicates which version of the kernel we're working with,
     * and hence which statistics are actually available.
     */
    fgets(line, sizeof(line), devin); /* ignore first line */
    fgets(line, sizeof(line), devin);
    if (strstr(line, "compressed")) {
        scan_line_to_use = scan_line_2_2;
        scan_expected = 9;
        DEBUGMSGTL(("ifTable", "using linux 2.2 kernel /proc/net/dev\n"));
     } else {
         scan_line_to_use = scan_line_2_0;
         scan_expected = 5;
         DEBUGMSGTL(("ifTable",
                     "using linux 2.0 kernel /proc/net/dev\n"));
    }
    fclose(devin);
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return MFD_SUCCESS;
}

/**
 * unsorted-external overview
 *
 * The unsorted external data access code works by calling a few simple
 * functions to get the index value for each row. Once the agent determines
 * which row is needed to process an incoming request, another function
 * is called to retrieve the data for that row.
 *
 * A simplified version of the pseudo-code looks like this:
 *
 *    ifTable_loop_get_first(loop,data)
 *    while( no_error ) {
 *       if( best_match(data, key)
 *          ifTable_loop_save_position(loop,pos);
 *       ifTable_loop_get_next(loop,data)
 *    }
 *    ifTable_loop_get_data(pos,data)
 *    ifTable_loop_cleanup_context(loop)
 */

/***********************************************************************
 *
 * ITERATION
 *
 ***********************************************************************/

/**
 * get the first data index
 *
 * Summary
 * -------
 *  This function is called to initialize the iterator loop context for a
 *  new iteration loop and return the index(es) for the first
 *  ifTable_data in the data set.
 *
 *  Note that during the loop, the only important thing is the indexes.
 *  If access to your data is cheap/fast (e.g. you have a pointer to a
 *  structure in memory), it would make sense to update the data here.
 *  If, however, the accessing the data invovles more work (e.g. parsing
 *  some other existing data, or peforming calculations to derive the data),
 *  then you should limit yourself to setting the indexes. Extracting the
 *  can be put off until the desired row is found. See the notes on
 *  ifTable_loop_get_data().
 *
 *  Note that this function does not correspond to a SNMP GET pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 *  This function should update the table index (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
 *  values for the raw data (rowreq_ctx_ref->rowreq_ctx->data).
 *
 * More Details
 * ------------
 *  If there is currently no data available, return MFD_END_OF_DATA.
 *  Otherwise, you should set rowreq_ctx_ref->rowreq_ctx and it's indexes.
 *
 *  rowreq_ctx_ref->rowreq_ctx will be NULL. You should allocate a new context
 *  for this loop. [Alternatively, you could allocate one in
 *  ifTable_loop_init_context, save it in your
 *  ifTable_ref_loop_ctx, and use it here.]
 *
 *  Once you have your context pointer, you should set the index (or indexes)
 *  in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the appropriate value for this row. [If you
 *  use your loop_ctx_ref cleverly, you might be able to put this work in
 *  ifTable_loop_get_next, and simply call that function.]
 *
 * @param ifTable_reg Pointer to a ifTable_registration_ptr
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no data available
 * @retval MFD_ERROR       : error.
 */
int
ifTable_loop_get_first(ifTable_registration_ptr ifTable_reg,
                       ifTable_ref_loop_ctx * loop_ctx_ref,
                       ifTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
    DEBUGMSGTL(("verbose:ifTable_loop_get_first", "called\n"));

    netsnmp_assert(rowreq_ctx_ref);
    netsnmp_assert(loop_ctx_ref);

    /*
     * allocate memory for new structure
     */
    loop_ctx_ref->loop_ctx = SNMP_MALLOC_TYPEDEF(ifTable_loop_context);
    if (NULL == loop_ctx_ref->loop_ctx)
        return MFD_ERROR;

    /*
     * allocate a temporary context to use during iteration
     */
    loop_ctx_ref->loop_ctx->rowreq_ctx = ifTable_allocate_rowreq_ctx();
    if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
        SNMP_FREE(loop_ctx_ref->loop_ctx);
        return MFD_RESOURCE_UNAVAILABLE;
    }

    /*
     * TODO:
     * set up loop context
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * open our data file.
     */
    loop_ctx_ref->loop_ctx->filep = fopen("/proc/net/dev", "r");
    if (NULL == loop_ctx_ref->loop_ctx->filep) {
        return MFD_RESOURCE_UNAVAILABLE;
    }
    /*
     * ignore header lines
     */
    fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
          loop_ctx_ref->loop_ctx->filep);
    fgets(loop_ctx_ref->loop_ctx->line, sizeof(loop_ctx_ref->loop_ctx->line),
          loop_ctx_ref->loop_ctx->filep);
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * in this example, after opening the file, get next does the same thing
     * as get first, we let's just call get next...
     */
    return ifTable_loop_get_next(ifTable_reg, loop_ctx_ref,
                                 rowreq_ctx_ref);
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return MFD_SUCCESS;
}

/**
 * get the next data index
 *
 * Summary
 * -------
 *  This function returns the next data item in the data set. The same
 *  caveat applies here as did above. The indexes are the important parts
 *  during loop processing.
 *
 *  Note that this function does not correspond to a SNMP GET-NEXT pdu, and
 *  you should return data items in whatever order they are already in.
 *  (In fact, if your data is already ordered in the same order as the
 *  SNMP indexes, you shouldn't be using the unsorted-access code).
 *
 * More Details
 * ------------
 * rowreq_ctx_ref->rowreq_ctx will have been set in ifTable_loop_get_first.
 *
 * If there is currently no data available, return MFD_END_OF_DATA.
 * Otherwise, you should set the indexes in rowreq_ctx_ref->rowreq_ctx->tbl_idx.
 *
 * You should set the index (or indexes) in rowreq_ctx_ref->rowreq_ctx->tbl_idx to the
 * appropriate value for this row.
 *
 * @param ifTable_reg Pointer to a ifTable_registration_ptr
 * @param loop_ctx_ref  Pointer to your loop reference.
 * @param rowreq_ctx_ref  Pointer to a context reference.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_END_OF_DATA : no more data available
 * @retval MFD_ERROR       : error.
 */
int
ifTable_loop_get_next(ifTable_registration_ptr ifTable_reg,
                      ifTable_ref_loop_ctx * loop_ctx_ref,
                      ifTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
    u_char         *ifstart;
    u_int           index = 0;

    DEBUGMSGTL(("verbose:ifTable_loop_get_next", "called\n"));

    netsnmp_assert(loop_ctx_ref && loop_ctx_ref->loop_ctx);
    netsnmp_assert(rowreq_ctx_ref);

    /*
     * we just need the index for now. Reuse the one in the loop context's
     * temporary row request context. (rowreq_ctx_ref->rowreq_ctx->tbl_idx)
     */
    rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;

    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * The rest of the file provides the statistics for an interface.
     * Read in each line in turn, isolate the interface name
     *   and retrieve (or create) the corresponding data structure.
     */
    while (NULL != (ifstart = fgets(loop_ctx_ref->loop_ctx->line,
                                    sizeof(loop_ctx_ref->loop_ctx->line),
                                    loop_ctx_ref->loop_ctx->filep))) {
        char           *stats;

        /*
         * remove any newline, and skip leading spaces
         */
        if (loop_ctx_ref->loop_ctx->line[strlen(loop_ctx_ref->loop_ctx->line) - 1] == '\n')
            loop_ctx_ref->loop_ctx->line[strlen(loop_ctx_ref->loop_ctx->line) - 1] = '\0';

        while (*ifstart && *ifstart == ' ')
            ifstart++;

        if ((!*ifstart) || ((stats = strrchr(ifstart, ':')) == NULL)) {
            snmp_log(LOG_ERR,
                     "interface data format error 1, line ==|%s|\n",
                     loop_ctx_ref->loop_ctx->line);
            continue;
        }

        DEBUGMSGTL(("ifTable", "found '%s'\n", ifstart));

        /*
         * If we've met this interface before, use the same index.
         * Otherwise find an unused index value and use that.
         */
        *stats++ = 0; /* null terminate name */
        index = se_find_value_in_slist("interfaces",
                                       loop_ctx_ref->loop_ctx->line);
        if (index == SE_DNE) {
            index = se_find_free_value_in_slist("interfaces");
            if (index == SE_DNE)
                index = 1;       /* Completely new list! */
            se_add_pair_to_slist("interfaces",
                                 strdup(loop_ctx_ref->loop_ctx->line), index);
            DEBUGMSGTL(("ifTable:ifIndex", "new ifIndex %d for %s\n",
                        index, loop_ctx_ref->loop_ctx->line));
        }
        break;
    }

    /*
     * check for end of data
     */
    if ((NULL == ifstart) || (0 == index))
        return MFD_END_OF_DATA;

    /*
     * TODO:
     * set local vars for index from loop_ctx_ref->loop_ctx
     */
    rowreq_ctx_ref->rowreq_ctx->tbl_idx.ifIndex = index;

    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return MFD_SUCCESS;
}

/**
 * duplicate the current loop reference
 *
 * Summary
 *  -------
 *  During loop iteration, the iterator keeps track of the row that
 *  is the current best match. This function is called when the
 *  current row is a better match than any previous row.
 *
 *  You should save any information you need to be able to locate this row
 *  again from the current loop context to a new loop context.
 *
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  ifTable_loop_get_data().
 *
 *  Since your data is transient, you need to make a copy of it before
 *  the iterator moves on to the next row.
 *
 * More Details
 * ------------
 *  One idea would be to copy it space allocated in the loop reference
 *  structure. Another would be to simply have a pointer in the loop
 *  reference structure, and allocate memory here.
 *
 * @param ifTable_reg Pointer to a ifTable_registration_ptr
 * @param loop_ctx_ref  Reference to current loop context.
 * @param save_loop_ctx_ref Reference to a loop context for saving the current
 *                  position. If reuse is not set or
 *                  save_loop_ctx_ref->loop_ctx is NULL, allocate
 *                  a new one. If reuse is set, you may reuse  the existing
 *                  loop_ctx.
 * @param reuse     Indicates if an existing save_loop_ctx_ref->loop_ctx
 *                  may be reused.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
ifTable_loop_save_position(ifTable_registration_ptr ifTable_reg,
                           ifTable_ref_loop_ctx * loop_ctx_ref,
                           ifTable_ref_loop_ctx * save_loop_ctx_ref,
                           int reuse)
{
    DEBUGMSGTL(("verbose:ifTable_loop_save_position", "called\n"));

    netsnmp_assert(loop_ctx_ref && save_loop_ctx_ref);

    /*
     * TODO:
     * 1) allocate new loop context, unless you can reuse a previous pointer.
     * 2) save information for the position of loop_ctx_ref in save_loop_ctx_ref.
     */
    if ((0 == reuse) || (NULL == save_loop_ctx_ref->loop_ctx))
        save_loop_ctx_ref->loop_ctx =
            SNMP_MALLOC_TYPEDEF(ifTable_loop_context);
    if (NULL == save_loop_ctx_ref->loop_ctx) {
        snmp_log(LOG_ERR, "could not allocate memory\n");
        return MFD_ERROR;
    }

    /*
     * if you can reuse a previously saved contex, just swap
     * it out with the loop iterator
     */
    if (reuse && save_loop_ctx_ref->loop_ctx->rowreq_ctx) {
        ifTable_rowreq_ctx *tmp_rowreq_ctx =
            save_loop_ctx_ref->loop_ctx->rowreq_ctx;
        save_loop_ctx_ref->loop_ctx->rowreq_ctx =
            loop_ctx_ref->loop_ctx->rowreq_ctx;
        loop_ctx_ref->loop_ctx->rowreq_ctx = tmp_rowreq_ctx;
    } else {
        /*
         * take the current pointer
         */
        save_loop_ctx_ref->loop_ctx->rowreq_ctx =
            loop_ctx_ref->loop_ctx->rowreq_ctx;

        /*
         * allocate a new context to replace the one you just took.
         */
        loop_ctx_ref->loop_ctx->rowreq_ctx = ifTable_allocate_rowreq_ctx();
        if (NULL == loop_ctx_ref->loop_ctx->rowreq_ctx) {
            SNMP_FREE(loop_ctx_ref->loop_ctx);
            return MFD_ERROR;
        }
    }

    /*
     * TRANSIENT data: copy all the data.
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * we just need line for parsing later
     */
    memcpy(save_loop_ctx_ref->loop_ctx->line, loop_ctx_ref->loop_ctx->line,
           sizeof(loop_ctx_ref->loop_ctx->line));
    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    return MFD_SUCCESS;
}

/**
 * set ifTable_data from a data context
 *
 * Summary
 * -------
 *  At the end of the loop, when the best match has been found, the saved
 *  loop context will be used to get the data for the row by calling
 *  ifTable_loop_get_data().
 *
 *  You should return a fully populated row request context in
 *  rowreq_ctx_ref->rowreq_ctx.
 *
 * More Details
 * ------------
 * @param ifTable_reg Pointer to a ifTable_registration_ptr
 * @param loop_ctx_ref pointer to your loop reference.
 * @param rowreq_ctx_ref pointer to a context reference.
 */
int
ifTable_loop_get_data(ifTable_registration_ptr ifTable_reg,
                      ifTable_ref_loop_ctx * loop_ctx_ref,
                      ifTable_ref_rowreq_ctx * rowreq_ctx_ref)
{
    struct ifreq    ifrq;
    int             scan_count, fd;
    char           *pos;
    unsigned long   rec_pkt, rec_oct, rec_err, rec_drop;
    unsigned long   snd_pkt, snd_oct, snd_err, snd_drop, coll;

    DEBUGMSGTL(("verbose:ifTable_loop_get_data", "called\n"));

    netsnmp_assert((NULL != loop_ctx_ref)
                   && (NULL != loop_ctx_ref->loop_ctx));
    netsnmp_assert(NULL != rowreq_ctx_ref);
    netsnmp_assert(NULL != rowreq_ctx_ref->rowreq_ctx);

    /*
     * take temporary row request context from loop context
     */
    rowreq_ctx_ref->rowreq_ctx = loop_ctx_ref->loop_ctx->rowreq_ctx;
    loop_ctx_ref->loop_ctx->rowreq_ctx = NULL;

    /*
     * copy data to the data context (rowreq_ctx_ref->rowreq_ctx->data.)
     * in loop_save_position, we saved line to do that
     */
    pos =
        &loop_ctx_ref->loop_ctx->line[strlen(loop_ctx_ref->loop_ctx->line)+1];
    rec_pkt = rec_oct = rec_err = rec_drop = 0;
    snd_pkt = snd_oct = snd_err = snd_drop = coll = 0;
    if (scan_line_to_use == scan_line_2_2) {
        scan_count = sscanf(pos, scan_line_to_use,
                            &rec_oct, &rec_pkt, &rec_err, &rec_drop,
                            &snd_oct, &snd_pkt, &snd_err, &snd_drop,
                            &coll);
    } else {
        scan_count = sscanf(pos, scan_line_to_use,
                                &rec_pkt, &rec_err,
                                &snd_pkt, &snd_err, &coll);
    }
    if(scan_count != scan_expected) {
        snmp_log(LOG_ERR,
                 "error scanning interface data (expected %d, got %d)\n",
                 scan_expected, scan_count);
        return MFD_ERROR;
    }
    if (scan_line_to_use != scan_line_2_2) {
        rec_oct = rec_pkt * 308;
        snd_oct = snd_pkt * 308;
    }

    /*
     * create socket for ioctls
     */
    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(fd < 0) {
        goto error;
    }

    /*
     * ifDescr(2)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H
     */
    /** no code to get description yet */
    rowreq_ctx_ref->rowreq_ctx->data.ifDescr[0] = 0;
    rowreq_ctx_ref->rowreq_ctx->data.ifDescr_len = 0;

    /*
     * ifPhysAddress(6)/PhysAddress/ASN_OCTET_STR/char(char)//L/A/w/e/r/d/H
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    if ((NULL == rowreq_ctx_ref->rowreq_ctx->data.ifPhysAddress)
        || (sizeof(rowreq_ctx_ref->rowreq_ctx->data.ifPhysAddress) < 6)) {
        goto error;
    }
    rowreq_ctx_ref->rowreq_ctx->data.ifPhysAddress_len = 6;
    pos = loop_ctx_ref->loop_ctx->line;
    while(*pos == ' ')
        ++pos;
    strncpy(ifrq.ifr_name, pos, sizeof(ifrq.ifr_name));
    ifrq.ifr_name[ sizeof(ifrq.ifr_name)-1 ] = 0;
    if (ioctl(fd, SIOCGIFHWADDR, &ifrq) < 0)
        memset(rowreq_ctx_ref->rowreq_ctx->data.ifPhysAddress, (0), 6);
    else {
        memcpy(rowreq_ctx_ref->rowreq_ctx->data.ifPhysAddress,
               ifrq.ifr_hwaddr.sa_data, 6);
    }
    /*
     * ifType(3)/IANAifType/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h
     */
    /*
     * TODO:
     * value mapping
     */
    if (MFD_SUCCESS !=
        ifType_map(&rowreq_ctx_ref->rowreq_ctx->data.ifType,
                   ifrq.ifr_hwaddr.sa_family)) {
        goto error;
    }

    /*
     * ifInOctets(10)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifInOctets = rec_oct;

    /*
     * ifInUcastPkts(11)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifInUcastPkts = rec_pkt;

    /*
     * ifInDiscards(13)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifInDiscards = snd_drop;

    /*
     * ifInErrors(14)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifInErrors = rec_err;

    /*
     * ifOutOctets(16)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifOutOctets = snd_oct;

    /*
     * ifOutUcastPkts(17)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifOutUcastPkts = snd_pkt;

    /*
     * ifOutDiscards(19)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifOutDiscards = snd_drop;

    /*
     * ifOutErrors(20)/COUNTER/ASN_COUNTER/u_long(u_long)//l/A/w/e/r/d/h
     */
    /** no mapping */
    /*
     * TODO:
     * update, replace or delete, if needed.
     */
    rowreq_ctx_ref->rowreq_ctx->data.ifOutErrors = snd_err;

    close(fd);

    return MFD_SUCCESS;

  error:
    if (fd>=0)
        close(fd);

    return MFD_ERROR;
}


/**
 * clean up a loop reference
 *
 * Summary
 * -------
 *  This function will be called once the loop iteration has completed
 *  to release any memory or resources allocated for the loop context.
 *
 * More Details
 * ------------
 * @param ifTable_reg Pointer to a ifTable_registration_ptr
 * @param loop_ctx_ref  Pointer to your loop reference.
 *
 * @retval MFD_SUCCESS : success.
 * @retval MFD_ERROR   : error.
 */
int
ifTable_loop_cleanup_context(ifTable_registration_ptr ifTable_reg,
                             ifTable_ref_loop_ctx * loop_ctx_ref)
{
    DEBUGMSGTL(("verbose:ifTable_loop_cleanup_context", "called\n"));

    netsnmp_assert(loop_ctx_ref);

    if (!loop_ctx_ref->loop_ctx)
        return MFD_ERROR;

    /*
     * release the row request context, if it wasn't taken
     */
    if (loop_ctx_ref->loop_ctx->rowreq_ctx)
        ifTable_release_rowreq_ctx(loop_ctx_ref->loop_ctx->rowreq_ctx);

    /*
     * TODO:
     * release resources
     */
    /***************************************************/
    /***             START EXAMPLE CODE              ***/
    /***---------------------------------------------***/
    /*
     * close file
     */
    if (loop_ctx_ref->loop_ctx->filep)
        fclose(loop_ctx_ref->loop_ctx->filep);

    /***---------------------------------------------***/
    /***              END  EXAMPLE CODE              ***/
    /***************************************************/

    /*
     * free loop context
     */
    free(loop_ctx_ref->loop_ctx);

    return MFD_SUCCESS;
}

/**
 * prepare row for processing.
 *
 *  When the agent has located the row for a request, this function is
 *  called to prepare the row for processing. If the data context already
 *  contains all data, you may not need to do anything.
 *
 * @param rowreq_ctx pointer to a context.
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 */
int
ifTable_row_prep(ifTable_rowreq_ctx * rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ifTable_row_prep", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    return MFD_SUCCESS;
}

/** @} */
