#!/usr/bin/perl

use Getopt::Std;

use DBI;
use Term::ReadLine;
use SNMP;

$opts{'t'} = ! eval { require Text::FormatTable; };

#defaults
$opts{'d'} = "\t";
$opts{'v'} = 1;
$opts{'l'} = 'authNoPriv';
$params = "";

getopts('hd:tR:u:l:v:a:A:x:X:p:c:t:r:',\%opts);

usage() if ($#ARGV == -1 || $opts{'h'});

my %parammap = {
    'v' => 'Version',
    'u' => 'SecName',
    'a' => 'AuthProto',
    'A' => 'AuthPass',
    'x' => 'PrivProto',
    'X' => 'PrivPass',
    'p' => 'RemotePort',
    't' => 'Timeout',
    'r' => 'Retries',
    'c' => 'Community',
    'l' => 'SecLevel'
    };

foreach my $x (keys(%opts)) {
    if ($parammap{$x}) {
	$params .= ";ad_SNMP_$parammap{$x}=$x";
    }
    push @sessparams,$parammap{$x},$x;
}

my $host = shift @ARGV;
$params .= ";ad_SNMP_DestHost=" . $host;
push @sessparms,'DestHost', $host;

# connect to the DBI interface
$AnyData::Storage::SNMP::debugre = $opts{'R'} if ($opts{'R'});
($dbh = DBI->connect("dbi:AnyData:ad_default=SNMP$params"))
    || die "\tConnection problem: $DBI::errstr\n";
$AnyData::Storage::SNMP::debugre = $opts{'R'} if ($opts{'R'});

$prompt = "snmpsh> ";

if (-f "$ENV{'HOME'}/.snmpshrc") {
    open(I, "$ENV{'HOME'}/.snmpshrc");
    while(<I>) {
	doit($_);
    }
    close(I);
}

if ($#ARGV >= 0) {
    # command line command
    doit(join(" ",@ARGV));
} else {
    # interactive shell
    $term = new Term::ReadLine 'snmpsh';
    while($cmd = $term->readline($prompt)) {
	last if ($cmd eq "exit" || $cmd eq "quit" || $cmd eq "q");
	doit($cmd, \%conf);
    }
}

sub doit {
    my $stmt = shift;
    chomp($stmt);
    next if ($stmt =~ /^\s*$/);
    next if ($stmt =~ /^\s*#/);
    my ($name, $args) = ($stmt =~ /^(\w+)\s*(.*)$/);

    #eval
    if ($name eq "eval") {
	$stmt =~ s/^eval//;
	eval $stmt;
	return;
    }

    #define alias
#    print "doing [$multi_alias]: $stmt\n";
    if ($name eq "alias" || $multi_alias) {
	if ($multi_alias) {
	    if ($stmt =~ /^\s*\}\s*$/) {
		$prompt = $oprompt;
		$multi_alias = 0;
		return;
	    }
	    push @{$aliases{$current_alias}},$stmt;
	    return;
	}
	$stmt =~ s/^alias\s+//;
	if ($args eq "") {
	    foreach $i (sort keys(%aliases)) {
		display_alias($i);
	    }
	    return;
	}
	($name, $args) = ($stmt =~ /^(\w+)\s*(.*)$/);
	if ($args eq "") {
	    display_alias($name);
	    return;
	}
#	print "alias: $name $args\n";
	if ($args eq "{") {
	    $oprompt = $prompt;
	    $prompt = "define $name> ";
	    $current_alias = $name;
	    $multi_alias = 1;
	    $aliases{$name} = [];
	    return;
	}
	$aliases{$name} = $args;
	return;
    }

    #eval aliases
    while (exists $aliases{$name}) {
#	print "modified: $stmt -> ";
	my $statements;
	if (ref($aliases{$name}) eq "ARRAY") {
	    $statements = $aliases{$name};
	} else {
	    $statements = [$aliases{$name}];
	}
	foreach my $stmt (@$statements) {
	    my @ARGS = split(/\s+/,$args);
	    #print "$stmt -> ";
	    $stmt =~ s/\\(\d+)/$ARGS[$1-1]/g;
#	    print "running $stmt\n";
	    ($name, $args) = ($stmt =~ /^(\w+)\s*(.*)$/);
	    doit($stmt);
	}
	return;
    }

    $stmt =~ s/;*$//; # get rid of trailing semicolons
    $stmt =~ s/^\s*//; # get rid of leading spaces

    my $subfn;

    if ($stmt =~ s/^printf\s+(\".*\")\s*(.*)/$2/) {
	if ($2 eq "") {
	    print eval $1;
	    return;
	}
	$subfn = \&my_printf;
	$stmt = $2;
	$printfmt = $1;
    }

    # special show columns statement
    if ($stmt =~ /^show columns from (\w+)$/) {
	my $mibnode = $SNMP::MIB{$1};
	my $entrynode = $mibnode->{children}[0];
	if (!defined($mibnode) || !defined($entrynode)) {
	    print STDERR "no such table: $1\n";
	    return;
	}
	if ($opts{'t'}) {
	    map { print $_->{label},"\n"; } sort { $a->{subID} <=> $b->{subID}} @{$entrynode->{children}};
	} else {
	    $table = Text::FormatTable->new('|r|');
	    $table->rule('-');
	    $table->head('Column');
	    $table->rule('-');
	    map { $table->row($_->{label}); } sort { $a->{subID} <=> $b->{subID}} @{$entrynode->{children}};
	    $table->rule('-');
	    print $table->render();
	}
	return;
    }

    # we have an SQL statement.  process it.
    if ($stmt =~ /^(select|insert|update|delete)/) {
	$sth = $dbh->prepare($stmt);
	$sth->execute();
	if ($stmt =~ /^select/) {
	    my $table;
	    while($row = $sth->fetchrow_arrayref) {
		if (ref($subfn) eq "CODE") {
#		print "fmt: $printfmt\n";
#		print "args:",join(",",@$row),"\n";
		    &$subfn($printfmt,@$row);
		} elsif ($opts{'t'}) {
		    print STDERR join($opts{'d'},@$row),"\n";
		} elsif (!$table) {
		    $table = Text::FormatTable->new('|r' x ($#$row+1) . "|");
		    $table->rule('-');
		    $table->head(@{$sth->{NAME}});
		    $table->rule('-');
		    $table->row(@$row);
		} else {
		    $table->row(@$row);
		}
	    }
	    if ($table) {
		$table->rule('-');
		print $table->render();
	    }
	}
	$sth->finish();
	return;
    }

    # retriaeve just one variable and display it
    if ($stmt =~ /^(get|)\s*([^\s]+)\s*[^=]/) {
	my $sess = make_session();
	if ($sess) {
	    my @results = split(/[,\s]+/,$stmt);
	    my $resultsv = new SNMP::VarList();
	    # expression stolen from the main perl SNMP module
	    map {  my ($tag, $iid) = 
		       (/^((?:\.\d+)+|(?:\w+(?:\-*\w+)+))\.?(.*)$/);
		   push @$resultsv, [$tag, $iid] } @results;
	    $sess->get($resultsv)  || 
		print STDERR "opps: $sess->{ErrorNum} $sess->{ErrString}\n";
  	    @results = ();
	    map { push @results, $_->[2] } @$resultsv;
	    if (ref($subfn) eq "CODE") {
		&$subfn($printfmt,@results);
	    } else {
		print join(" ", @results),"\n";
	    }
	} else {
	    print STDERR "could not establish a SNMP session to $host\n";
	}
	return;
    }

    # set something
    if ($stmt =~ /^(set|)\s*([^\s]+)\s=\s(.*)$/) {
	my $sess = make_session();
	if ($sess) {
	    $sess->set([$2,undef,$1]) || 
		print STDERR "opps: $sess->{ErrorNum} $sess->{ErrString}\n";
	} else {
	    print STDERR "could not establish a SNMP session to $host\n";
	}
	return;
    }

}

sub my_printf {
    my @args = @_;
#    print "begin: $args[0]\n";
    $args[0] = eval $args[0];
#    print "result: $args[0]\n";
    printf(@args);
}

sub display_alias {
    my $name = shift;
    if (exists $aliases{$name}) {
	if (ref($aliases{$name}) eq "ARRAY") {
	    print "alias $name {\n";
	    map { print "  $_\n"; } @{$aliases{$name}};
	    print "}\n";
	} else {
	    print "alias $name $aliases{$name}\n";
	}
    } else {
	print "no alias defined for \"$name\"\n";
    }
}

sub make_session {
    if (!$sess) {
	$sess = new SNMP::Session(@sessparms);
    }
    return $sess;
}


sub usage {
    print STDERR "
$0 [ARGUMENTS] HOSTNAME [SQL_COMMAND] 

  $0 implements a simple SQL shell which maps onto SNMP.  All
  statements issued within the shell are converted to SNMP requests and
  sent to HOSTNAME and the results displayed in a nice table output
  format if the Text::FormatTable module is available.  If SQL_COMMAND
  is given on the command line, then it's interpreted and control is
  returned to the caller.  If not, an interactive prompt is given where
  multiple commands can be issued.

ARGUMENTS may include:

  -t         delimiter separated output, don't print pretty tables.
  -d DELIM   use DELIM as the delimiter.  A tab is the default delimiter.

ARGUMENTS also may include the following.  See the net-snmp snmpcmd
manual page for details on what they mean:

  -v VERSION        (default: 1)
  -t TIMEOUT
  -r RETRIES
  -p PORT
  -c COMMUNITY
  -a AUTHPROTOCOL   (default: MD5)
  -x PRIVPROTOCOL   (default: DES)
  -A AUTHPASS
  -X PRIVPASS
  -l SECURITY_LEVEL (default: authNoPriv)
  
";
    exit;
}
