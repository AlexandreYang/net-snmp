#!/usr/bin/perl

use Getopt::Std;

use DBI;
use Term::ReadLine;
use SNMP;
use AutoLoader;
use IO::File;

$opts{'t'} = ! eval { require Text::FormatTable; };
$ansicolor = eval { require Term::ANSIColor; };
if ($ansicolor) {
    $begin = Term::ANSIColor::color("BOLD", "RED");
    $end = Term::ANSIColor::RESET();
} else {
    $begin = $end = "*";
}


#defaults
$opts{'d'} = "\t";
$opts{'v'} = 1;
$opts{'l'} = 'authNoPriv';
$params = "";

getopts('hd:tR:u:l:v:a:A:x:X:p:c:t:r:',\%opts);

usage() if ($#ARGV == -1 || $opts{'h'});

my %parammap = {
    'v' => 'Version',
    'u' => 'SecName',
    'a' => 'AuthProto',
    'A' => 'AuthPass',
    'x' => 'PrivProto',
    'X' => 'PrivPass',
    'p' => 'RemotePort',
    't' => 'Timeout',
    'r' => 'Retries',
    'c' => 'Community',
    'l' => 'SecLevel'
    };

foreach my $x (keys(%opts)) {
    if ($parammap{$x}) {
	$params .= ";ad_SNMP_$parammap{$x}=$x";
    }
    push @sessparams,$parammap{$x},$x;
}

my $host = shift @ARGV;
$params .= ";ad_SNMP_DestHost=" . $host;
push @sessparms,'DestHost', $host;

# connect to the DBI interface
$AnyData::Storage::SNMP::debugre = $opts{'R'} if ($opts{'R'});
($dbh = DBI->connect("dbi:AnyData:ad_default=SNMP$params"))
    || die "\tConnection problem: $DBI::errstr\n";
$AnyData::Storage::SNMP::debugre = $opts{'R'} if ($opts{'R'});

$prompt = "snmpsh> ";

if (-f "$ENV{'HOME'}/.snmpshrc") {
    source_file("$ENV{'HOME'}/.snmpshrc");
}

if ($#ARGV >= 0) {
    # command line command
    snmpsh(join(" ",@ARGV));
} else {
    # interactive shell
    $ENV{'PERL_RL'}='o=0' if (!exists($ENV{'PERL_RL'}));
    # the ornaments are too ugly
    $term = new Term::ReadLine 'snmpsh';
    while($cmd = $term->readline($prompt)) {
	last if ($cmd eq "exit" || $cmd eq "quit" || $cmd eq "q");
	snmpsh($cmd, \%conf);
    }
}

sub source_file {
    my $fh = new IO::File;
    if ($fh->open("<$_[0]")) {
	while(<$fh>) {
	    if (s/<<\s*(\w+)$//) {
		my $stopat = $1;
		my $lines = $_;
		while(<$fh>) {
		    last if (/$stopat/);
		    $lines .= $_;
		}
		$_ = $lines;
	    }
	    snmpsh($_);
	}
    } else {
	print STDERR "no such file: $_[0]\n";
    }
}

sub snmpsh {
    my $stmt = shift;
    chomp($stmt);
    next if ($stmt =~ /^\s*$/);
    next if ($stmt =~ /^\s*\#/);
    my ($name, $args) = ($stmt =~ /^(\w+)\s*(.*)$/);

    #eval
    if ($name eq "eval") {
	$stmt =~ s/^eval//;
	eval $stmt;
	return;
    }

    #define alias
#    print "doing [$multi_alias]: $stmt\n";
    if ($name eq "alias" || $multi_alias) {
	if ($multi_alias) {
	    if ($stmt =~ /^\s*\}\s*$/) {
		$prompt = $oprompt;
		$multi_alias = 0;
		return;
	    }
	    push @{$aliases{$current_alias}},$stmt;
	    return;
	}
	$stmt =~ s/^alias\s+//;
	if ($args eq "") {
	    foreach $i (sort keys(%aliases)) {
		display_alias($i);
	    }
	    return;
	}
	($name, $args) = ($stmt =~ /^(\w+)\s*(.*)$/);
	if ($args eq "") {
	    display_alias($name);
	    return;
	}
#	print "alias: $name $args\n";
	if ($args eq "{") {
	    $oprompt = $prompt;
	    $prompt = "define $name> ";
	    $current_alias = $name;
	    $multi_alias = 1;
	    $aliases{$name} = [];
	    return;
	}
	$aliases{$name} = $args;
	return;
    }

    #eval aliases
    while (exists $aliases{$name}) {
#	print "modified: $stmt -> ";
	my $statements;
	if (ref($aliases{$name}) eq "ARRAY") {
	    $statements = $aliases{$name};
	} else {
	    $statements = [$aliases{$name}];
	}
	foreach my $stmt (@$statements) {
	    my @ARGS = split(/\s+/,$args);
	    #print "$stmt -> ";
	    $stmt =~ s/\\(\d+)/$ARGS[$1-1]/g;
#	    print "running $stmt\n";
	    ($name, $args) = ($stmt =~ /^(\w+)\s*(.*)$/);
	    snmpsh($stmt);
	}
	return;
    }

    $stmt =~ s/;*$//; # get rid of trailing semicolons
    $stmt =~ s/^\s*//; # get rid of leading spaces

    my $subfn;

    if ($stmt =~ s/^printf\s+(\".*\")\s*(.*)/$2/) {
	if ($2 eq "") {
	    print eval $1;
	    return;
	}
	$subfn = \&my_printf;
	$stmt = $2;
	$printfmt = $1;
    }

    # special show columns statement
    if ($stmt =~ /^show columns from (\w+)$/) {
	my $mibnode = $SNMP::MIB{$1};
	my $entrynode = $mibnode->{children}[0];
	if (!defined($mibnode) || !defined($entrynode)) {
	    print STDERR "no such table: $1\n";
	    return;
	}
	if ($opts{'t'}) {
	    map { print $_->{label},"\n"; } sort { $a->{subID} <=> $b->{subID}} @{$entrynode->{children}};
	} else {
	    $table = Text::FormatTable->new('|r|');
	    $table->rule('-');
	    $table->head('Column');
	    $table->rule('-');
	    map { $table->row($_->{label}); } sort { $a->{subID} <=> $b->{subID}} @{$entrynode->{children}};
	    $table->rule('-');
	    print $table->render();
	}
	return;
    }

    if ($stmt =~ /^eval (.*)/) {
	eval $1;
    }

    if ($stmt =~ /^source\s+(.*)/) {
	source_file($1);
	return;
    }

    # we have an SQL statement.  process it.
    if ($stmt =~ /^watch\s+(.*)/) {
	$running_watch = 1;
	my $cmd = $1;
	my $delay = 1;
	my $clear = `clear`;
	if ($cmd =~ s/^(\d+)\s+(.*)/$2/) {
	    $delay = $1;
	    $cmd = $2;
	}
	$SIG{'TERM'} = sub { $running_watch = 0; };
	$SIG{'INT'} = sub { $running_watch = 0; };
	while($running_watch) {
	    print $clear;
	    snmpsh($cmd);
	    sleep($delay);
	}
	$SIG{'TERM'} = \&exit;
	$SIG{'INT'} = \&exit;
	return;
    }


    # we have an SQL statement.  process it.
    if ($stmt =~ /^(select|insert|update|delete)/) {
	$sth = $dbh->prepare($stmt);
	$sth->execute();
	if ($stmt =~ /^select/) {
	    my $table;
	    my $older_data = $old_data;
	    $old_data = [];
	    my $oldcount = 0;
	    while($row = $sth->fetchrow_arrayref) {
		
		# self printing;
		if (ref($subfn) eq "CODE") {
		    &$subfn($printfmt,@$row);
		    next;
		}

		if ($running_watch) {
		    $newrow=[];
		    my $count;
		    for($count = 0; $count <= $#$row; $count++) {
			if ($older_data &&
			    $row->[$count] ne
			    $older_data->[$oldcount][$count]) {
			    push @$newrow,"$begin$row->[$count]$end";
			} else {
			    push @$newrow,$row->[$count];
			}
			$old_data->[$oldcount][$count] = $row->[$count];
		    }
		    $oldcount++;
		    $row = $newrow;
 		}

		if ($opts{'t'}) {
		    print join($opts{'d'},@$row),"\n";
		} elsif (!$table) {
		    $table = Text::FormatTable->new('|r' x ($#$row+1) . "|");
		    $table->rule('-');
		    $table->head(@{$sth->{NAME}});
		    $table->rule('-');
		    $table->row(@$row);
		} else {
		    $table->row(@$row);
		}
	    }
	    if ($table) {
		$table->rule('-');
		print $table->render();
	    }
	}
	$sth->finish();
	return;
    }

    # retrieve just one variable and display it
    if ($stmt =~ /^(get|)\s*([^\s]+)\s*[^=]/) {
	my $sess = make_session();
	if ($sess) {
	    my @results = split(/[,\s]+/,$stmt);
	    my $resultsv = new SNMP::VarList();
	    # expression stolen from the main perl SNMP module
	    map {  my ($tag, $iid) = 
		       (/^((?:\.\d+)+|(?:\w+(?:\-*\w+)+))\.?(.*)$/);
		   push @$resultsv, [$tag, $iid] } @results;
	    $sess->get($resultsv)  || 
		print STDERR "Error: $sess->{ErrorNum} $sess->{ErrString}\n";
  	    @results = ();
	    map { push @results, $_->[2] } @$resultsv;
	    if (ref($subfn) eq "CODE") {
		&$subfn($printfmt,@results);
	    } else {
		print join(" ", @results),"\n";
	    }
	} else {
	    print STDERR "could not establish a SNMP session to $host\n";
	}
	return;
    }

    # set something
    if ($stmt =~ /^(set|)\s*([^\s]+)\s=\s(.*)$/) {
	my $sess = make_session();
	if ($sess) {
	    $sess->set([$2,undef,$1]) || 
		print STDERR "opps: $sess->{ErrorNum} $sess->{ErrString}\n";
	} else {
	    print STDERR "could not establish a SNMP session to $host\n";
	}
	return;
    }
}

sub auto_snmp {
    my $node = $SNMP::MIB{$_[0]};
#    print STDERR "snmpsh::fetch_snmp $_[0] $node->{label}\n";
    my $indexes = $node->{parent}{indexes};
    if ($#$indexes > -1) {
#	print STDERR "column\n";
	# table 
    } else {
	# scalar
	if (exists($_[1])) {
	    my $sess = make_session();
	    my $val = $sess->set([$_[0],0,$_[1]]) || return;
#	    print STDERR "scalar set: $val\n";
	    return $val;
	} else {
	    my $sess = make_session();
	    my $val = $sess->get([$_[0],0]);
#	    print STDERR "scalar get: $val\n";
	    return $val;
	}
    }
}

sub AUTOLOAD {
    my $nodename = $AUTOLOAD;
    $nodename =~ s/.*:://;
    print STDERR "snmpsh::AUTOLOAD $AUTOLOAD $nodename\n";
    if ($SNMP::MIB{$nodename}) {
	eval << "END";
        sub $AUTOLOAD {
	    auto_snmp($nodename, \@_);
	}
END
	goto &$AUTOLOAD;
    }
    print STDERR join(",",@_),"\n";
}

sub my_printf {
    my @args = @_;
#    print "begin: $args[0]\n";
    $args[0] = eval $args[0];
#    print "result: $args[0]\n";
    printf(@args);
}

sub display_alias {
    my $name = shift;
    if (exists $aliases{$name}) {
	if (ref($aliases{$name}) eq "ARRAY") {
	    print "alias $name {\n";
	    map { print "  $_\n"; } @{$aliases{$name}};
	    print "}\n";
	} else {
	    print "alias $name $aliases{$name}\n";
	}
    } else {
	print "no alias defined for \"$name\"\n";
    }
}

sub make_session {
    if (!$sess) {
	$sess = new SNMP::Session(@sessparms);
    }
    return $sess;
}


sub usage {
    print STDERR "
$0 [ARGUMENTS] HOSTNAME [SQL_COMMAND] 

  $0 implements a simple SQL shell which maps onto SNMP.  All
  statements issued within the shell are converted to SNMP requests and
  sent to HOSTNAME and the results displayed in a nice table output
  format if the Text::FormatTable module is available.  If SQL_COMMAND
  is given on the command line, then it's interpreted and control is
  returned to the caller.  If not, an interactive prompt is given where
  multiple commands can be issued.

ARGUMENTS may include:

  -t         delimiter separated output, don't print pretty tables.
  -d DELIM   use DELIM as the delimiter.  A tab is the default delimiter.

ARGUMENTS also may include the following.  See the net-snmp snmpcmd
manual page for details on what they mean:

  -v VERSION        (default: 1)
  -t TIMEOUT
  -r RETRIES
  -p PORT
  -c COMMUNITY
  -a AUTHPROTOCOL   (default: MD5)
  -x PRIVPROTOCOL   (default: DES)
  -A AUTHPASS
  -X PRIVPASS
  -l SECURITY_LEVEL (default: authNoPriv)
  
";
    exit;
}
